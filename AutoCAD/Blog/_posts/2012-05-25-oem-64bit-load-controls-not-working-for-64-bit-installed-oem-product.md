---
layout: "post"
title: "OEM 64bit - Load controls not working for 64 bit installed OEM product"
date: "2012-05-25 10:31:44"
author: "Wayne Brill"
categories:
  - "2011"
  - "2012"
  - "AutoCAD OEM"
  - "Wayne Brill"
original_url: "https://adndevblog.typepad.com/autocad/2012/05/oem-64bit-load-controls-not-working-for-64-bit-installed-oem-product.html "
typepad_basename: "oem-64bit-load-controls-not-working-for-64-bit-installed-oem-product"
typepad_status: "Publish"
---

<p>By <a href="http://adndevblog.typepad.com/autocad/wayne-brill.html" target="_self">Wayne Brill</a></p>  <p><b>Issue</b></p>  <p>I have created OEM application and an installer using the OEM InstallerWizard. I install my application on a new 64 bit system. I run the application and the custom modules that I added in the OEM MakeWizard with a load controls setting of 2, are not automatically loaded. It works as expected using 32 bit. (the custom module is loaded) When I look into windows registry, I found the installation created an entry under HKEY_LOCAL_MACHINE\SOFWARE\Wow6432Node\MYAPP\.....    <br />but the OEM product still looks for value under&#160; HKEY_LOCAL_MACHINE\SOFWARE\MYAPP\.....&#160; which caused our OEM product to fail when loading my custom module automatically. Is there a way to fix this behavior for 64bit OEM applications?</p>  <p><a name="section2"></a></p>  <p><b>Solution</b></p>  <p>The problem with the OEM InstallerWizard is reported in a Change Request. (fixed in 2013) The OEM InstallerWizard is not fully adding the required settings for modules in a 64bit install.</p>  <p>To resolve this problem follow these steps:</p>  <p>1) Install and load the ORCA.exe application from Microsoft. (or use another tool that can modify msi files)    <br />2) Open your 64bit OEM Product MSI in ORCA     <br />3) Goto View-&gt;Summary information     <br />4) Set the Platform to x64     <br />5) Save     <br />6) Click on the Components Table on the left     <br />7) Make sure the Attributes setting for all components bitwise and’s with 256… So if the value was 4, then make it 260. But if the value was 260, leave it alone.     <br />Here’s the documentation on the Components table: <a href="http://msdn.microsoft.com/en-us/library/aa368007(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/aa368007(v=vs.85).aspx</a>     <br />8) save and test</p>  <p>More detail about the solution. If you define binary bits in a byte</p>  <p>The first bit if set, = 1    <br />The second bit, if set, = 2     <br />Third, if set, =4     <br />8,     <br />16,     <br />32,     <br />64,     <br />128,     <br />256</p>  <p>If you take a denary number such as 37, this will be defined in binary as 100101, that is from right to left bit 1=on(1), bit 2=off, bit 3=on(4), bits 4,5 off and finally bit 6(32) on. You’ll notice that if you add all of the numbers in ( )’s that they will equal 37, that’s how they relate. Interestingly, the bit order on UNIX platforms is reversed in a single byte. The solution is to ensure the number is and’d with 256, what this means is that bit 8 needs to be turned on…So, if the number is 200 clearly bit 8 is off (because 200 is smaller than 256), so you can add 256 to that to make 456. If the number is 1829, that’s 11100100101 in binary, which shows that bit 8 is off, so you need to add 256 to it in order to turn it on.</p>

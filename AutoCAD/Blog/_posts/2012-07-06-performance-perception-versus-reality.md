---
layout: "post"
title: "Performance &ndash; perception versus reality"
date: "2012-07-06 12:43:27"
author: "Madhukar Moogala"
categories:
  - "Stephen Preston"
original_url: "https://adndevblog.typepad.com/autocad/2012/07/performance-perception-versus-reality.html "
typepad_basename: "performance-perception-versus-reality"
typepad_status: "Publish"
---

<p>By <a href="http://adndevblog.typepad.com/autocad/stephen-preston.html">Stephen Preston</a></p>
<p>A good comment on performance to my <a href="http://adndevblog.typepad.com/autocad/2012/07/objectidgetobject.html">ObjectId.GetObject</a> post by Anonymoose (a.k.a. Tony Tanzillo) reminded me of some fun discussions I had with <a href="http://adndevblog.typepad.com/autocad/fenton-webb.html">Fenton</a> a while ago about how important it is (or not) to optimize your code to squeeze it for every possible nanosecond of performance that I thought was worth summarizing here. (Thanks for the prod, Tony).</p>
<p>The answer to the question, of course, is that it depends.</p>
<p>For real-time trading systems, it is claimed that <a href="http://www.npr.org/blogs/money/2010/06/08/127563433/the-tuesday-podcast-the-million-dollar-microsecond" target="_blank">a microsecond latency and processing delay can ‘cost’ a company approximately $1million per day in unrealized profits</a>.</p>
<p>Then there’s the apocryphal tale of the development team who profiled their software and found that it spent over 90% of its time executing one loop. After weeks of optimization effort, the profiling showed the program was still spending the same fraction of its time in that same loop. That was when they realized that they’d just invested several $100,000 in optimizing their idle loop. (This is probably the same apocryphal company that paid its testers a bonus for every new bug they found and paid its programmers a bonus for every bug they fixed) <img alt="Open-mouthed smile" class="wlEmoticon wlEmoticon-openmouthedsmile" src="/assets/image_50437.jpg" style="border-style: none;" />.</p>
<p>If you’re performing a long operation, or a batch operation, that is tying up the users machine for minutes, hours, or even days, then its definitely worth investing in speeding up your batch process. A good example of this was an ADN partner (hi Jack, if you’re reading this <img alt="Smile" class="wlEmoticon wlEmoticon-smile" src="/assets/image_70563.jpg" style="border-style: none;" />) who came to our very first <a href="http://usa.autodesk.com/adsk/servlet/item?siteID=123112&amp;id=13713450" target="_blank">DevLab</a>. He had a LISP routine that batch processed (a lot of) drawings to update their title blocks, and had come to DevLab to find out if converting the routine to .NET would speed things up. It did – he used Database.ReadDwgFile() in .NET to open each DWG as a side database instead of opening each in a document as he’d done in LISP – the result was that a batch process that previously took all night completed in just a few minutes.</p>
<p><em>If you can’t significantly speed up a long operation, then you may be able to move the process to the cloud so your user can carry on using their computer as the process runs.</em></p>
<p>The benefits of optimization or ‘cloudification’ (I made up that word <img alt="Confused smile" class="wlEmoticon wlEmoticon-confusedsmile" src="/assets/image_546630.jpg" style="border-style: none;" />) are very clear for these long, uninterruptable operations. But many of us are writing applications that require interaction with the user. Once you have a human involved, its not just about stopwatches – psychology plays a big part in the user’s perception of whether your software ‘feels’ fast or slow. Something simple like adding a well designed progress indicator can make the user feel that the application is faster without you having to optimize any code at all. Conversely, if you do optimize your code, there is a threshold you have to exceed before the user actually notices. And if your code is stopping to ask the user to pick points on the screen, it doesn’t matter how long the code that processes those points takes to run – as long as the user doesn’t ‘perceive’ a delay. Any optimization work over and above removing the ‘perception’ of a delay is essentially wasted effort.</p>
<p><em>An example: If you have a VMWare (or similar), try installing AutoCAD (or any other application that uses a progress bar in its installer). Then reset the VMWare and run the installation again, but with a piece of sticky tape covering the progress indicator. Which ‘feels’ quicker&#39;?</em></p>
<p>There are lots of books, studies, white papers etc. on this topic. Go ahead and Google, or ask your friendly neighborhood <a href="http://dux.typepad.com/" target="_blank">user experience designer</a>. My quick search uncovered <a href="http://codebetter.com/howarddierking/2009/12/12/understanding-perceived-performance/" target="_blank">these</a> <a href="http://codebetter.com/howarddierking/2009/12/14/more-on-perceived-performance/" target="_blank">two</a> straightforward blog posts that summarize the blogger’s takeaways from reading <a href="http://www.amazon.com/Designing-Engineering-Time-Psychology-Perception/dp/0321509188/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1260410750&amp;sr=8-1" target="_blank">this book</a>. The book’s author has posted a handy public cheat sheet <a href="http://www.stevenseow.com/papers/UI%20Timing%20Cheatsheet.pdf" target="_blank">here</a>. Some of the points made are very interesting, and (for me at least) not at all intuitive.</p>
<p>Finally, I promise to ask Fenton to write up a blog post on the relative speeds of different AutoCAD APIs and API constructs based on the work he did for an AU class several years ago. (Whether he agrees to do it is another matter, of course <img alt="Winking smile" class="wlEmoticon wlEmoticon-winkingsmile" src="/assets/image_497549.jpg" style="border-style: none;" />).</p>

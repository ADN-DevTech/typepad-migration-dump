---
layout: "post"
title: "Proxy graphic in DXF binary chunk interpretation"
date: "2013-02-01 11:57:07"
author: "Fenton Webb"
categories:
  - "2010"
  - "2011"
  - "2012"
  - "2013"
  - "AutoCAD"
  - "Fenton Webb"
original_url: "https://adndevblog.typepad.com/autocad/2013/02/proxy-graphic-in-dxf-binary-chunk-interpretation.html "
typepad_basename: "proxy-graphic-in-dxf-binary-chunk-interpretation"
typepad_status: "Publish"
---

<p>by <a href="http://adndevblog.typepad.com/autocad/fenton-webb.html">Fenton Webb</a></p>  <p><b>Issue</b></p>  <p>How to interpret the proxy graphic binary data enclosed in AutoCAD DXF files?</p>  <p><a name="section2"></a></p>  <p><b>Solution</b></p>  <p>Binary Data enclosed in DXF file is stored by block of 256 bytes maximum under   <br />DXF code 310 (i.e. 'kDxfBinaryChunk'). A complete description of all standard    <br />binary chunks is available in <a href="http://adndevblog.typepad.com/autocad/2013/02/dxf-files-binary-chunk-interpretation.html">dxf binary chunk interpretation</a>    <br />as this one will only describe the proxy graphics binary chunk.</p>  <p>DXF ENTITY proxy graphics section is present for all non-AutoCAD core entities   <br />(i.e. custom entities, or AutoCAD entities defined in ARX/DBX modules). It is    <br />always preceded by a DXF code 92 (of type 'int') which indicates the length of    <br />the binary chunk which follow.</p>  <p>The binary chunk block contains the proxy graphics generated by the entity, when   <br />its 'saveAs()' method was called by AutoCAD upon the DXFOUT command call, as    <br />well as some non graphical information which are related to the graphic such as    <br />the bounding box, color used, etc....</p>  <p>The 'saveAs()' method may call the 'worldDraw()' method which generates the   <br />graphic. In case 'worldDraw()' return 'false', the system calls 'viewporDraw()'    <br />to generate the viewport dependent graphic. It means the proxy graphic binary    <br />chunk contains the graphic primitive calls representation called during    <br />worldDraw() or viewportDraw(). Finally the proxy graphic binary chunk is the    <br />same thing as a Windows Metafile. Instead of containing an image, it contains    <br />the instruction to redraw the last representation generated by    <br />worldDraw()/viewportDraw().</p>  <p>Depending of the settings of AutoCAD (i.e. Proxy Graphic Never Saved), and the   <br />presence of the ARX/DBX module when the DXFOUT operation occurred, the proxy    <br />graphics binary chunk can contain:    <br />- a bounding box with class name and logical application name,    <br />- the last know entity graphic description.</p>  <p>As said above the proxy graphics binary chunk contains just an output of the   <br />AcGiWorldDraw/AcGiViewportDraw vector collector classes which were called upon    <br />DXFOUT. The proxy graphics binary chunk' output is of form:</p>  <p>{Header}[{Command} [{Command} [{Command} [...]]]]</p>  <p>and the {Command} packet is of form:</p>  <p>{Command Packet Length} {Command OPCODE} [{Command Argument} {Command   <br />argument} ...]</p>  <p>* To interpret the output of the {Header}, apply the following rule:</p>  <p>{Header}   <br />{int32 / Length of the binary chunk} {int32 / Number of commands}</p>  <p>* To Interpret a {Command} packet, apply the following rules:</p>  <p>{Command}   <br />{int 32 / Command Packet Length} {int 32 / Command OPCODE} [{Command    <br />Argument} {Command argument} ...]</p>  <p>{Command Argument}   <br />The command argument(s) depends of the OPCODE, see below for more    <br />information.</p>  <p>* OPCODE=0 (kAcGiOpBad)   <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>  <p>Should not happen. If it does, skip to packet length. This has been provide   <br />for backward compatibility for r13/r14 reading AutoCAD 2000 DXF file for    <br />example.    <br />{Nothing}</p>  <p>* OPCODE=1 (kAcGiOpSetExtents)   <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>  <p>This one define an extent, by providing two 3D points.   <br />{AcGePoint3d / Min. point} {AcGePoint3d / Max. point}</p>  <p>* OPCODE=2 (kAcGiOpCircle1)   <br />&lt;AcGiGeometry::circle (const AcGePoint3d&amp; center, const double radius, const    <br />AcGeVector3d &amp;normal)&gt;</p>  <p>Displays a circle primitive with center and a radius.   <br />{AcGePoint3d / Center} {double / Radius} {AcGeVector3d / Normal}</p>  <p>* OPCODE=3 (kAcGiOpCircle2)   <br />&lt;AcGiGeometry::circle (const AcGePoint3d&amp; pt1, const AcGePoint3d&amp; pt2, const    <br />AcGePoint3d&amp; pt3)&gt;</p>  <p>Displays a circle primitive that is defined by the three points--pt1, pt2, and   <br />pt3--which all lie on the circle.    <br />{AcGePoint3d / 1st point} {AcGePoint3d / 2nd point} {AcGePoint3d / 3rdt point}</p>  <p>* OPCODE=4 (kAcGiOpCircularArc1)   <br />&lt;AcGiGeometry::circularArc (const AcGePoint3d&amp; center, const double radius,    <br />const AcGeVector3d&amp; normal, const AcGeVector3d&amp; startVector, const double    <br />sweepAngle, const AcGiArcType arcType)&gt;</p>  <p>Displays an arc primitive defined by the arc's center of curvature center, the   <br />radius of curvature radius, the containment plane's normal vector normal, the    <br />vector from the center of curvature to the arc start point startVector, the    <br />angle that the arc spans sweepAngle, and the arc type arcType.    <br />{AcGePoint3d / Center} {double / Radius} {AcGeVector3d / Normal} {AcGeVector3d    <br />/ Start vector} {double / Angle} {int32 / Arc type}</p>  <p>* OPCODE=5 (kAcGiOpCircularArc2)   <br />&lt;AcGiGeometry::circularArc (const AcGePoint3d&amp; start, const AcGePoint3d&amp;    <br />point, const AcGePoint3d&amp; end, const AcGiArcType arcType)&gt;</p>  <p>Displays an arc primitive defined by the three points.   <br />{AcGePoint3d / 1st point} {AcGePoint3d / 2nd point} {AcGePoint3d / 3rdt point}    <br />{int32 / Arc type}</p>  <p>* OPCODE=6 (kAcGiOpPolyline)   <br />&lt;AcGiGeometry::polyline (const Adesk::UInt32 nbPoints, const AcGePoint3d*    <br />pVertexList, const AcGeVector3d* pNormal, Adesk::Int32 lBaseSubEntMarker)&gt;</p>  <p>Draws a polyline.   <br />{int32 / Number of vertex} {AcGePoint3d / Vertex} [{AcGePoint3d / Vertex}    <br />[...]]</p>  <p>* OPCODE=7 (kAcGiOpPolygon)   <br />&lt;AcGiGeometry::polygon (const Adesk::UInt32 nbPoints, const AcGePoint3d*    <br />pVertexList)&gt;</p>  <p>Draws a polygon.   <br />{int32 / Number of vertex} {AcGePoint3d / Vertex} [{AcGePoint3d / Vertex}    <br />[...]]    <br />* OPCODE=8 (kAcGiOpMesh)    <br />&lt;AcGiGeometry::mesh (const Adesk::UInt32 rows, const Adesk::UInt32 columns,    <br />const AcGePoint3d* pVertexList, const AcGiEdgeData* pEdgeData, const    <br />AcGiFaceData* pFaceData, const AcGiVertexData* pVertexData)&gt;</p>  <p>Draws a mesh.   <br />{int32 / Number of rows} {int32 / Number of columns} {Vertex List} {Edge Data    <br />Packet} {Face Data Packet} {Vertex Data Packet}</p>  <p>Number of Vertexes: {Number of rows} * {Number of columns}   <br />Number of Edges: 2 * {Number of Vertexes} - {Number of rows} - {Number of    <br />columns}    <br />Number of Faces: ({Number of rows} - 1) * ({Number of columns} - 1)</p>  <p>{Vertext List}   <br />{AcGepoint3d / Vertex} [{AcGepoint3d / Vertex} [...]]</p>  <p>{Edge Data Packet}   <br />{int32 / Edge info type} {Edge data}    <br />'Edge info type' is a bitwise value which indicates what are the data    <br />behind. NB: 'Edge data' stored are order dependant.    <br />Bit values: ACGI_COLORS (0x01), ACGI_LAYER_IDS (0x100), ACGI_LINETYPE_IDS    <br />(0x200), ACGI_MARKERS (0x20), ACGI_VIS_DATA (0x40)</p>  <p>{Edge data}   <br />* ACGI_COLORS &lt;array of 'short int'&gt;    <br />{int16 / Color index} [{int16 / Color index} [...]]    <br />* ACGI_LAYER_IDS &lt;array of 'id'&gt;    <br />{AcDbHardPointerId / Layer ID} [{AcDbHardPointerId / Layer ID} [...]]    <br />* ACGI_LINETYPE_IDS &lt;array of 'id'&gt;    <br />{AcDbHardPointerId / Linetype ID} [{AcDbHardPointerId / Linetype ID}    <br />[...]]    <br />* ACGI_COLORS &lt;array of 'int'&gt;    <br />{int32 / ACGI marker} [{int32 / ACGI marker} [...]]    <br />* ACGI_VIS_DATA &lt;array of 'Adesk::Boolean'&gt;    <br />{int8 / Visibilit flag} [{int8 / Visibilit flag} [...]]</p>  <p>{Face Data Packet}   <br />{int32 / Face info type} {Face data}    <br />'Face info type' is a bitwise value which indicates what are the data    <br />behind. NB: 'Face data' stored are order dependant.    <br />Bit values: ACGI_COLORS (0x01), ACGI_LAYER_IDS (0x100), ACGI_MARKERS (0x20),    <br />ACGI_NORMALS (0x80), ACGI_VIS_DATA (0x40)</p>  <p>{Face data}   <br />* ACGI_COLORS &lt;array of 'short int'&gt;    <br />{int16 / Color index} [{int16 / Color index} [...]]    <br />* ACGI_LAYER_IDS &lt;array of 'id'&gt;    <br />{AcDbHardPointerId / Layer ID} [{AcDbHardPointerId / Layer ID} [...]]    <br />* ACGI_COLORS &lt;array of 'int'&gt;    <br />{int32 / ACGI marker} [{int32 / ACGI marker} [...]]    <br />* ACGI_NORMALS &lt;array of 'AcGeVector3d'&gt;    <br />{AcGeVector3d / Normal} [{AcGeVector3d / Normal} [...]]    <br />* ACGI_VIS_DATA &lt;array of 'Adesk::Boolean'&gt;    <br />{int8 / Visibilit flag} [{int8 / Visibilit flag} [...]]</p>  <p>{Vertex Data Packet}   <br />{int32 / Vertex info type} {Vertex data}    <br />'Vertex info type' is a bitwise value which indicates what are the data    <br />behind. NB: 'Vertex data' stored are order dependant.    <br />Bit values: ACGI_NORMALS (0x80), ACGI_ORIENTATION (0x400)</p>  <p>{Vertex data}   <br />* ACGI_NORMALS &lt;array of 'AcGeVector3d'&gt;    <br />{AcGeVector3d / Normal} [{AcGeVector3d / Normal} [...]]    <br />* ACGI_ORIENTATION &lt;array of 'int'&gt;    <br />{int32 / AcGiOrientationType} [{int32 / AcGiOrientationType} [...]]</p>  <p>* OPCODE=9 (kAcGiOpShell)   <br />&lt;AcGiGeometry::shell (const Adesk::UInt32 nbVertex, const AcGePoint3d*    <br />pVertexList, const Adesk::UInt32 faceListSize, const Adesk::Int32* pFaceList,    <br />const AcGiEdgeData* pEdgeData, const AcGiFaceData* pFaceData, const    <br />AcGiVertexData* pVertexData, const resbuf* pResBuf)&gt;</p>  <p>Draws a shell.   <br />{int32 / Number of vertexes} {Vertex List} {int32 / Face list size} {Face    <br />list} {Edge Data Packet} {Face Data Packet} {Vertex Data Packet}</p>  <p>{Vertext List}   <br />{AcGepoint3d / Number of vertex} [{AcGepoint3d / Vertex} [...]]</p>  <p>{Face list}   <br />{int32 / Face vertex count} {int32 / Vertex indice} [{int32 / Vertex indice}    <br />[...]]</p>  <p>{Edge Data Packet}   <br />See mesh definition above.</p>  <p>{Face Data Packet}   <br />See mesh definition above.</p>  <p>{Vertex Data Packet}   <br />See mesh definition above.</p>  <p>* OPCODE=10 (kAcGiOpText1)   <br />&lt;AcGiGeometry::text (const AcGePoint3d&amp; position, const AcGeVector3d&amp; normal,    <br />const AcGeVector3d&amp; direction, const double height, const double width, const    <br />double oblique, const char* pMsg)&gt;</p>  <p>Draws a text.   <br />{AcGePoint3d / Position} {AcGeVector3d / Normal} {AcGeVector3d / Direction}    <br />{double / Height} {double / Widht} {double / Oblique} {char * / Text string}</p>  <p>* OPCODE=11 (kAcGiOpText2)   <br />&lt;AcGiGeometry::text (const AcGePoint3d&amp; position, const AcGeVector3d&amp; normal,    <br />const AcGeVector3d&amp; direction, const char* pMsg, const Adesk::Int32 length,    <br />const Adesk::Boolean raw, const AcGiTextStyle&amp; pTextStyle)&gt;</p>  <p>Draws a text.   <br />{AcGePoint3d / Position} {AcGeVector3d / Normal} {AcGeVector3d / Direction}    <br />{char * / Text string} {int32 / length} {int32 / Raw code} {double / Text size}    <br />{double / Xscale} {double / Obliquing angle} {double / Tracking percentage}    <br />{int32 / IsBackward} {int32 / IsUpsideDown} {int32 / IsVertical} {int32 /    <br />IsUnderlined} {int32/ IsOverlined} {char * / Font name} {char * / Big font name}</p>  <p>* OPCODE=12 (kAcGiOpXLine)   <br />&lt;AcGiGeometry::xline(const AcGePoint3d&amp; oneXlinePoint, const AcGePoint3d&amp;    <br />aDifferentXlinePoint)&gt;</p>  <p>An xline passing '1st point' and a '2nd point' is displayed.   <br />{AcGePoint3d / 1st point} {AcGePoint3d / 2nd point}</p>  <p>* OPCODE=13 (kAcGiOpRay)   <br />&lt;AcGiGeometry::ray (const AcGePoint3d&amp; raysStartingPoint, const AcGePoint3d&amp;    <br />aDifferentRayPoint)&gt;</p>  <p>Displays a ray that starts at '1st point' and passes through a '2nd point'.   <br />{AcGePoint3d / 1st point} {AcGePoint3d / 2nd point}</p>  <p>* OPCODE=14 (kAcGiOpColor)   <br />&lt;AcGiSubEntityTraits::setColor (const Adesk::UInt16 color)&gt;</p>  <p>{unsigned int32 / Color index}   <br />* OPCODE=15 (kAcGiOpLayerName)    <br />&lt;AcGiSubEntityTraits::setLayer (const AcDbObjectId layerId)&gt;</p>  <p>{char * / Layer name}</p>  <p>* OPCODE=16 (kAcGiOpLayerIndex)   <br />&lt;AcGiSubEntityTraits::setLayer (const AcDbObjectId layerId)&gt;</p>  <p>{AcDbHardPointerId / Layer ID}</p>  <p>* OPCODE=17 (kAcGiOpLineTypeName)   <br />&lt;AcGiSubEntityTraits::setLineType (const AcDbObjectId linetypeId)&gt;</p>  <p>{char * / Linetype name}</p>  <p>* OPCODE=18 (kAcGiOpLineTypeIndex)   <br />&lt;AcGiSubEntityTraits::setLineType (const AcDbObjectId linetypeId)&gt;</p>  <p>{AcDbHardPointerId / Linetype ID}</p>  <p>* OPCODE=19 (kAcGiOpSelectionMarker)   <br />&lt;AcGiSubEntityTraits::setSelectionMarker (const Adesk::Int32 markerId)&gt;</p>  <p>{unsigned int32 / ACGI marker}</p>  <p>* OPCODE=20 (kAcGiOpFillType)   <br />&lt;AcGiSubEntityTraits::setFillType (const AcGiFillType fill)&gt;</p>  <p>{unsigned int32 / AcGiFillType}</p>  <p>* OPCODE=21 (kAcGiBoundingBoxSave)   <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>  <p>{Nothing}</p>  <p>// new ones for Tahoe   <br />* OPCODE=22 (kAcGiOpTrueColor)    <br />&lt;AcGiSubEntityTraits::setTrueColor (const AcCmEntityColor&amp; color)&gt;</p>  <p>{AcCmEntityColor / True color definition}</p>  <p>* OPCODE=23 (kAcGiOpLineWeight)   <br />&lt;AcGiSubEntityTraits::setLineWeight (const AcDb::LineWeight lw)&gt;</p>  <p>{double / Lineweight}</p>  <p>* OPCODE=24 (kAcGiOpLineTypeScale)   <br />&lt;AcGiSubEntityTraits::setLineTypeScale (double dScale)&gt;</p>  <p>{double / Line scale}</p>  <p>* OPCODE=25 (kAcGiOpThickness)   <br />&lt;AcGiSubEntityTraits::setThickness (double dThickness)&gt;</p>  <p>{double/ Thickness}</p>  <p>* OPCODE=26 (kAcGiOpPlotStyleName)   <br />&lt;AcGiSubEntityTraits::setPlotStyleName (AcDb::PlotStyleNameType type, const    <br />AcDbObjectId &amp; id)&gt;</p>  <p>{int32 / PlotStyle name type} {int32 / ID}</p>  <p>* OPCODE=27 (kAcGiOpPushClipBoundary)   <br />&lt;AcGiGeometry::pushClipBoundary (AcGiClipBoundary* pBoundary)&gt;</p>  <p>{AcGiClipBoundary / Clip Boundary}</p>  <pre><pre><br />struct AcGiClipBoundary {<br />   // Boundaries<br />   AcGeVector3d    m_vNormal;<br />   AcGePoint3d     m_ptPoint;<br />   AcGePoint2dArray    m_aptPoints;<br /><br />   // Transforms<br />   AcGeMatrix3d    m_xToClipSpace;<br />   AcGeMatrix3d    m_xInverseBlockRefXForm;<br /><br />   // Z clipping<br />   Adesk::Boolean    m_bClippingFront;<br />   Adesk::Boolean    m_bClippingBack;<br />   double        m_dFrontClipZ;<br />   double        m_dBackClipZ;<br /><br />   Adsk::Boolean    m_bDrawBoundary;<br /> };<br /></pre></pre>

<p>* OPCODE=28 (kAcGiOpPopClipBoundary)
  <br />&lt;AcGiGeometry::popClipBoundary ()&gt;</p>

<p>{Nothing}</p>

<p>* OPCODE=29 (kAcGiOpPushTransformM)
  <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>

<p>{AcGeMatrix3d / Matrix}</p>

<p>* OPCODE=30 (kAcGiOpPushTransformV)
  <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>

<p>{AcGeMatrix3d/ Matrix}</p>

<p>* OPCODE=31 (kAcGiOpPopTransform)
  <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>

<p>{Nothing}</p>

<p>* OPCODE=32 (kAcGiOpPlineNormal)
  <br />&lt;AcGiViewportGeometry::polylineEye (const Adesk::UInt32 nbPoints, const

  <br />AcGePoint3d* pPoints)

  <br />AcGiViewportGeometry::polylineDc (const Adesk::UInt32 nbPoints, const

  <br />AcGePoint3d* pPoints)&gt;</p>

<p>{int32 / Number of points} {AcGePoint3d / Point definition} [{AcGePoint3d /
  <br />Point definition} [...]] {AcGeVector3d / Normal}</p>

<p>* OPCODE=33 (kAcGiOpMaxOpCodes)
  <br />&lt;No AcGiGeometry Primitive Equivalent&gt;</p>

<p>Should not happen. If it does, skip to packet length. This has been provided
  <br />for forward compatibility for r2000 reading later AutoCAD releases DXF file for

  <br />example.</p>

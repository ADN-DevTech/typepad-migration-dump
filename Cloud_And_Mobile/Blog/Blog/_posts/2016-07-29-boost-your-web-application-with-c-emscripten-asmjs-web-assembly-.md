---
layout: "post"
title: "Boost your Web Application with C++! Emscripten, ASM.js, Web Assembly ..."
date: "2016-07-29 16:00:35"
author: "Philippe Leefsma"
categories:
  - "Browser"
  - "Build Tools"
  - "Client"
  - "Cloud"
  - "Compute"
  - "Frontend"
  - "HTML5"
  - "Javascript"
  - "Philippe Leefsma"
  - "Web Development"
original_url: "https://adndevblog.typepad.com/cloud_and_mobile/2016/07/boost-your-web-application-with-c-emscripten-asmjs-web-assembly-.html "
typepad_basename: "boost-your-web-application-with-c-emscripten-asmjs-web-assembly-"
typepad_status: "Publish"
---

<p><span style="font-family: arial, helvetica, sans-serif;">By&nbsp;<a href="http://adndevblog.typepad.com/cloud_and_mobile/philippe-leefsma.html" target="_blank">Philippe Leefsma</a> <a href="https://twitter.com/F3lipek" target="_blank">(@F3lipek)</a></span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; &nbsp; I meant to take a look at the topic since a while but finally got time during a rainy weekend:&nbsp;<a href="http://asmjs.org" target="_blank">asm.js</a>, <em>"an extraordinarily optimizable, low-level subset of JavaScript"</em>&nbsp;and <a href="https://webassembly.github.io" target="_blank">Web Assembly</a>, <em>"</em></span><span style="font-family: arial, helvetica, sans-serif;"><em>an experimental efficient low-level programming language for in-browser client-side scripting"</em> !&nbsp;</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; &nbsp; You can&nbsp;easily find lots of articles on that topic over the web, so I'm not planning to explain in details the theory... Rather than summing up again&nbsp;the same information from different&nbsp;sources, this blogpost is&nbsp;a deep dive from my own experience into digging how to compile a non-trivial piece of C++ into asm.js and Web Assembly (wasm). Then running them inside the browser from&nbsp;a custom test in order to benchmark the performances. Results are&nbsp;satisfying, to say the least.</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;If you are ready for a sneak peek at the future of web development, keep reading!</span></p>
<p><em><strong><span style="font-family: arial, helvetica, sans-serif;">I - Setting up the Emscripten tool chain</span></strong></em></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; &nbsp; The first step in the process is to setup the required tools that enable you to compile a piece of C++ into <em>something</em> that can be loaded into a browser. That project is called <a href="http://kripken.github.io/emscripten-site/" target="_blank">Emscripten</a>, so the first thing you would do when opening the link, is to go to the <a href="http://kripken.github.io/emscripten-site/docs/getting_started/index.html" target="_blank">Getting Started</a> section and follow the instructions right?&nbsp;</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; &nbsp; Yes, but there is a trick...&nbsp;the standard install instructions are suitable to compile C++ into asm.js, but if you plan to compile into Web Assembly - I know you do - there is just a little difference: instead of installing the latest SDK, you need to install the <em><strong>incoming</strong></em> branch, which has <strong>BINARYEN</strong> compile option available out of the box.</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;1/ Go to <a href="http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html#installation-instructions" target="_blank">Emscripten SDK download page</a> and make sure you have the <a href="https://kripken.github.io/emscripten-site/docs/building_from_source/toolchain_what_is_needed.html#toolchain-what-you-need" target="_blank">prerequisite tools on your machine</a>. The SDK runs on OSX, Windows and Linux</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;2/ You will then build the SDK from source as per <a href="https://kripken.github.io/emscripten-site/docs/building_from_source/building_emscripten_from_source_using_the_sdk.html" target="_blank">those instructions</a>. You just need to instal the&nbsp;</span><em><strong><span class="n">sdk</span><span class="o">-</span><span class="n">incoming</span><span class="o">-</span><span class="mi">64</span></strong></em><span class="n"><em><strong>bit</strong></em> as described in the tutorial, you do NOT need to install the master branch (no wasm support there yet - at the time of this writing)</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; &nbsp; 3/ Perform a check to see if emcc (the Emscripten compiler) is installed properly, I have it&nbsp;in my system path, so I can simply type <em><strong>emcc -v</strong></em> in a terminal:</span></p>
<p><span style="font-family: arial, helvetica, sans-serif;"> <a class="asset-img-link" href="http://adndevblog.typepad.com/.a/6a0167607c2431970b01bb09249f5c970d-pi" style="display: inline;"><img class="asset  asset-image at-xid-6a0167607c2431970b01bb09249f5c970d image-full img-responsive" title="Screen Shot 2016-07-29 at 19.10.07" src="/assets/image_9b4e32.jpg" alt="Screen Shot 2016-07-29 at 19.10.07" width="689" height="162" border="0" /></a></span> <span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;If you see something like this, then you are ready for the next thrill!</span> <br /> </p>
<p><strong><em><span style="font-family: arial, helvetica, sans-serif;">II - Back to the 90's, let's write some C++&nbsp;</span></em></strong></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; &nbsp; It's been a while since I hadn't written more than few lines of C++. Emscripten documentation is pretty good and the SDK comes which a bunch of samples, ranging from very basic to pretty advanced, so you probably want to go at least through the basic <a href="https://kripken.github.io/emscripten-site/docs/getting_started/Tutorial.html" target="_blank">hello world tutorial</a>. </span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;It's quite detailed, so I assume this goes smoothly on your side as well and you are now able to compile a single C++ file into asm.js, then load it into the demo web page that is produced when using the <em><strong>-o output.html</strong></em>:</span></p>
<pre><span class="p">.</span><span class="o">/</span><span class="n">emcc</span> <span class="n">tests</span><span class="o">/</span><span class="n">hello_world</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">html<br /></span></pre>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp; <a class="asset-img-link" href="http://adndevblog.typepad.com/.a/6a0167607c2431970b01b7c8812283970b-pi" style="display: inline;"><img class="asset  asset-image at-xid-6a0167607c2431970b01b7c8812283970b img-responsive" title="Screen Shot 2016-07-29 at 19.23.19" src="/assets/image_a42a3f.jpg" alt="Screen Shot 2016-07-29 at 19.23.19" width="361" height="407" /></a></span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;Almost the same emotion than the first C++ program I wrote on my PC! </span></p>
<p><span style="font-family: arial, helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;My goal here however is to write a slightly more advanced&nbsp;piece of code in order to&nbsp;compare its execution speed with plain JavaScript or we could say <em>"human written JavaScript".&nbsp;</em>A good candidate for that task that came naturally to my mind is&nbsp;the particle system I wrote few months ago, I already have the <a href="https://github.com/Developer-Autodesk/library-javascript-viewer-extensions/tree/master/src/Viewing.Extension.Particle" target="_blank">JavaScript ES6 version</a>, so I just needed to write an equivalent C++ version. &nbsp;&nbsp;</span></p>
<p>&nbsp; &nbsp; Below&nbsp;is how the console test of my C++ particle system looks like. Note: it is just used to test and debug the particle system&nbsp;while writing it, this is not the actual test this blog is about.</p>
<script src="https://gist.github.com/leefsmp/b2e76b62ed1cb6d3f18dcbbeba4a752c.js"></script>
<p>&nbsp; &nbsp; I wrote and compiled the project initially in Visual Studio 2010 (for compatibility reason with the tools), then used a tool called <a href="https://code.google.com/archive/p/make-it-so/" target="_blank">make-it-so</a> that will parse the Visual Studio .sln solution and generate a make file out of it.</p>
<p><em><strong>III -&nbsp;Exposing C++ classes to JavaScript</strong></em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alright, at this step we have a C++ particle system that&nbsp;compiles and can run in console mode as a pure C++ application.&nbsp;We can compile it using the make file produced by MakeItSo - or created by hand if you fancy this kind of thing. However what we want is to be able to instantiate the <em>ParticleSystem</em> from our JavaScript code, so we can really leverage the speed gain from a web application mostly written in js.&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;In order to achieve that, Emscripten offers two different&nbsp;approaches:</p>
<p>1/ <a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#embind" target="_blank">Embind</a>: basically you declare the bindings between the C++ class methods and properties and the generated JavaScript objects using the <a href="http://kripken.github.io/emscripten-site/docs/api_reference/bind.h.html#EMSCRIPTEN_BINDINGS__X" target="_blank">EMSCRIPTEN_BINDINGS</a> macro</p>
<p>2/ <a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/WebIDL-Binder.html#webidl-binder" target="_blank">WebIDL Binder</a>: you create an extra .idl file that describes the bindings, generate a .js and .cpp files by running a python script from the SDK against the idl and finally compile the project including that cpp file.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The second option may look like like a lot of extra steps, however this is the one I chose. I felt that the&nbsp;main advantage is that you don't have to&nbsp;modify your initial C++ code by adding macro to each file and link the project to the correct emscripten C libraries, so you can keep your C++ code base intact and keep developing and testing as is. Note that this is also the approach chosen by two major Emscripten C++ ports: <a href="https://github.com/kripken/box2d.js/#box2djs" target="_blank">box2d.js</a> and <a href="https://github.com/kripken/ammo.js/#ammojs" target="_blank">ammo.js</a>&nbsp;(<a href="http://bulletphysics.org/wordpress/" target="_blank">Bullet Physics</a>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here are&nbsp;the&nbsp;bindings definition for my project so far:</p>
<script src="https://gist.github.com/leefsmp/a02918af99d7bda3439a0024eaf93fdd.js"></script>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Once the bindings are correct, you will generate the glue files by invoking a python script as follow - path will depends on your emsdk location:</p>
<p><span style="font-family: 'courier new', courier;">python ~/emsdk/emscripten/incoming/tools/webidl_binder.py bindings.idl glue</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;This produces <em>glue.cpp</em> and <em>glue.js</em>, you can then create an extra file <em>glue_wrapper.cpp</em> which includes the required headers and <em>glue.cpp</em>, you then add <em>glue_wrapper.cpp</em> to your makefile. This is suggested&nbsp;this way so if you modify your bindings in the future, you can simply re-run the python script without editing any other file in your project. Refer to <a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/WebIDL-Binder.html#webidl-binder" target="_blank">WebIDL&nbsp;section</a>&nbsp;on the official documentation for more details.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;If everything is done correctly, you should now be able to replace g++ compiler by emcc in the makefile and by running <strong><em>make</em></strong>, it will produce the byte code: <em><strong>ParticleSystem.bc</strong></em>. You can take a look at my custom makefile <a href="https://github.com/leefsmp/Particle-System/blob/master/Emscripten/ParticleSystem/ParticleSystem.makefile" target="_blank">there</a>.&nbsp;</p>
<p><em><strong>IV - Generating asm.js</strong></em></p>
<p>&nbsp; &nbsp; We are just one step away from generating asm.js: just run the following command by specifying the <em>glue.js</em> as <em>post-js</em> step, the <em>ParticleSystem.bc</em> from the compilation and also <em>NO_EXIT_RUNTIME=1</em> option to indicate that even after main has returned, we keep the runtime alive because our JavaScript code will be running the particles. I also comment out all the test code inside the C++ main as it is irrelevant.</p>
<pre>emcc -s NO_EXIT_RUNTIME=1 -s release/ParticleSystem.bc --post-js ParticleSystem/glue.js -o dist/asmjs/ParticleSystem.asm.js</pre>
<p>&nbsp; &nbsp; In my project I created the <em><strong>emcc-asmjs.sh</strong></em> script for not having to type the command every time. The output file is valid ES5 JavaScript file <em><strong>ParticleSystem.asm.js</strong></em> that can simply be included in your html using a classic &lt;script&gt; tag. You can take a look at the <a href="https://github.com/leefsmp/Particle-System/blob/master/Test/src/UnitTests/ASM.Test.js" target="_blank">asm.js test</a>, which is invoking the exported C++ classes, it's pretty close to the C++ code we had originally in main.cpp.</p>
<p><strong><em>V - Generating Web Assembly</em></strong></p>
<p>&nbsp; &nbsp; That's the cherry on the top, by simply adding the <em><strong>BINARYEN=1</strong></em> option - that's where using the <strong><em>incoming</em></strong> branch of Emscripten matters - you can generate wasm files!</p>
<pre>emcc -s NO_EXIT_RUNTIME=1 -s BINARYEN=1 release/ParticleSystem.bc --post-js ParticleSystem/glue.js -o dist/wasm/ParticleSystem.js</pre>
<p>In that case it produces <a href="https://github.com/leefsmp/Particle-System/tree/master/Emscripten/dist/wasm" target="_blank">several files</a> and loading the script in your html requires a bit more trickery:</p>
<pre style="line-height: 100%; font-family: monospace; background-color: #ffffff; padding: 4px; font-size: 10pt; border: 0.01mm solid #000000;"><span style="color: #800000; background-color: #f0f0f0;"> 1 </span><span style="background-color: #efefef;">&lt;</span><span style="color: #000080; background-color: #efefef; font-weight: bold;">script</span><span style="background-color: #efefef;">&gt;
</span><span style="color: #800000; background-color: #f0f0f0;"> 2 </span>  
<span style="color: #800000; background-color: #f0f0f0;"> 3 </span>  <span style="color: #000080; background-color: #ffffff; font-weight: bold;">var</span><span style="background-color: #ffffff;"> Module = Module || {
</span><span style="color: #800000; background-color: #f0f0f0;"> 4 </span><span style="background-color: #ffffff;">    wasmBinaryFile: </span><span style="color: #008000; background-color: #ffffff; font-weight: bold;">'../Emscripten/dist/wasm/ParticleSystem.wasm'
</span><span style="color: #800000; background-color: #f0f0f0;"> 5 </span><span style="background-color: #ffffff;">  }
</span><span style="color: #800000; background-color: #f0f0f0;"> 6 
 7 </span>  <span style="color: #000080; background-color: #ffffff; font-weight: bold;">var</span><span style="background-color: #ffffff;"> xhr = </span><span style="color: #000080; background-color: #ffffff; font-weight: bold;">new</span><span style="background-color: #ffffff;"> XMLHttpRequest()
</span><span style="color: #800000; background-color: #f0f0f0;"> 8 </span><span style="background-color: #ffffff;">  xhr.open(</span><span style="color: #008000; background-color: #ffffff; font-weight: bold;">'GET'</span><span style="background-color: #ffffff;">, </span><span style="color: #008000; background-color: #ffffff; font-weight: bold;">'../Emscripten/dist/wasm/ParticleSystem.wasm'</span><span style="background-color: #ffffff;">, </span><span style="color: #000080; background-color: #ffffff; font-weight: bold;">true</span><span style="background-color: #ffffff;">)
</span><span style="color: #800000; background-color: #f0f0f0;"> 9 </span><span style="background-color: #ffffff;">  xhr.responseType = </span><span style="color: #008000; background-color: #ffffff; font-weight: bold;">'arraybuffer'
</span><span style="color: #800000; background-color: #f0f0f0;">10 
11 </span><span style="background-color: #ffffff;">  xhr.onload = </span><span style="color: #000080; background-color: #ffffff; font-weight: bold;">function</span><span style="background-color: #ffffff;">() {
</span><span style="color: #800000; background-color: #f0f0f0;">12 
13 </span><span style="background-color: #ffffff;">    Module.wasmBinary = xhr.response
</span><span style="color: #800000; background-color: #f0f0f0;">14 
15 </span>    <span style="color: #000080; background-color: #ffffff; font-weight: bold;">var</span><span style="background-color: #ffffff;"> script = document.createElement(</span><span style="color: #008000; background-color: #ffffff; font-weight: bold;">'script'</span><span style="background-color: #ffffff;">)
</span><span style="color: #800000; background-color: #f0f0f0;">16 </span><span style="background-color: #ffffff;">    script.src = </span><span style="color: #008000; background-color: #ffffff; font-weight: bold;">"../Emscripten/dist/wasm/ParticleSystem.js"
</span><span style="color: #800000; background-color: #f0f0f0;">17 </span><span style="background-color: #ffffff;">    document.body.appendChild(script)
</span><span style="color: #800000; background-color: #f0f0f0;">18 </span><span style="background-color: #ffffff;">  }
</span><span style="color: #800000; background-color: #f0f0f0;">19 
20 </span><span style="background-color: #ffffff;">  xhr.send(</span><span style="color: #000080; background-color: #ffffff; font-weight: bold;">null</span><span style="background-color: #ffffff;">)
</span><span style="color: #800000; background-color: #f0f0f0;">21 </span><span style="background-color: #efefef;">&lt;/</span><span style="color: #000080; background-color: #efefef; font-weight: bold;">script</span><span style="background-color: #efefef;">&gt;</span></pre>
<p>&nbsp; &nbsp; Testing the wasm&nbsp;can be achieved with the exact same code than for asm.js, I only added a <a href="https://github.com/leefsmp/Particle-System/blob/master/Test/src/UnitTests/Wasm.Test.js#L31" target="_blank">check on Module </a>to see if ParticleSystem object is available as the laoding is asynchronous. It might not be the best approach but reliable enough for now...</p>
<p><em><strong>VI - Benchmarking the code</strong></em></p>
<p>&nbsp; &nbsp; Finally the fun part is to compare how well asm.js and wasm perform against the plain JavaScript code, well my JavaScript code was written in ES6, so it still has to go through a build step to transpile it.</p>
<p>&nbsp; &nbsp; Asm.js is plain JavaScript so&nbsp;any current browser should be able to load it, wasm is experimental so it has support only in <a href="https://www.google.com/chrome/browser/canary.html" target="_blank">Chrome Canary</a> and <a href="https://nightly.mozilla.org/" target="_blank">Firefox Nightly</a> at this time, with Microsoft Edge coming pretty soon.&nbsp;</p>
<p>&nbsp; &nbsp; I created a simple interface using <a href="https://www.npmjs.com/package/jsoneditor" target="_blank">jsoneditor</a> which allows to modify the test configuration. You can tweak the time step, number of particles, number of steps, add some emitters and fields. There is no validation so if you provide invalid or missing parameters, you will probably crash the test. You can also output the particles position to the browser console with <strong><em>dumpParticles</em></strong> set to true, so don't output 10,000 particles over 10,000 steps, you may sit there for a while...</p>
<p><a class="asset-img-link" href="http://adndevblog.typepad.com/.a/6a0167607c2431970b01b7c8813e16970b-pi" style="display: inline;"><img class="asset  asset-image at-xid-6a0167607c2431970b01b7c8813e16970b img-responsive" title="Screen Shot 2016-07-30 at 00.35.28" src="/assets/image_416b33.jpg" alt="Screen Shot 2016-07-30 at 00.35.28" width="350" height="473" /></a></p>
<p>&nbsp; &nbsp; Loading the wasm on a browser that doesn't support will use a fallback, so the code still runs but ends up being very very slow. You can give it a try but be warned.&nbsp;</p>
<p>&nbsp; &nbsp; That's what you can see in your browser console if it can successfully load the wasm file. In Canary it worked straight ot of the install, in Firefox Nightly I had to activate in the config flags <em><strong>javascript.options.wasm: true&nbsp;</strong></em></p>
<em><strong> <a class="asset-img-link" href="http://adndevblog.typepad.com/.a/6a0167607c2431970b01b7c881415d970b-pi" style="display: inline;"><img class="asset  asset-image at-xid-6a0167607c2431970b01b7c881415d970b img-responsive" title="Screen Shot 2016-07-30 at 01.27.11" src="/assets/image_28f630.jpg" alt="Screen Shot 2016-07-30 at 01.27.11" /></a><br /></strong></em>
<p>&nbsp;&nbsp;&nbsp;&nbsp;I created two tests, here are the live versions: <a href="https://leefsmp.github.io/Particle-System/Test/ES6vsASM.html" target="_blank">ES6 vs ASM.js</a> and <a href="https://leefsmp.github.io/Particle-System/Test/ES6vsWASM.html" target="_blank">ES6 vs WASM</a>&nbsp;and here is a plot of the results I gathered across several browsers, they were using the same default config 1000 particles over 5000 steps:</p>
<p><a class="asset-img-link" href="http://adndevblog.typepad.com/.a/6a0167607c2431970b01bb09249e61970d-pi" style="display: inline;"><img class="asset  asset-image at-xid-6a0167607c2431970b01bb09249e61970d image-full img-responsive" title="20160727101631" src="/assets/image_1e6346.jpg" alt="20160727101631" border="0" /></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Safari comes the very last as far as ES6 is concerned with a huge difference, however the asm.js executes almost the fastest on it with a 42x speed factor increase!</p>
<p>&nbsp; &nbsp;&nbsp;Firefox Nightly is the one that executes the asm.js code the fastest with an elapsed time of 122 ms. Oddly it doesn't seem to handle wasm very well with a total time of 521 ms, so much higher in comparison</p>
<p>&nbsp; &nbsp; Canary is the absolute&nbsp;winner of the contest with an execution speed of 121 ms for the wasm version, 12x faster than it runs ES6! However it doesn't handle asm.js as well as Firefox or Safari ...</p>
<p>&nbsp; &nbsp; That's it for now! I hope you enjoyed, that was a pretty interesting experiment for me so far. The next step will be integrate my particle system asm.js and wasm versions into a Forge Viewer sample and see how much they can increase the FPS of the simulation, so I will definitely blog some more of that in the future.</p>
<p>&nbsp; &nbsp; The full git project is available at <a href="https://github.com/leefsmp/Particle-System" target="_blank">https://github.com/leefsmp/Particle-System</a>&nbsp;with instructions on how to build it.&nbsp;</p>
<p>&nbsp;</p>

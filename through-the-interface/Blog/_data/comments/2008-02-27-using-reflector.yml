comments:
- author: namin
  email: autocad@namin.net
  ip: 18.251.3.76
  url: ''
  date: '2008-02-27 15:44:59'
  body: 'In order for a recursive call to be tail call, there needs to be no pending
    operations when the recursive call is made. Wouldn''t that explain why getNPoints
    isn''t tail-call optimized? Indeed, the @ operation must happen  after the recursive
    call:


    ptlist @ getNPoints (n - pts.Count) sol


    It''s clearer, if you write this:

    let recres = getNPoints (n - pts.Count) sol


    ptlist @ recres


    You see clearly that the @ must happen after the recursive call to getNPoints,
    so it cannot be tail-call optimized, because of this pending operation.


    You could re-write getNPoints to be iterative, accumulating the list of points
    in an extra parameter.'
- author: Kean
  email: kean.walmsley@autodesk.com
  ip: 132.188.32.100
  url: http://blogs.autodesk.com/through-the-interface
  date: '2008-02-27 16:20:07'
  body: "It does indeed seem to be the reason - I wasn't aware of the pending operation\
    \ restriction, although I think I suspected something like this at the root of\
    \ it.\n\nIf I pass an accumulator list it can indeed be defined recursively and\
    \ get optimized to an iterative operation:\n\nlet rec getNPoints n (sol:Solid3d)\
    \ ptlist =\n  if n <= 0 then\n    ptlist\n  else\n    ...\n\n    getNPoints (n\
    \ - pts.Count) sol (ptlist @ Seq.untyped_to_list pts)\n\nObviously the initial\
    \ call is made with an empty list, but then we're in business.\n\nThanks for your\
    \ comment, namin - nice to know someone's listening! :-)\n\nKean"
- author: Jose Madrigal
  email: jmadrigal@bgarch.com
  ip: 209.78.249.2
  url: http://www.bgarch.com
  date: '2008-02-27 20:17:14'
  body: 'Kean,


    I''m listening but don''t have time to try out the new F# code. C# works just
    fine for me. Maybe if you could demonstrate in F# post the c# along with example
    would be nice and easier for me to test?'
- author: namin
  email: autocad@namin.net
  ip: 18.251.3.76
  url: ''
  date: '2008-02-28 04:39:08'
  body: 'Hi Kean,


    Yup, I am really enjoying your F# series :)


    Just to develop a bit on tail-call, the idea is basically that if there are no
    pending operations, then there''s no need to push the recursive call on the stack,
    because we know that we can just jump away and we''ll be in the right place. However,
    as soon as there are pending operations, we need to remember what we need to do
    once we''re done with the recursive call -- hence, we cannot just "jump".'
- author: Kean
  email: kean.walmsley@autodesk.com
  ip: 132.188.32.100
  url: http://blogs.autodesk.com/through-the-interface
  date: '2008-02-28 09:30:49'
  body: 'Jose - thanks, I understand it''s very different for those used to "classic"
    languages. From time to time I will try to post both C# and F#, but it takes time
    & effort to do, of course (the recent Robotic Hatching series is an example where
    I chose to provide both).


    Namin - thanks, that does indeed make sense. I just needed to take the time to
    think about it.'
- author: Jon Harrop
  email: jon@ffconsultancy.com
  ip: 80.229.56.224
  url: http://www.ffconsultancy.com
  date: '2008-02-28 11:51:40'
  body: 'To the best of my knowledge, C# cannot represent tail calls so your approach
    of decompiling compiled F# code back into C# code will not work reliably.


    What you''re seeing in the first case is probably the F# compiler generating a
    loop and not using the tail call ILX op (because the current .NET JIT compiles
    loops much more efficiently than tail call ops). So you see a faithful decompilation
    to C# in that specific case but not in general.'
- author: Kean
  email: kean.walmsley@autodesk.com
  ip: 132.188.32.100
  url: http://blogs.autodesk.com/through-the-interface
  date: '2008-02-28 11:59:25'
  body: 'Hi Jon,


    You can indeed tell (at least I could) from the C# code generated by Reflector
    from the IL whether the tail call has been optimized or not.


    The ultimate intent is to see a difference in the way the F# compiler optimizes
    your code: this approach does help you spot when code gets optimized to an iterative
    construct rather than remaining recursive.


    Or maybe I''ve missed your point?


    Regards,


    kean

    -----'

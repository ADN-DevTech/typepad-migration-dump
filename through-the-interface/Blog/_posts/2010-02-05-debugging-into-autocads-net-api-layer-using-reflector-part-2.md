---
layout: "post"
title: "Debugging into AutoCAD&rsquo;s .NET API layer using Reflector &ndash; Part 2"
date: "2010-02-05 11:15:30"
author: "Kean Walmsley"
categories:
  - "AutoCAD"
  - "AutoCAD .NET"
  - "Debugging"
  - "Visual Studio"
original_url: "https://www.keanw.com/2010/02/debugging-into-autocads-net-api-layer-using-reflector-part-2.html "
typepad_basename: "debugging-into-autocads-net-api-layer-using-reflector-part-2"
typepad_status: "Publish"
---

<p>In <a href="http://through-the-interface.typepad.com/through_the_interface/2010/02/debugging-into-autocads-net-api-layer-using-reflector-part-1.html">the first post in this series</a> we looked at the basic (and free) capabilities of the upcoming version 6 of .NET Reflector. Today we’ll look at the “Pro” capabilities, which integrate decompilation with debugging of 3rd party assemblies.</p>  <p>To get started, we should see a new “.NET Reflector” toolbar inside our Visual Studio installation. On it, we should see a “Choose Assemblies to Debug…” option:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2012877674d5a970c-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Launching the assembly decompilation" border="0" alt="Launching the assembly decompilation" src="/assets/image_974318.jpg" width="384" height="262" /></a> </p>  <p>This option launches an analysis of our currently open solution, to understand the assemblies that have been referenced inside it:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e20120a864f99a970b-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Reading assemblies from our solution" border="0" alt="Reading assemblies from our solution" src="/assets/image_737608.jpg" width="472" height="342" /></a> </p>  <p><strong>One very important thing to note</strong>: for Reflector to work, you must have assembly references to the versions of acmgd.dll and acdbmgd.dll found in <strong>AutoCAD’s Program Files folder</strong>. If you’re using the “liposuctioned” assemblies provided in the ObjectARX SDK (which are absolutely the right ones to use under normal circumstances) then you’ll get an error such as “Object reference not set to an instance of an object”, at least with the Beta version of this tool I tried.</p>  <p>To get started with the decompilation, we select AcMgd and AcDbMgd from the assembly list:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2012877674d7e970c-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Choosing AutoCAD&#39;s assemblies to decompile" border="0" alt="Choosing AutoCAD&#39;s assemblies to decompile" src="/assets/image_93656.jpg" width="472" height="342" /></a> </p>  <p>Selecting OK causes the decompilation process to start on these assemblies:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2012877674d8b970c-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Decompiling AutoCAD&#39;s assemblies" border="0" alt="Decompiling AutoCAD&#39;s assemblies" src="/assets/image_954490.jpg" width="472" height="342" /></a> </p>  <p>Once complete, we see a notice describing the results. For the AutoCAD 2010 assemblies there were 28 methods that failed to decompile (and 19,390 which decompiled successfully):</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2012877674da4970c-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Finished decompilation" border="0" alt="Finished decompilation" src="/assets/image_443468.jpg" width="472" height="342" /></a> </p>  <p>Looking at the details, we can see that the majority of the non-decompiled (for want of a better word :-) methods belong to the ObjectId class (whether due to an optimization we make on that class or a bug in Reflector’s decompilation algorithm):</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2012877674db7970c-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Details of methods that failed to decompile" border="0" alt="Details of methods that failed to decompile" src="/assets/image_217025.jpg" width="472" height="343" /></a></p>  <p>The decompilation has added about 33 Mb of data to Reflector’s “Debug Store” (which appears to be under <em>C:\Users\username\AppData\Local\Red Gate\.NET Reflector 6\Cache</em>, at least on my system).</p>  <p>Now we can go ahead and debug as normal and see the results. Let’s start by adding a breakpoint to our Extend method. Once it hits, we can step into the code:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e20120a864f9fd970b-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Debugging our Line&#39;s Extend call" border="0" alt="Debugging our Line&#39;s Extend call" src="/assets/image_299557.jpg" width="358" height="274" /></a></p>  <p>Firstly we’ll see some code that shows us retrieving the StartPoint property of a Line (which I haven’t shown here), and then we get to debug the use of the subtraction operator between a point and a vector (which we can see subtracts the coordinate values of the vector from those of the point before returning the point): </p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e20120a864fa0a970b-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Debugging the subtraction operator between a point and a vector" border="0" alt="Debugging the subtraction operator between a point and a vector" src="/assets/image_270835.jpg" width="485" height="165" /></a>And next we get to see that the Extend call is simple a call through to an unmanaged ObjectARX interface (which happens to be AcDbCurve::extend(), not that this is in any way obvious from the decompiled code):</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2012877674de7970c-pi"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="Debugging the actual Extend call" border="0" alt="Debugging the actual Extend call" src="/assets/image_271223.jpg" width="485" height="127" /></a></p>  <p>Fun stuff! I can see this being of great interest to people who like to get under the hood of software components, although clearly a lot will depend on the cost at which the tool is made available (and about this I have no clue).</p>

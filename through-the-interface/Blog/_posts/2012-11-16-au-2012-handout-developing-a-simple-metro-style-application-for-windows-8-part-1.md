---
layout: "post"
title: "AU 2012 Handout: Developing a simple Metro-style application for Windows 8 &ndash; Part 1"
date: "2012-11-16 11:53:49"
author: "Kean Walmsley"
categories:
  - "AU"
  - "AutoCAD"
  - "iOS"
  - "WinRT"
original_url: "https://www.keanw.com/2012/11/au-2012-handout-developing-a-simple-metro-style-application-for-windows-8-part-1.html "
typepad_basename: "au-2012-handout-developing-a-simple-metro-style-application-for-windows-8-part-1"
typepad_status: "Publish"
---

<p>I finally managed to wrap-up my AU material over the weekend. Here’s the first part of the handout for <a href="https://www.autodeskuniversity2012.com/connect/sessionDetail.ww?SESSION_ID=1921" target="_blank">my Windows 8-related session</a> (if you log in with your AU account, you’ll be able to access the accompanying presentation and sample project).</p>  <p>This is an “intermediate” class (rather than “advanced”), so at times it may seem fairly high-level. That said, if anyone sees issues with the material – especially important topics that have been glossed over – please do let me know: I’d be happy to make corrections (especially in advance of the class being delivered :-).</p>  <h3>Introduction</h3>  <p>Windows 8 has recently been released to a great deal of interest around the globe. It has been branded – and this is in some ways backed up by <a href="http://www.forbes.com/sites/netapp/2012/10/11/windows-8-release-date-tablet-microsoft-cloud" target="_blank">the $1.5+ billion marketing spend around the launch</a> – as the most ambitious release of Windows ever. It certainly presents a very different UI paradigm to its users – something for which Microsoft has been both praised and criticized, inevitably – while also maintaining a strong focus on running legacy (now termed “desktop”) applications</p>  <p>Let’s start by taking a look at the Windows 8 Start screen:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017c3391f9c8970b-pi" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 20px auto; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Windows 8 Start screen" border="0" alt="Windows 8 Start screen" src="/assets/image_172979.jpg" width="474" height="298" /></a></p>  <p>The screen contains colourful – and actually very informative – tiles that are clearly targeted at touch-centric, mobile devices.</p>  <p>Devices that specifically target the Windows RT sub-system will run on both traditional Windows 8 machines (with Intel processors, which means they can run WinRT apps as well as traditional desktop apps such as AutoCAD) and on the new ARM-based devices such as the Microsoft Surface tablet and Windows Phone 8 handsets.</p>  <p>In this class, we’re going to spend some time looking at Windows 8 – and specifically WinRT – as well as the development challenges and opportunities it presents.</p>  <h3>Windows Runtime – The New Sandbox on the Block</h3>  <p>Windows Runtime – which as we’ve already seen is commonly abbreviated to WinRT – is Microsoft’s answer to Android and iOS: two application sandboxes that have had explosive growth over the last few years. Windows has its own, highly popular application execution environment – the .NET Framework – but it seems the belief within at least some divisions at Redmond was that this was not the appropriate model for working with next-generation mobile devices. Attempts have been made in the past to use a subset (which typically means a separate, streamlined version) of the .NET Framework in this way (such as <a href="http://en.wikipedia.org/wiki/.NET_Compact_Framework" target="_blank">the .NET Compact Framework</a> and <a href="http://msdn.microsoft.com/en-us/library/bb404713(v=vs.95).aspx" target="_blank">Microsoft Silverlight</a>), but for better or worse WinRT is Microsoft’s latest attempt at addressing this particular market need.</p>  <p>WinRT is a complete layer on top of the core services belonging to the Windows OS. While with .NET it has often been needed to use the Platform Invoke capability to call through to the underlying Win32 API, with WinRT this is no longer needed or even allowed (at least not if you want to make your application available via the Windows Store).</p>  <p>So what does it mean, this idea of a sandbox? It’s basically a controlled execution environment for software: one that only provides a restricted subset of OS capabilities to applications. By not providing “risky” capabilities, sandboxes allow untrusted code to be executed in a controlled way: the ability to access certain resources – such as a user’s documents – must be specifically requested by the app, which get transferred to privileges that must be granted specifically by the user.</p>  <p>Aside from providing a much more secure and trustworthy environment for applications to execute, WinRT also provides the ability for code to be written in a variety of languages. We’ll look at that in more detail shortly.</p>  <h3>WinRT – How it looks different</h3>  <p>The first thing that strikes you when you see Windows 8 is that it looks very different. As mentioned earlier, the Start screen presents some highly colourful tiles to the user, some of which are “live” and present information deemed important by the apps to whom they belong.</p>  <p>The original name for the design language used for Windows 8 – as well as Zune, Xbox and Windows Phone – was Metro. In fact that’s the reason this class is named as it is. A few months ago, however, Microsoft stated the name had actually been a codename and went through a significant re-branding exercise (as despite being a codename, the Metro moniker had proved popular and was used fairly pervasively to describe the design language and the apps that make use of it). It’s believed this change of approach was driven by legal action from Metro AG, but that’s not really important for us to focus on.</p>  <p>Microsoft <a href="http://www.theverge.com/2012/8/10/3232921/microsoft-modern-ui-style-metro-style-replacement" target="_blank">adopted the term “modern UI style apps”</a> before finally settling – <a href="http://www.theregister.co.uk/2012/09/13/metro_apps_are_windows_store_apps/" target="_blank">fairly recently</a> – on the term “Windows Store” apps. Whenever you see the title of this class – which has clearly now been set in fairly strong concrete – please translate it automatically to “Developing a simple Windows Store application for Windows 8”.     <br />Windows Store apps are full-screen, chromeless and are clearly targeted at touch-centric devices (although it’s always possible to use them on devices that are not touch-capable).</p>  <p>There were various influences that drove the look of what was formerly known as “Metro”. While not a core part of this class, it’s interest to note them:</p>  <ul>   <li>Bauhaus: <a href="http://en.wikipedia.org/wiki/Bauhaus">http://en.wikipedia.org/wiki/Bauhaus</a> </li> </ul>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017d3dc05f86970c-pi" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 20px 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Bauhaus poster" border="0" alt="Bauhaus poster" align="left" src="/assets/image_697208.jpg" width="176" height="263" /></a></p>  <p>&#160;</p>  <p>&#160;&#160;&#160;&#160; <a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017c3391fa37970b-pi" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 20px 0px; padding-left: 0px; padding-right: 0px; display: inline; float: right; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Bauhaus exhibition" border="0" alt="Bauhaus exhibition" align="right" src="/assets/image_213828.jpg" width="275" height="198" /></a></p>  <p>&#160;</p>  <p>&#160;</p>  <p>&#160;</p>  <p>&#160;</p>  <p>&#160;</p>  <p>&#160;</p>  <ul>   <li>Swiss typography: <a href="http://en.wikipedia.org/wiki/International_Typographic_Style">http://en.wikipedia.org/wiki/International_Typographic_Style</a> </li> </ul>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017ee53558da970d-pi" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 20px 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Swiss typographic poster" border="0" alt="Swiss typographic poster" align="left" src="/assets/image_482882.jpg" width="226" height="321" /></a></p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017d3dc05fff970c-pi" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 20px 0px; padding-left: 0px; padding-right: 0px; display: inline; float: right; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Stravinksy poster" border="0" alt="Stravinksy poster" align="right" src="/assets/image_158073.jpg" width="232" height="322" /></a></p>  <p>&#160;</p>  <p>&#160;</p>  <p>&#160;</p>  <p><font size="1"></font></p>  <p>&#160;</p>  <p>&#160;</p>  <p><font size="1"></font></p>  <p><font size="1"></font></p>  <p>&#160;</p>  <p>&#160;</p>  <ul>   <li>Motion design: <a href="http://en.wikipedia.org/wiki/Motion_graphic_design">http://en.wikipedia.org/wiki/Motion_graphic_design</a> </li> </ul>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017d3dc0603e970c-pi" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 20px auto; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Motion design" border="0" alt="Motion design" src="/assets/image_537720.jpg" width="240" height="319" /></a></p>  <p>In addition to these inspirations, the “Metro” design language is founded on some core principles:</p>  <ul>   <li>Pride in craftsmanship </li>    <li>Fast and fluid </li>    <li>Authentically digital </li>    <li>Do more with less </li>    <li>Win as one </li> </ul>  <p>One point that’s worth calling out specifically is “authentically digital”: while <a href="http://www.fastcodesign.com/1670760/will-apples-tacky-software-design-philosophy-cause-a-revolt" target="_blank">iOS has</a> (<a href="http://www.ign.com/articles/2012/11/06/jony-ives-ios-revisions-likely-to-ditch-skeuomorphism" target="_blank">at least until now</a>) taken a firm position in favour of <a href="http://en.wikipedia.org/wiki/Skeuomorphism" target="_blank">skeuomorphism</a> (in this context the act of imitating the real world in the digital one), Microsoft has chosen another path, avoiding the temptation of making digital imitations of real-world objects such as bookshelves. The message here is: don’t be afraid of digital versions being different, as those differences are also what make them valuable.</p>  <p>For more detailed information on these topics, I recommend these <a href="http://www.slideshare.net/shanemo/metro-design-language" target="_blank">two</a> <a href="http://download.microsoft.com/download/4/2/1/4213D2B3-FB36-4969-BFEF-19C926C4BBDE/SHAPE12_9.pptx" target="_blank">presentations</a> (the second of which was the source of the included images, many thanks to <a href="https://twitter.com/LBugnion" target="_blank">Laurent Bugnion</a>).</p>  <h3>WinRT – How it <em><u>is</u></em> different</h3>  <p>The programming model and the tools you need to use to make use of it are – on the one hand – familiar to .NET developers, but there are significant differences. There’s a lot to learn with WinRT.</p>  <p>Here are four main areas of difference, that we’ll cover in some detail:</p>  <ul>   <li>Different object model for OS capabilities </li>    <li>Asynchronous operation enforced for anything but “instant” responses </li>    <li>Strict control over disk access </li>    <li>Application interop only via contracts or file associations </li> </ul>  <h4>The WinRT Object Model</h4>  <p>When you first start working with WinRT from C#, there’s a great deal that’s familiar (especially if you’ve been working either with WPF or with Silverlight). There is a relationship with .NET, but it’s not actually the central mechanism that’s used to connect with the core OS layer. This happens to be COM – somewhat curiously for those of us that have been happy to distance ourselves from using this technology over the .NET years – but that’s really an implementation detail: you’re unlikely to have to get down and dirty with IUnknown (unless you really want to, of course).</p>  <p>WinRT and the CLR have distinct type systems that are effectively merged by the WinRT metadata adapter. At times it will seem a little strange to be working with the different types in the same application: for instance, some events are exposed via the CLR while others come from WinRT. You may notice the difference from the names (and types) of the arguments that are assigned automatically, but mostly these differences don’t get in the way at all.</p>  <p>When using C# or VB – and, inevitably, XAML for the UI – you’ll be targeting a particular <a href="http://blogs.microsoft.co.il/blogs/sasha/archive/2011/09/17/metro-net-framework-profile-windows-tailored.aspx" target="_blank">.NET Framework profile</a> (the .NETCore implementation). This provides access to the approved subset of the CLR for use with WinRT. At runtime, the full CLR is actually loaded and theoretically available to applications but the reality is that an application won’t be able to make use of it: while it’s possible for developers to hack their way beyond this approved subset of the Windows API, the Windows Store vetting process will exclude any apps submitted for posting that use techniques such as Platform Invoke or network loopback to play outside of the sandbox.</p>  <h4>Asynchronous operations are now the norm</h4>  <p>.NET developers have been playing with the async capabilities released in .NET 4.5 for some time, but with WinRT this mechanism takes on a whole new significance: any operations that could in theory take more than 50ms to complete are only made available via asynchronous API calls.</p>  <p>The intention is clearly to stop long-running API calls from blocking the UI thread and resulting in apps “whiting out”. Asynchronous calls help keep the Windows 8 UI responsive and fluid.</p>  <p>And the good news is that the async and await keywords make this really easy to deal with from your code, for instance:</p>  <div style="font-family: courier new; background: white; color: black; font-size: 8pt">   <p style="margin: 0px"><span style="line-height: 140%; color: blue">var</span><span style="line-height: 140%"> file =</span></p>    <p style="margin: 0px"><span style="line-height: 140%">&#160; </span><span style="line-height: 140%; color: blue">await</span><span style="line-height: 140%"> <font color="#4bacc6">KnownFolders</font>.DocumentsLibrary.GetFileAsync(</span><span style="line-height: 140%; color: #a31515">&quot;file.txt&quot;</span><span style="line-height: 140%">);</span></p> </div>  <p>In this situation, the await keyword tells the compiler to create an event that gets fired to continue execution of the application’s code once the results of the GetFileAsync() call are returned. The pain previously associated with performing operations asynchronously is now thankfully abstracted away by the compiler.</p>  <h4>Restricted access to the file system</h4>  <p>Applications making use of the WinRT object model no longer have arbitrary access to the file system. This is clearly intended to make applications more easily trusted by their users.</p>  <p>There are a relatively small number of locations that applications can request access to – they need to do so by modifying the Package.appmanifest to add “Capabilities”. Applications can – for instance – use this mechanism to request read/write access to the current user’s Documents, Pictures, Videos and to Removable Storage devices.</p>  <p>In addition to asking for access to files in this very restricted set of locations, applications also need to register themselves as associated with the types of the files they wish to access.</p>  <p>All these permissions get presented to the user when installing the app – and via the application’s Settings information – to make it very clear the type of information the app intends to access.</p>  <p>When an app asks the user to select a particular file from the system more freedom is granted to the app: it is effectively implied by the selection that the app is being granted permission to work with a particular file.</p>  <h4>Application interop</h4>  <p>Applications have very limited abilities to interoperate in the WinRT world: even if the system’s underpinnings are COM – a mechanism that was intended to facilitate the passing of information between software components – WinRT has been deliberately limited in this very important respect. This imposes good behavior on app developers, but many will find it restrictive: there will certainly be times when apps want to pass information between each other without it being a user-initiated operation. But for the good of the user experience, this is the choice that has been made by the implementers of WinRT.</p>  <p>As mentioned previously, access to the file system has been deliberately limited, but it is still possible to use it to share data at a user level. The Registry, on the other hand, is not accessible from WinRT apps, and so can no longer be used to pass information between applications.</p>  <p>There was a brief reference to “network loopback” in a previous section: this is the act of hosting a lightweight internet server on the local host (127.0.0.1) and using that from another WinRT app to exchange information. This is a fairly common interop technique, but this capability has been at least partially blocked for apps. And those that do manage to implement this technique will not make it through the Windows Store vetting process.</p>  <p>So what options do apps have for sharing information?</p>  <p>There’s one very specific “contract” (which is basically a protocol that needs to be implemented and registered with the framework) that apps can implement in order to share information at the request of the user (the user can choose to pass data from one application to another via the Share charm). It’s in this way that apps can have user-initiated interop – such as a user choosing to share a photo with the Mail app.</p>  <p>It’s also possible for WinRT apps to launch a desktop app that has been associated with a particular file-type. We’ll see this later on, where we choose to launch AutoCAD from our companion app to load a particular DWG file.</p>  <h3>Some additional points about WinRT apps</h3>  <p>The WinRT sub-system – while it runs on a traditional Windows 8 PC – is really intended for lightweight, touch-centric apps that will be run on a mobile device of some kind. WinRT apps are 32-bit only and are also not expected to consume significant quantities of memory: any that do will be jumped on by the WinRT runtime.</p>  <p>In fact the runtime is being left to manage application memory on a fairly general basis: apps typically don’t have explicit close or exit buttons (although you could, of course, choose to implement one) as the runtime is expected to terminate and resurrect apps as it needs to. It is possible to close applications via the task manager – or to get the app list on the left, which in recent versions of the OS provides a close option for each – but the expectation is that most users will not want to prune the list of running apps manually.</p>  <p>It’s generally not anticipated that software products such as AutoCAD will get ported to the WinRT sub-system: Microsoft doesn’t expect that heavyweight apps will get ported to WinRT. That’s not to say that it’ll never happen – or that AutoCAD components such as RealDWG will never be made available for WinRT – but there are significant architectural questions to resolve beforehand. For instance, with restricted file system access, how would AutoCAD handle accessing and loading support files or external references?</p>  <p>So it’s clear that we’re not going to be talking about writing an AutoCAD-hosted WinRT app in this session – because without WinRT-based AutoCAD, there is no WinRT API for it. Let’s then take a look at what application possibilities there might be, especially considering that application interop is so limited between WinRT and desktop apps.    <br />    <br /><em>In the next part, we’ll take a look at the opportunities for Windows Store apps to complement desktop software such as AutoCAD.</em></p>  <p><strong>Update:</strong></p>  <p>I found <a href="http://www.zdnet.com/so-what-will-tomorrows-microsoft-look-like-7000007502/" target="_blank">this article</a> an interesting read, today: it ties the vision around WinRT together with the subject of my other AU session, moving desktop functionality to the cloud via Windows Azure.</p>

---
layout: "post"
title: "Caching the results of long browser-based operations in Local Storage"
date: "2016-08-18 10:00:10"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Autodesk Research"
  - "IoT"
  - "PaaS"
original_url: "https://www.keanw.com/2016/08/caching-the-results-of-long-browser-based-operations-in-local-storage.html "
typepad_basename: "caching-the-results-of-long-browser-based-operations-in-local-storage"
typepad_status: "Publish"
---

<p>In the IoT-related (and Forge Viewer-based) prototype I’m spending most of my time working on, we have a long startup operation that instantiates a number of arrays of data with information derived from the BIM. This operation only really needs to be done once per model – every user will get exactly the same information from the model that’s loaded in their own browser instance – but we were calculating it on every load of the model in the Forge Viewer.</p> <p>The question I’d like to look at in this post is the appropriate method for <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">memoization</a> of this function call.</p> <p>I’ve <a href="http://through-the-interface.typepad.com/through_the_interface/2016/06/reflecting-on-the-forge-devcon.html" target="_blank">mentioned</a> in the past that we can now offload this kind of operation to the server – perhaps when the model is uploaded and translated, for instance – using the <a href="https://developer.autodesk.com/en/docs/model-derivative/v2/overview/" target="_blank">Model Derivative API</a>. That would make a lot of sense – and is the preferred longer-term solution – but it also requires a bit more infrastructure work to make happen (we need server-side processing, storage and an API to access it). Another quick and not-particularly-dirty approach is to cache the results for each model on the local client machine and load them (if they exist) from there.</p> <p>Which means the operation goes from being run on every load of the model to being run only the first time the model gets loaded in a particular browser on a particular system. Every user will still have to go through one (relatively) slow load of the model, but things will be much quicker for subsequent loads.</p> <p>The best news is that it’s *really* easy to store information in a browser’s <a href="https://developer.mozilla.org/en/docs/Web/API/Window/localStorage" target="_blank">Local Storage</a>. And the results – in our case, at least – were pretty remarkable.</p> <p>Here are the TypeScript functions I wrote to save to and read from Local Storage:</p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px">&nbsp; <span style="color: blue">public</span> storeObject(key: <span style="color: blue">string</span>, value: <span style="color: blue">any</span>): <span style="color: blue">void</span> {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; localStorage.setItem(</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._buildingMetadata.urn + key, JSON.stringify(value)</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; );</p> <p style="margin: 0px">&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp; <span style="color: blue">public</span> getObject(key: <span style="color: blue">string</span>): <span style="color: blue">any</span> {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">var</span> value = localStorage.getItem(<span style="color: blue">this</span>._buildingMetadata.urn + key);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> value &amp;&amp; JSON.parse(value);</p> <p style="margin: 0px">&nbsp; }</p> <p style="margin: 0px">&nbsp;</p></div> <p>The _buildingMetadata member contains information about the BIM, including the URN we load it from. This is a handy prefix for making sure we keep the information unique to a single model.</p> <p>On load we have a “restoreFromStorage” function which tries to get the various objects from Local Storage: if it’s unsuccessful at any point we go ahead and process the metadata to create our objects. Which we then save to Local Storage for the next time we load.</p> <p>If you open up the browser – in my case Chrome – you can check (and edit) the contents of Local Storage via More Tools –&gt; Developer Tools –&gt; Application –&gt; Local Storage (and then select your domain). You’ll even see some Forge Viewer items in there:</p> <p>&nbsp;</p> <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201b8d21218d5970c-pi" target="_blank"><img title="Local Storage in Chrome" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; border-top-width: 0px; margin-right: auto" border="0" alt="Local Storage in Chrome" src="/assets/image_908320.jpg" width="500" height="342"></a></p> <p>I haven’t specifically benchmarked the performance of this – it depends on the model and on the system crunching the numbers – but for our models the load time for the second and subsequent loads reduces to a fraction of what it was for the first. Which proves the value of doing this centrally via the Model Derivative API, also.</p>

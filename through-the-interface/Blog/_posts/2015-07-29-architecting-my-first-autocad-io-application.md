---
layout: "post"
title: "Architecting my first AutoCAD I/O application"
date: "2015-07-29 13:00:55"
author: "Kean Walmsley"
categories:
  - "AU"
  - "AutoCAD"
  - "AutoCAD I/O"
  - "Geometry"
  - "PaaS"
original_url: "https://www.keanw.com/2015/07/architecting-my-first-autocad-io-application.html "
typepad_basename: "architecting-my-first-autocad-io-application"
typepad_status: "Publish"
---

<p>As mentioned in <a href="http://through-the-interface.typepad.com/through_the_interface/2015/07/visualizing-the-autocad-io-api.html" target="_blank">this recent post</a>, I’ve been working on my AutoCAD I/O-driven web-site on and off for the last few weeks. Lately I’ve had to think beyond certain assumptions I’d made about its architecture, and I thought it worth sharing those thoughts here.</p>  <p>The intention of the site is that you upload an image and then see some edge detection get performed on it, generating an engraving layer for a custom jigsaw puzzle. AutoCAD I/O gets used to generate a drawing that can drive a laser cutter, creating your 100% unique jigsaw puzzle. Basically <a href="https://vimeo.com/98720197" target="_blank">making the world a better place</a> through the power of jigsaws. ;-)</p>  <p align="left">I had originally seen a lot of the work as being done in the browser: we’re already doing the edge detection there, for instance, so why not just send all the engraving information across from the browser to the AutoCAD I/O service in a JSON file, for it to use?</p>  <p align="center"><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201bb085a3feb970d-pi" target="_blank"><img title="Initial design" style="margin: 50px 0px 0px; display: inline" alt="Initial design" src="/assets/image_510417.jpg" width="500" height="375" /></a></p>  <p>The problem with this approach was that the engraving data I needed to transfer to my Node.js service – and from there to AutoCAD I/O – was way too much to encode as URL parameters. Presumably there are other ways of encoding and passing this data from the browser, but it certainly gave me reason to rethink my initial approach.</p>  <p>Back to the drawing board, then. My next design worked on the basis that – rather than relying on the heavy lifting being done in the browser – we could upload the selected image (or a scaled-down version of it) and run our edge detection code in a custom web-service. We launch the upload in the background as soon as the image is selected, so the user should see no lag, from their side. When the user has selected the various options in the browser, the Node.js service gets called again – where our edge detection algorithm gets run, server-side – and will in turn call into AutoCAD I/O for the geometry generation.</p>  <p>That’s a major part of the value proposition of <a href="https://nodejs.org" target="_blank">Node.js</a>: you can run the same code on the server as in the browser. It did mean I had to factor away anything too browser-dependent – such as direct DOM modifications – and then make use of <a href="https://github.com/Automattic/node-canvas" target="_blank">node-canvas</a> (which doesn’t behave exactly like the browser-based canvas… more on this later). Getting node-canvas – which depends on a component called <a href="http://cairographics.org/" target="_blank">Cairo</a> – working in <a href="http://heroku.com" target="_blank">Heroku</a> – my chosen hosting provider – took <a href="https://github.com/mojodna/heroku-buildpack-cairo" target="_blank">quite some effort</a>, but that’s a whole nother story.</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201b8d13f250d970c-pi" target="_blank"><img title="Current design" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin: 50px auto; display: block; padding-right: 0px; border-top-width: 0px" border="0" alt="Current design" src="/assets/image_479484.jpg" width="500" height="375" /></a></p>  <p>This system architecture mostly works very well. You can check out <a href="https://github.com/KeanW/jigsawify" target="_blank">the code in GitHub</a> or <a href="http://jigsawify.com" target="_blank">play with the live site</a>.</p>  <p>There are some caveats, though: the issue of transferring the engraving data to AutoCAD I/O is still there: right now there’s a limit of around 30K characters that can be transferred as parameters for a WorkItem request… which means I can typically encode an engraving of around (say) 200 x 300 with modest pixel density. This may or may not be enough, over time. I did manage to get a ~4x increase in the data I could transfer by encoding pixel data such as [{“X”:0,“Y”:1},{“X”:0,“Y”:2},{“X”:0,“Y”:3},…,{“X”:1,…}] as {“0”:“1,2,3,…”,“1”:“…”}, but that’s just pushing the problem further out.</p>  <p>For now the code iteratively reduces the size of the engraving – when it finds the payload is &gt;30K – until the WorkItem request is small enough to succeed. An alternative would be to post the engraving data somewhere AutoCAD I/O can access it, rather than including it in the request. I expect this is going to form the basis of my next iteration on the design.</p>  <p>A related, alternative – and quickly discarded – architecture was to have the edge detection code running inside AutoCAD I/O itself. We would send a URL for the image to be downloaded and let the code run there. This would mean we would either have to run JavaScript code locally in AutoCAD I/O or re-write the code to work in an I/O-compliant language (i.e. LISP, .NET, C++). Over time it’s possible that the former is an option (today it is not) but I’m not about to re-write working JS code in C#. Even having the existing edge detection code work between the browser and the server created subtle issues: I found the same image loaded using the browser and node-canvas results in slightly different pixel values… which (I believe) leads to different edges being detected. I’ve attempted to mitigate this by adjusting the edge detection threshold when running on the server, but this is basically a kludge.</p>  <p>If you’re interested in other aspects of this design for this application – which will be forming the basis of <a href="http://through-the-interface.typepad.com/through_the_interface/2015/05/autodesk-university-2015-class-proposals.html" target="_blank">my AU2015 class on AutoCAD I/O</a> – then please post a comment!</p>

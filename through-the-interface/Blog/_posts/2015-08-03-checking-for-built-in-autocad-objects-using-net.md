---
layout: "post"
title: "Checking for built-in AutoCAD objects using .NET"
date: "2015-08-03 11:56:51"
author: "Kean Walmsley"
categories:
  - "AutoCAD"
  - "AutoCAD .NET"
  - "Blocks"
  - "Drawing structure"
  - "Runtime"
original_url: "https://www.keanw.com/2015/08/checking-for-built-in-autocad-objects-using-net.html "
typepad_basename: "checking-for-built-in-autocad-objects-using-net"
typepad_status: "Publish"
---

<p>This interesting question came in by email from Igor, over the weekend:</p>  <blockquote>   <p>Let say I want to delete a layer by it's name. I can get ObjectId or LayerTabelRecord&#160; from the name, like</p>    <p>LayerTable tLayers = (LayerTable)</p>    <p>Transaction.GetObject(Database.LayerTableId,OpenMode.ForRead,false) </p>    <p>LayerTableRecord ltRecord = (LayerTableRecord)</p>    <p>Transaction.GetObject(tLayers.Item[Name],OpenMode.ForWrite,false);</p>    <p>Now having LayerTableRecord how can I found out that this DBObject is not the built-in one? Like names '0' or 'DEFPOINTS'.</p>    <p>Same goes for TextStyle (STANDARD) or layout (MODEL)….?</p>    <p>I can't found any property regarding this, like IsBuiltIn. The IsPersistent property is no help.</p> </blockquote>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201bb085d3b5e970d-pi" target="_blank"><img title="Built-in AutoCAD objects in ArxDbg" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: right; padding-top: 0px; padding-left: 0px; margin: 0px 0px 20px 20px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Built-in AutoCAD objects in ArxDbg" src="/assets/image_786955.jpg" width="188" align="right" height="273" /></a>It’s true that there isn’t an IsBuiltIn property on AutoCAD objects… for block definitions you can check IsLayout, although that doesn’t tell you whether the modelspace or a deletable paperspace, mind.</p>  <p>The first suggestion would be to use the very-handy SymbolUtilityServices namespace. I usually use this to check the validity of a symbol name, or to get the ObjectId of a built-in BlockTableRecord – such as modelspace – from a specified Database, but it can also be used to check whether symbols are “built-in”.</p>  <p>Here are the methods you can use – each takes a string – to see whether you have the name of a built-in object:</p>  <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%">   <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsBlockLayoutName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsBlockModelSpaceName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsBlockPaperSpaceName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsLayerDefpointsName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsLayerZeroName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsLinetypeByBlockName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsLinetypeContinuousName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsRegAppAcadName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsTextStyleStandardName()</p>    <p style="margin: 0px"><span style="color: #2b91af">SymbolUtilityServices</span>.IsViewportActiveName()</p>    <p style="margin: 0px">&#160;</p> </div>  <p>So it’s not quite a simple as checking a property, but you can, at least, validate whether a name is “built-in” before you choose to do something destructive with the associated object.</p>  <p>One other thought occurred to me: if you wanted to do this more dynamically – i.e. protect a set of objects beyond those baked into the SymbolUtilityServices API – then you could drive it from the standard drawing template (e.g. <em>acad.dwt</em>). You would have some kind of “database” (which could simple be a JSON file) that is created by code that traverses the drawing structure in the file. It might also be hand-crafted, but the effort to automate it should be modest, and it would allow the file to be recreated when additional “standard” objects get added.</p>  <p>This “database” would then be read into memory and used at runtime to validate whether the user (or the application) should be allowed to modify or erase certain objects. It could be done at the name- or the ObjectId-level: we could create a simple list of “protected” ObjectIds the first time we need to check an modify operation on a particular drawing.</p>  <p>It strikes me that this must be a fairly common issue. Has anyone else address this in their application, in some (other) way?</p>

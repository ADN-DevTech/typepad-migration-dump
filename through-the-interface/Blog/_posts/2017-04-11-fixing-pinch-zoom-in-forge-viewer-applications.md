---
layout: "post"
title: "Fixing pinch-zoom in Forge viewer applications"
date: "2017-04-11 17:09:42"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Autodesk Research"
  - "PaaS"
original_url: "https://www.keanw.com/2017/04/fixing-pinch-zoom-in-forge-viewer-applications.html "
typepad_basename: "fixing-pinch-zoom-in-forge-viewer-applications"
typepad_status: "Publish"
---

<p>Over the last few days I’ve been working to improve support for touch devices in <a href="http://dasher360.com" target="_blank">Dasher 360</a>: the primary focus is on touch-enabled TVs and monitors, but I’ve been doing much of the testing for this on my mobile phone. Which means things are steadily getting better for people wanting to use phones and tablets to access the site, too.</p> <p>It turns out – and this may not come as a surprise to many of you – that the default pinch behaviour in the Forge viewer is to do an unconstrained orbit. No zoom, just the orbit mode that makes the least sense for building models. So the experience inside Dasher 360 was frankly really bad.<a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201bb098f6286970d-pi" target="_blank"><img title="Broken pinch-zoom in Dasher 360" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin: 30px auto; border-left: 0px; display: block; padding-right: 0px" border="0" alt="Broken pinch-zoom in Dasher 360" src="/assets/image_66802.jpg" width="500" height="312"></a></p> <p>The good news is that it’s actually pretty easy to override the default behaviour and add custom touch-gesture support inside your Forge viewer applications. The key to doing this is to create your own object that implements <a href="https://developer.autodesk.com/en/docs/viewer/v2/reference/javascript/toolinterface/" target="_blank">Autodesk.Viewing.ToolInterface</a>, and in particular the handleGesture() function. This allows you to intercept a number of operations: in our case we want to override the behaviour of “pinch” and “rotate” gestures, converting each to a zoom, but you can also modify the “drag” operation, if you so wish.</p> <p>Here’s some TypeScript code that implements this function in a way that makes sense for us. I haven’t included the rest of the class, as it doesn’t really contribute anything.<br></p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">handleGesture(event: any): boolean {</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp; <span style="color: green">// We don't care about drag gestures - leave these to another handler</span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp; <span style="color: blue">if</span> (event.type.indexOf(<span style="color: #a31515">'drag'</span>) === 0) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> <span style="color: blue">false</span>;</p> <p style="margin: 0px">&nbsp; } <span style="color: blue">else</span> <span style="color: blue">if</span> (event.type.indexOf(<span style="color: #a31515">'pinch'</span>) === 0 || event.type.indexOf(<span style="color: #a31515">'rotate'</span>) === 0) {</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Pinch or rotate gestures should result in a zoom (with no rotation)</span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> target = <span style="color: blue">this</span>._viewer.navigation.getTarget();</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">if</span> (event.type === <span style="color: #a31515">'pinchstart'</span> || event.type === <span style="color: #a31515">'rotatestart'</span>) {</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: green">// When the gesture starts, we'll store the view direction</span></p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: green">// and initial distance between the camera and target </span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> position = <span style="color: blue">this</span>._viewer.navigation.getPosition();</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._direction = <span style="color: blue">new</span> THREE.Vector3();</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._direction.subVectors(position, target);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._dist = <span style="color: blue">this</span>._direction.length();</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// Then we normalize the direction vector and multiply it by the</span></p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// scale factor of the gesture, adding this to the target to get</span></p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: green">// the new camera position</span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._direction.normalize();</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._direction.multiplyScalar(<span style="color: blue">this</span>._dist / event.scale);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> newPos = target.add(<span style="color: blue">this</span>._direction);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._viewer.navigation.setPosition(newPos);</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> <span style="color: blue">true</span>;</p> <p style="margin: 0px">&nbsp; }</p> <p style="margin: 0px">&nbsp; <span style="color: blue">return</span> <span style="color: blue">false</span>;</p> <p style="margin: 0px">}</p> <p style="margin: 0px">&nbsp;</p></div> <p>Adding the “tool” is easy: you call viewer.toolController.registerTool(tool) and then viewer.toolController.activateTool(tool.getName()). The last-added tools get called first – before the built-in ones – allowing custom functions to return true and essentially stop events from propagating to other tools. If you return false then other tools will be called – it’s really up to you to decide the appropriate behaviour for your application.</p> <p>To see how things work without – and then with – this custom gesture interception, watch this video:</p> <p align="center">&nbsp;</p> <p align="center"><iframe height="281" src="https://www.youtube-nocookie.com/embed/SkhOhMp3Gj4?rel=0&amp;showinfo=0?ecver=1" frameborder="0" width="500" allowfullscreen></iframe></p> <p align="center">&nbsp;</p> <p>As you can hopefully see, this makes a big difference for touch-based usability.</p>

---
layout: "post"
title: "Animating robots in the Forge viewer"
date: "2018-09-28 11:01:19"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Autodesk Research"
  - "Robotics"
  - "Solid modeling"
original_url: "https://www.keanw.com/2018/09/animating-robots-in-the-forge-viewer.html "
typepad_basename: "animating-robots-in-the-forge-viewer"
typepad_status: "Publish"
---

<p>The inspiration for this post has come from a variety of sources. (Feel free to skip this preamble where I talk about the history of the project: as much as anything it’s so I remember myself how things happened when I come back to this post at some point in the future. ;-)</p><p>My colleague, Simon Breslav, worked on an <a href="http://through-the-interface.typepad.com/through_the_interface/2017/10/dasher-360-at-autodesk-university-and-the-forge-devcon.html" target="_blank">initial implementation in Dasher 360 that animated robots</a> – and even mapped stress information to their surfaces – for a demo shown at AU 2017, back when I was <a href="http://keanw.com/round-the-world" target="_blank">travelling around the world with my family</a>. One of the issues Simon had with his implementation was the amount of per-model configuration required: the mechanism was linked to specific components that somehow had to be identified in the model (for the demo this was hardcoded).</p><p>Simon’s work was partly driven by a <a href="http://www.keanw.com/2018/02/dasher-360-at-the-advanced-manufacturing-facility.html" target="_blank">collaboration with the AMF in the UK</a>, where we knew we’d one day want to display animated robots inside <a href="http://dasher360.com" target="_blank">Dasher 360</a>.</p><p>More recently I started working on displaying human skeletons <a href="http://www.keanw.com/2018/08/adding-3d-geometry-to-a-scene-in-the-forge-viewer.html" target="_blank">inside</a> <a href="http://www.keanw.com/2018/09/displaying-skeletons-in-the-forge-viewer-part-1.html" target="_blank">the</a> <a href="http://www.keanw.com/2018/09/displaying-skeletons-in-the-forge-viewer-part-2.html" target="_blank">Forge</a> <a href="http://www.keanw.com/2018/09/displaying-skeletons-in-the-forge-viewer-part-3.html" target="_blank">viewer</a>. It turns out that using a bone structure for a skeleton isn’t currently needed for Dasher 360, as we’re <a href="http://www.keanw.com/2018/09/when-in-rome.html" target="_blank">deriving the joint positions from video footage</a>, and don’t need to worry about the various joint angles between limbs.</p><p>For robots, however, we will be capturing the angles of the various joints, which really lends itself to using a bone structure of connected parts. During and after <a href="http://www.keanw.com/2018/09/robarch-2018.html" target="_blank">Rob|Arch 2018</a> I worked on enabling the animation of skinned meshes inside the Forge viewer. This resulted in the ability to create and animate a skinned mesh with basic geometry – that I created in code – for each of the limbs, but my goal wasn’t to define the geometry of a robot in code, it was to allow loading of external robot models that were created using a 3D modelling tool of some sort.</p><p>During the Forge accelerator in Rome I hit my head against the limitations of various object loaders inside r71 of three.js (the one currently supported by the Forge viewer):</p><ul><li>The glTF loader in that version was only for v1.0 of the spec, and had a number of issues.</li><li>The JSON format supported by three.js at that time didn’t seem to include any joint information.</li><li>Collada seemed the only way to go, but was limited at v1.4.x in that version of the toolkit.</li></ul><p>In the long-term I think glTF is probably my preferred option for bringing 3D data into three.js, but it’s not really an option with r71. Collada looked like a decent option, but in v1.4 it only supports skinning and not kinematics (the distinction seeming to be that skinned models have their mesh vertices morphed along with changes to its bone structure, while kinematics can just apply transformations to rigid bodies… I’ve probably stated this poorly – not being a domain expert – so feel free to correct me in the comments).</p><p>The <a href="https://www.turbosquid.com/FullPreview/Index.cfm/ID/1113575" target="_blank">rigged model of a Kuka KR-1000 industrial robot</a> I got from TurboSquid included a DAE (Collada) file that was v1.4.1. This was a good thing, in that three.js r71 could at least load it. The bad news was that if you just brought it into the viewer – by adding the loaded geometry directly into the Forge viewer scene – then it resulted in geometry that was poorly positioned.</p><p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad36e8c6c200c-pi" target="_blank"><img width="500" height="432" title="Poorly positioned geometry, the default from importing a rigged Collada scene" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="Poorly positioned geometry, the default from importing a rigged Collada scene" src="/assets/image_330956.jpg" border="0"></a></p><p>I could go through the individual meshes in the model and add these into the scene…</p><p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad3b45527200b-pi" target="_blank"><img width="500" height="246" title="Kuka robots in the Forge viewer" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="Kuka robots in the Forge viewer" src="/assets/image_300395.jpg" border="0"></a></p><p>… but these wouldn’t animate with the attached skeleton. Argh.</p><p>When I got home from Rome I found this simple bit of advice that seemed a great way to add your own kinematics to a model: you can <a href="https://stackoverflow.com/questions/19031198/three-js-attaching-object-to-bone" target="_blank">add a mesh to any bone in a skeleton and it will get transformed along with it</a>. Perfect! Now all I had to do was to find a way to parse the scene loaded from the Collada file and attach the various meshes to their corresponding bones.</p><p>Here’s the algorithm I used to load in the Collada model and attach component meshes to the bones:</p><ol><li>Clone the first skinned mesh from the Collada file and add it into the viewer scene.</li><ul><li>This defines the skeleton – with its various bones – for the robot model.</li><li>In our case the mesh only represented a flexible hose (which presumably it supposed to deform as the skeleton moves), but I just set its material to invisible.</li></ul><li>Call a recursive function that searches the Collada scene for the meshes that correspond to its bones.</li><ul><li>If we find an object in the scene that has the same name as a bone, get its children and add the meshes that correspond to them into the viewer.</li><ul><li>We can create a simple THREE.Mesh using the geometry in <font face="Courier New" size="2">collada.dae.geometries['XXX-mesh'].mesh.geometry3js</font> (where XXX is the name of the child).</li><li>If you add them “as is”, then the results are just as we saw when we first imported the model: the transforms are messed up in exactly the same way.</li><ul><li>The difference being the meshes at meast move (albeit in the wrong place) with the skeleton. Progress!</li><li>To get them to show up in the right place, we need to apply the inverse of the new owner’s matrixWorld.</li></ul></ul><li>In most cases we add the mesh to the bone directly: in case you need to fix some geometry (such as the base of the robot) then this needs to be added to the parent (the scene itself).</li></ul><li>Create a THREE.SkeletonHelper object, passing in our mesh. Add the mesh to the scene (and the helper, if you want the bone structure to be visible, too).</li><li>Periodically you’ll want to change the joint angles on the various bones: this will allow you to animate the robot, whether based on real or simulated data.</li></ol><p>Once implemented in code, in turns out that this approach doesn’t even require skinning to be enabled: it works perfectly with the shipping Forge viewer. Hooray!</p><p>Something we learned, a few posts ago, is that in order to animate an object inside the Forge viewer it needs to have its material’s depthTest property set to false. This allows the scene to be updated without a full render. The downside is that you can see the object “through walls” (and other geometry) and even its own components are drawn in an arbitrary order.</p><p>This means there’s no point trying to apply a nice Phong material with shadows, etc. Here’s what it looks like when you do:</p><p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad36e8c70200c-pi" target="_blank"><img width="500" height="447" title="Phong materials don't work with depthTest set to false" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="Phong materials don't work with depthTest set to false" src="/assets/image_885194.jpg" border="0"></a></p><p>Using a basic mesh material things look a little better, but it’s still not great:</p><p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad36e8c78200c-pi" target="_blank"><img width="500" height="488" title="Basic shaded materials look better" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="Basic shaded materials look better" src="/assets/image_231754.jpg" border="0"></a></p><p>The best approach, in my opinion, is to make the material wireframe. It adds a really nice feel to it.<a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad394b6e4200d-pi" target="_blank"><img width="500" height="539" title="And now in wireframe" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="And now in wireframe" src="/assets/image_457294.jpg" border="0"></a></p><p>Here’s how things look when animated:</p><p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad36e8c7d200c-pi" target="_blank"><img width="500" height="400" title="Wireframe robot" style="margin: 30px auto; float: none; display: block;" alt="Wireframe robot" src="/assets/image_235651.jpg"></a></p><p>Performance is pretty decent, and the wireframe view makes multiple overlapping robots display well, too.</p><p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad394b779200d-pi" target="_blank"><img width="500" height="336" title="Wireframe robots" style="margin: 30px auto; float: none; display: block;" alt="Wireframe robots" src="/assets/image_742972.jpg"></a></p><p>For the future: once we’re able to use a recent three.js version, we’ll also be able to use Collada v1.5 files. Which can contain kinematics data directly, <a href="https://threejs.org/examples/#webgl_loader_collada_kinematics" target="_blank">allowing stuff like this</a>. There’s also a <a href="https://github.com/rdiankov/collada_robots" target="_blank">much broader set of models available</a>, thanks largely to the <a href="http://openrave.org/docs/latest_stable/robots_overview/" target="_blank">OpenRAVE project</a>. If we end up needing to be on r71 for some time to come, I’ll probably need to look into how best to create Collada v1.4 files from Autodesk tools, and see whether the scene structure can be managed by the code I’ve used to import the model for this post. We’ll see.</p><p>A quick word of thanks… Petr Broz and Cyrille Fauvel both helped me a huge amount during the Forge accelerator in Rome: it’s largely thanks to these two that I was able to sift through the various options and progress to the point where I could make this work on my own. Thanks again for all your help, guys!</p><p>Next week I’m flying across to Amsterdam to help with a project we’re working on with <a href="http://keanw.com/2018/04/checking-out-the-worlds-first-3d-printed-steel-bridge-at-mx3d-in-amsterdam.html" target="_blank">MX3D</a> for Dutch Design Week. Later in the week I’ll fly across to Barcelona to give a presentation on our generative design efforts in the AEC space. I’ll hopefully find the time to write a blog post or two, at some point…</p>

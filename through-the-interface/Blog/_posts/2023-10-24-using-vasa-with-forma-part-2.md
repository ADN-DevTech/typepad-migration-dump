---
layout: "post"
title: "Using VASA with Forma - Part 2"
date: "2023-10-24 14:16:29"
author: "Kean Walmsley"
categories:
  - "Autodesk Research"
  - "Forma"
  - "VASA"
  - "Web/Tech"
original_url: "https://www.keanw.com/2023/10/using-vasa-with-forma-part-2.html "
typepad_basename: "using-vasa-with-forma-part-2"
typepad_status: "Publish"
---

<p>In <a href="https://www.keanw.com/2023/10/using-vasa-with-forma-part-1.html" rel="noopener" target="_blank">the first post in this series</a> we looked at an approach for exporting Forma geometry to an STL file that can be loaded into Dynamo and analysed using VASA, our Voxel-based Architectural Space Analysis toolkit. The overall goal is to be able to use VASA for urban-scale analysis of the site context. (Later on I hope we’ll also be able to work with more detailed architectural geometry as the level of detail in Forma evolves.)</p>
<p>In that post I also alluded to something that’s coming soon which will streamline the above workflow: you’ll hear more about that at AU 2023 if you’re lucky enough to be attending that event.</p>
<p>Today I wanted to talk about a prototype integration of VASA directly into Forma. Using the same approach as the “Export STL” extension we saw last time - an Embedded View that displays an HTML-based dialog inside one of Forma’s two panels - we can host VASA’s WebAssembly package and use it directly within the Forma browser environment.</p>
<p>I’ve talked about VASA’s WebAssembly package before: the first time was 2 years ago, in the context of <a href="https://www.keanw.com/2021/10/streamlines-in-the-forge-viewer.html" rel="noopener" target="_blank">displaying streamlines in the APS (or Forge, at the time) Viewer</a>, and soon after about how it was possible to <a href="https://www.keanw.com/2021/12/using-vasa-via-webassembly-for-pathfinding-inside-formit.html" rel="noopener" target="_blank">use it directly inside FormIt to solve mazes</a>.</p>
<p>For those of you who aren’t familiar with WebAssembly (or Wasm), it’s a way to package code - very often written in languages that have direct memory management such as C++ or Rust, rather than memory managed (typically garbage collected) languages - into a form that can be loaded and used in a browser, which really means called from your traditional Javascript code. In our case we’ve used Emscripten to take our low-level C++ toolkit (the same one that is exposed via Dynamo nodes in the public package) to build a Wasm file and accompanying Javascript loader. I first started <a href="https://www.keanw.com/2015/07/autodesk-technical-summit-2015.html" rel="noopener" target="_blank">playing with Emscripten back in 2015</a> but VASA is the first “real” project I’ve had the chance to use it with.</p>
<p>The Wasm version of VASA weighs in at around 800KB and performs surprisingly well. I’ll demo it at our AU class on VASA, but have included some videos in today’s post. We don’t currently have plans for this to move beyond research: the point of showing these videos is to provide some inspiration for how VASA might be used in more integrated workflows but also to show the flexibility of the Forma extension system and Embedded View SDK.</p>
<p>To get things rolling with the project we integrated pathfinding into Forma. There&#39;s a sequence of steps that get represented by buttons in this version: getting the scene geometry, then triangulating and voxellising it.</p>
<p><a class="asset-img-link" href="/assets/image_957932.jpg" rel="noopener" target="_blank"><img alt="VASA pathfinding in Forma" border="0" class="asset  asset-image at-xid-6a00d83452464869e202c8d3a0ecd4200b img-responsive" src="/assets/image_957932.jpg" style="display: block; margin: 30px auto;" title="VASA pathfinding in Forma" width="500" /></a></p>
<p>You’ll notice that the user is having to manipulate a point using sliders, rather than interacting directly with the Forma canvas. This is a near-term workaround until that particular capability gets implemented, but it’s actually quite OK once you get used to it.</p>
<p>In the next version it&#39;s mostly about streamlining the UX: the path redraw is smoother and the sliders are colour-coded.</p>
<p><a class="asset-img-link" href="/assets/image_388479.jpg" rel="noopener" target="_blank"><img alt="Smoother VASA pathfinding in Forma" border="0" class="asset  asset-image at-xid-6a00d83452464869e202c8d39cd540200c img-responsive" src="/assets/image_388479.jpg" style="display: block; margin: 30px auto;" title="Smoother VASA pathfinding in Forma" width="500" /></a>Being reasonably happy with the state of pathfinding, it was time to turn to visibility. The idea here was to show the voxels of the visibility calculated from a point (which would once again be manipulated using sliders, along with an additional one for the maximum visibility distance).</p>
<p><a class="asset-img-link" href="/assets/image_539558.jpg" rel="noopener" target="_blank"><img alt="VASA visibility in Forma" border="0" class="asset  asset-image at-xid-6a00d83452464869e202c8d39cd59d200c img-responsive" src="/assets/image_539558.jpg" style="display: block; margin: 30px auto;" title="VASA visibility in Forma" width="500" /></a>I was actually really happy with this! Apart from one thing: when the visibility is clipped by a building (which is, after all, the whole point of showing a visibility dome) it&#39;s hard to see where the dome is cut away.</p>
<p><a href="/assets/image_450015.jpg" rel="noopener" target="_blank"><img alt="Undelineated dome" border="0" height="375" src="/assets/image_450015.jpg" style="display: block; margin: 30px auto;" title="Undelineated dome" width="500" /></a></p>
<p>I was chatting about this with my old friend Simon Breslav, who suggested darkening the color based on the distance from the centre of the sphere (the visibility point).</p>
<p>Here are a few of the fun results I got on the way there:</p>
<p><a href="/assets/image_541399.jpg" rel="noopener" target="_blank"><img alt="Zebra dome" border="0" height="375" src="/assets/image_541399.jpg" style="display: block; margin: 30px auto;" title="Zebra dome" width="500" /></a></p>
<p><a href="/assets/image_984026.jpg" rel="noopener" target="_blank"><img alt="Unicorn dome" border="0" height="375" src="/assets/image_984026.jpg" style="display: block; margin: 30px auto;" title="Unicorn dome" width="500" /></a></p>
<p><a href="/assets/image_982562.jpg" rel="noopener" target="_blank"><img alt="Some RGB overflow issues" border="0" height="375" src="/assets/image_982562.jpg" style="display: block; margin: 30px auto;" title="Some RGB overflow issues" width="500" /></a></p>
<p><a href="/assets/image_420908.jpg" rel="noopener" target="_blank"><img alt="Almost there" border="0" height="375" src="/assets/image_420908.jpg" style="display: block; margin: 30px auto;" title="Almost there" width="500" /></a></p>
<p>The only issue with the above was the fact that - due to a quirk of the code I used to colour the dome - it was being coloured per triangle rather than per vertex.</p>
<p><a href="/assets/image_494214.jpg" rel="noopener" target="_blank"><img alt="A nicely rendered visibility field" border="0" height="375" src="/assets/image_494214.jpg" style="display: block; margin: 30px auto;" title="A nicely rendered visibility field" width="500" /></a></p>
<p>When I fixed that issue, the dome was shaded perfectly, but perhaps too perfectly: I liked the glitchiness of the previous implementation - in terms of the way it made the curvature of the dome more obvious - so I introduced an additional “roughness” slider that created a cork-like effect on the outside of the dome by adding a random darkness factor to the outer triangles.</p>
<p><a href="/assets/image_378751.jpg" rel="noopener" target="_blank"><img alt="Now with roughness applied to the exterior shell" border="0" height="375" src="/assets/image_378751.jpg" style="display: block; margin: 30px auto;" title="Now with roughness applied to the exterior shell" width="500" /></a></p>
<p>Here’s a video of the “final” (this may evolve as new thoughts occur, of course) version that has a further streamlined UI (fewer buttons, more toggles) and the visualization features I wanted.<a class="asset-img-link" href="/assets/image_996214.jpg" rel="noopener" target="_blank"><img alt="VASA visibility in Forma" border="0" class="asset  asset-image at-xid-6a00d83452464869e202c8d3a0f202200b img-responsive" src="/assets/image_996214.jpg" style="display: block; margin: 30px auto;" title="VASA visibility in Forma" width="500" /></a>This is the version we&#39;ll be seeing in <a href="https://conferences.autodesk.com/flow/autodesk/au2023/sessioncatalog/page/inperson/session/1686766044586001Z9UY" rel="noopener" target="_blank">our VASA class in Las Vegas</a>, although probably with a Forma project showing The Strip rather than my home town.</p>
<p>I admit I&#39;ve been very impressed with the potential for integrating WebAssembly with our various web-based environments (whether inside a Forma extension or a web-site embedding the APS Viewer or Tandem SDK). Just as the AutoCAD team has found with their groundbreaking work on AutoCAD Web (also built from C++ to target the browser via Wasm) it&#39;s a great solution for executing complex code in browser-based environments where you want the code to execute locally rather than relying on server-side computation.</p>

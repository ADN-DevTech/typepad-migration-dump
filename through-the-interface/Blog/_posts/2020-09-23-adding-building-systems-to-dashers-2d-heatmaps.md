---
layout: "post"
title: "Adding building systems to Dasher&rsquo;s 2D heatmaps"
date: "2020-09-23 14:03:40"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "AU"
  - "Autodesk Research"
  - "IoT"
original_url: "https://www.keanw.com/2020/09/adding-building-systems-to-dashers-2d-heatmaps.html "
typepad_basename: "adding-building-systems-to-dashers-2d-heatmaps"
typepad_status: "Publish"
---

<p>As a recap, so far in this series we’ve looked at <a href="https://www.keanw.com/2020/08/displaying-a-2d-heatmap-when-surface-shading-inside-dasher.html" target="_blank">creating 2D heatmaps</a>, <a href="https://www.keanw.com/2020/08/creating-a-resizable-square-panel-inside-the-forge-viewer.html" target="_blank">making them resizable</a>, <a href="https://www.keanw.com/2020/09/viewing-multiple-heatmaps-inside-project-dasher.html" target="_blank">adding lots of them</a> inside <a href="https://dasher360.com/" target="_blank">Project Dasher</a>, and then <a href="https://www.keanw.com/2020/09/pinning-2d-heatmaps-per-level-in-project-dasher.html" target="_blank">making them pinnable per-level</a>.</p><p>There are two main tasks left for the completed feature – which will form the core of my upcoming class for AU2020 – which are to add information on building systems and to implement a UI to make these new views easier to access.</p><p>Today we’re focusing on adding building system information. Let’s first step back and talk about why this is important…</p><p>One of the key insights we’ve derived over the years with Project Dasher is that <strong>data correlation is valuable</strong>. This might mean correlating occupancy data with CO2 levels, or seeing people moving across a bridge and comparing that with stress levels. Context is important.</p><p>In this series we’ve already seen the introduction of the ability to correlate data across sensor types – something that was possible before, but not in a highly visual way – but also to correlate these sensor types across levels of a building (which we saw in the last post with pinning). I expect both of these to be valuable in their own way, but today’s post introduces another potentially interesting type of correlation: the ability to compare data captured by sensors with geometric information about a building’s internal systems.</p><p>This allows us to really understand the context of the data in new ways: how light levels behave relative to the placement of lighting fixtures, for instance, or how temperature variation across an open space is influenced by the HVAC system.</p><p>Forge does provide 2D geometry streams, but they typically need to set up and published. For our workflow we’re going to base our 2D layers on information that exists in 3D (hopefully, anyway, otherwise the feature won’t do much for people). We saw the ability to <a href="https://www.keanw.com/2019/10/knee-deep-in-au-prep.html" target="_blank">view layers in 3D during my preparation for AU2019</a>, and we’re going to leverage the same feature for our 2D work: you need to find a way to define your layers, whether by filtering by object type or by assuming the geometry comes from a specific source file. We’ll assume that you have a list of dbIds for each layer, anyway.</p><p>Here’s the approach I found to flatten this 3D geometry into 2D layers. This is all quite detailed – it’s something that should probably be considered an advanced topic in terms of development with the Forge viewer – so feel free to skip over it if you’re not interested in the nitty gritty.</p><ul><li>Create a material (a THREE.MeshBasicMaterial is fine) for each layer with a different colour.</li><ul><li>It makes sense for these materials to be at least partially transparent (I went with 50%).</li></ul><li>Get the instanceTree and call enumNodeFragments() on each dbId defining a particular layer.</li><ul><li>Get a renderProxy for each fragment, and convert its geometry to “simple” THREE.js geometry.</li><ul><li>We do this by enumerating the mesh vertices and faces, copying them across to the new geometry definitions.</li></ul><li>Check the bounding box of the fragment: work out which level(s) it’s on by doing a simple intersection with the bounding boxes for the various levels.</li><li>Create a mesh for the new geometry and the layer’s material.</li><li>Add the mesh to a scene for each level.</li></ul><li>Now that we have a scene containing the geometry of the various layers for each level, render each into a texture (the dimensions of which need to match the bounds of our heatmaps per-level).</li><ul><li>This is a bit complicated, but it involves creating an orthographic camera looking down onto the scene – making it 2D – and adjusting it to fit the bounds of heatmap’s scene.</li><ul><li>This is the same approach as was used to generate the 2D heatmaps themselves.</li></ul><li>We render it using a custom THREE.WebGLRenderer and our own THREE.WebGLRenderTarget.</li></ul><li>At this stage we should have a single texture for each level: we can dispose of the scenes that were used to generate them, as they won’t be needed anymore.</li><li>To render these layer textures on our per-level heatmaps, we map each to a plane.</li><ul><li>Create some THREE.PlaneBufferGeometry with the dimensions we care about (for our heatmaps these just need to be square).</li><li>We create a THREE.MeshBasicMaterial using the texture as a map – once again with a touch of transparency – and set depthTest and depthWrite to false.</li><li>The Mesh displaying this texture needs to be positioned relative to the bounding box for it to align properly.</li><ul><li>This took me ages to work out, but the mesh’s position needs to be the exact centre of the bounding box.</li></ul></ul><li>When we render the heatmaps – even when animated – we can now choose to include the layer overlay.</li><ul><li>We need to make sure autoClear is turned off on the renderer, to make sure we combine the two render passes.</li></ul></ul><p>For the NEST model we can see how going through the levels causes an overlay to be displayed for the mechanical system (most of which is in the basement):</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2026bde954185200c-pi" target="_blank"><img width="500" height="341" title="Heatmaps with layers" style="margin: 30px auto; float: none; display: block;" alt="Heatmaps with layers" src="/assets/image_45403.jpg"></a></p><p>This geometry is available in the 3D view, of course, but it’s interesting to see it now in 2D, too.</p><p>And this style of overlay also works with heatmap animations:</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2026be4140af1200d-pi" target="_blank"><img width="500" height="493" title="CO2 with mechanical" style="margin: 30px auto; float: none; display: block;" alt="CO2 with mechanical" src="/assets/image_680185.jpg"></a></p><p>The IKON building model has a more extensive set of geometry layers available. Here’s a view of temperature heatmaps of the first and second floors:</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2026be4140d8f200d-pi" target="_blank"><img width="500" height="270" title="IKON first and second floor temperature" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="IKON first and second floor temperature" src="/assets/image_225932.jpg" border="0"></a></p><p>And here they are with the MEP layers toggled on:</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e20263e967e942200b-pi" target="_blank"><img width="500" height="270" title="IKON first and second floor temperature, with MEP" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="IKON first and second floor temperature, with MEP" src="/assets/image_664778.jpg" border="0"></a></p><p>To try this for yourself you can toggle the option on in Dasher’s Appearance settings. Bear in mind that the first time you do this it can take quite some time to extract the geometry and overlay the textures (it’s the geometry processing that takes the time). You’ll know it’s done when the graphics appear and/or the toggle turns blue. If you leave this option toggled on, then the processing will be performed – and the additional time taken – when Dasher starts, but you won’t then have to wait to toggle between modes, as all the required textures will be available.</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2026bde954bf5200c-pi" target="_blank"><img width="500" height="452" title="Toggling layers on and off" style="margin: 30px auto; float: none; display: block;" alt="Toggling layers on and off" src="/assets/image_883720.jpg"></a></p><p>I think this could be a really interesting way to correlate geometry representing systems with IoT data. If you agree, disagree, or have other thoughts about how it may be used, please post a comment!</p>

---
layout: "post"
title: "Getting better-looking text in your Dynamo graph output"
date: "2020-04-30 18:55:45"
author: "Kean Walmsley"
categories:
  - "Autodesk Research"
  - "Dynamo"
  - "Generative design"
original_url: "https://www.keanw.com/2020/04/getting-better-looking-text-in-your-dynamo-graph.html "
typepad_basename: "getting-better-looking-text-in-your-dynamo-graph"
typepad_status: "Publish"
---

<p>One of my pet peeves with Dynamo – as I typically use it standalone from Revit – is the quality of the text you can generate as graphics: the <a href="https://github.com/DynamoDS/DynamoText/blob/master/Text.cs" target="_blank">Dynamo Text</a> package will generate curves (actually lots of little lines) that represent the outline of your characters, but they often look quite lame depending on your zoom level. Actually scratch that – they look lame irrespective of the zoom level. Sigh.</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e20263d6f81567200d-pi" target="_blank"><img width="400" height="556" title="Dynamo Text out of the box" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="Dynamo Text out of the box" src="/assets/image_336743.jpg" border="0"></a></p><p>Anyway – today I finally dug into what I needed to do to create better-looking text as output from your Dynamo graphs.</p><p>My first attempt was to create a bunch of closed curves from the line segments, and then patch them with surfaces. Which looked liked I’d gone spray-painting with a poor stencil.</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e20263d3f8813a200c-pi" target="_blank"><img width="400" height="540" title="Filling the gaps - all of them" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="Filling the gaps - all of them" src="/assets/image_285912.jpg" border="0"></a></p><p>With some thought – and a little bit of sweat, I admit – I settled on a process that works well:</p><ol><li>Take the output from the Dynamo Text node.</li><li>Create PolyCurves from the line segments using Ampersand’s PolyCurve.ByCurves node.</li><li>Process the (hopefully now closed) loops with a Python script (code is provided below), to find the enclosed loops (the “children”) and the enclosing ones (the “parents”).</li><ul><li>To search the list of loops efficiently, we first sort it based on each item’s minimum bounding box point, and then assume that we only need to compare each potential child with the ones that come before it in the list, to see whether any of them enclose it (i.e. are its parent).</li><li>It’s really important to treat separate lines of text independently – hence us passing in a list – as otherwise performance will die in a combinatorial explosion.</li></ul><li>Create surfaces from each set – parents, children and others – and then get the difference between the parents and the children.</li><li>View the differenced surfaces and the others (the ones with no loops).</li></ol><p>The results look much better!</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e20263d6f81595200d-pi" target="_blank"><img width="400" height="523" title="The best I could get" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="The best I could get" src="/assets/image_459941.jpg" border="0"></a></p><p>Here’s the graph, for now. At some point I’ll look at whether it makes sense to build it into a custom node/package. We’ll see.</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e20263d3f880ff200c-pi" target="_blank"><img width="500" height="132" title="The graph, for now" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" alt="The graph, for now" src="/assets/image_456241.jpg" border="0"></a></p><p>There is some performance hit – as there’s quite a lot of geometry to process – but I think it’s a decent compromise for the final creation of your presentation graphics (such as when you want to do use Capturefinery on your Refinery study).</p><p>Here’s the code for the “Fill Text” Python node:</p><p><div class="vscode" style="white-space: pre;"><div><span style="color: rgb(106, 153, 85);"># Imports</span></div><div><br></div><div><span style="color: rgb(197, 134, 192);">import</span><span style="color: rgb(212, 212, 212);"> clr</span></div><div><span style="color: rgb(212, 212, 212);">clr.AddReference(</span><span style="color: rgb(206, 145, 120);">'ProtoGeometry'</span><span style="color: rgb(212, 212, 212);">)</span></div><div><span style="color: rgb(197, 134, 192);">from</span><span style="color: rgb(212, 212, 212);"> Autodesk.DesignScript.Geometry </span><span style="color: rgb(197, 134, 192);">import</span><span style="color: rgb(212, 212, 212);"> *</span></div><div><br></div><div><span style="color: rgb(106, 153, 85);"># Main</span></div><div><br></div><div><span style="color: rgb(212, 212, 212);">boundaries_list = IN[</span><span style="color: rgb(181, 206, 168);">0</span><span style="color: rgb(212, 212, 212);">]</span></div><div><br></div><div><span style="color: rgb(212, 212, 212);">children_out = []</span></div><div><span style="color: rgb(212, 212, 212);">parents_out = []</span></div><div><span style="color: rgb(212, 212, 212);">others_out = []</span></div><div><br></div><div><span style="color: rgb(106, 153, 85);"># Return the minimum point of a geometry's bounding box</span></div><div><br></div><div><span style="color: rgb(86, 156, 214);">def</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(220, 220, 170);">getMin</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(156, 220, 254);">geom</span><span style="color: rgb(212, 212, 212);">):</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; bb = BoundingBox.ByGeometry(geom)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(220, 220, 170);">min</span><span style="color: rgb(212, 212, 212);"> = bb.MinPoint</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">return</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(220, 220, 170);">min</span><span style="color: rgb(212, 212, 212);">.X, </span><span style="color: rgb(220, 220, 170);">min</span><span style="color: rgb(212, 212, 212);">.Y</span></div><div><br></div><div><span style="color: rgb(106, 153, 85);"># Check a list of potential parents, and return the ones</span></div><div><span style="color: rgb(106, 153, 85);"># that contain the child (comparing bounding boxes)</span></div><div><br></div><div><span style="color: rgb(86, 156, 214);">def</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(220, 220, 170);">getParents</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(156, 220, 254);">child</span><span style="color: rgb(212, 212, 212);">, </span><span style="color: rgb(156, 220, 254);">parents</span><span style="color: rgb(212, 212, 212);">):</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; parent_list = []</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; bb1 = BoundingBox.ByGeometry(child)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">for</span><span style="color: rgb(212, 212, 212);"> parent </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);"> parents:</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bb2 = BoundingBox.ByGeometry(parent)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">if</span><span style="color: rgb(212, 212, 212);"> bb2.Contains(bb1.MinPoint) </span><span style="color: rgb(86, 156, 214);">and</span><span style="color: rgb(212, 212, 212);"> bb2.Contains(bb1.MaxPoint):</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent_list.Add(parent)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">return</span><span style="color: rgb(212, 212, 212);"> parent_list</span></div><div><br></div><div><span style="color: rgb(106, 153, 85);"># We have a list of lists as input</span></div><div><br></div><div><span style="color: rgb(197, 134, 192);">for</span><span style="color: rgb(212, 212, 212);"> boundaries </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);"> boundaries_list:</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; local_children = []</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; local_parents = []</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; local_others = []</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; temp_others = []</span></div><div><br></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># Sort each list based on the contained geometry's bounding box</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; boundaries.sort(</span><span style="color: rgb(156, 220, 254);">key</span><span style="color: rgb(212, 212, 212);">=getMin)</span></div><div><br></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># Go through the sorted list and find the parent(s) of each one</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># (as we've sorted the list, we should only need to check the</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># items that preceed the child, at least that's the theory)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">for</span><span style="color: rgb(212, 212, 212);"> i, boundary </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(220, 220, 170);">enumerate</span><span style="color: rgb(212, 212, 212);">(boundaries):</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parents = getParents(boundary, boundaries[</span><span style="color: rgb(181, 206, 168);">0</span><span style="color: rgb(212, 212, 212);">:i])</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># If we found a parent(s), add the child and its parent(s)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">if</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(220, 220, 170);">len</span><span style="color: rgb(212, 212, 212);">(parents) &gt; </span><span style="color: rgb(181, 206, 168);">0</span><span style="color: rgb(212, 212, 212);">:</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_children.Add(boundary)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_parents.Add(parents)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">else</span><span style="color: rgb(212, 212, 212);">:</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># Otherwise we add it to the others list</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp_others.Add(boundary)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># Flatten the list of parents to help filter the others list</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; flat_parents = [item </span><span style="color: rgb(197, 134, 192);">for</span><span style="color: rgb(212, 212, 212);"> sublist </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);"> local_parents </span><span style="color: rgb(197, 134, 192);">for</span><span style="color: rgb(212, 212, 212);"> item </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);"> sublist]</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># Select the items from the others list that aren't parents</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">for</span><span style="color: rgb(212, 212, 212);"> o </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);"> temp_others:</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">if</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(86, 156, 214);">not</span><span style="color: rgb(212, 212, 212);"> o </span><span style="color: rgb(86, 156, 214);">in</span><span style="color: rgb(212, 212, 212);"> flat_parents:</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_others.Add(o)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(106, 153, 85);"># For each iteration, add our results</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; children_out.Add(local_children)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; parents_out.Add(local_parents)</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; others_out.Add(local_others)</span></div><div><br></div><div><span style="color: rgb(106, 153, 85);"># Output the lists of lists</span></div><div><span style="color: rgb(212, 212, 212);">OUT = children_out, parents_out, others_out</span></div><div><br></div></div><p>You can probably take a guess at what I’m working on from the images I’ve included in today’s post. I’ll be posting more on this topic in the coming weeks, for sure.</p>

---
layout: "post"
title: "Breathing fresh life into LISP applications with a modern GUI"
date: "2006-07-31 16:41:30"
author: "Kean Walmsley"
categories:
  - "AutoCAD"
  - "AutoCAD .NET"
  - "AutoLISP / Visual LISP"
  - "User interface"
original_url: "https://www.keanw.com/2006/07/breathe_fresh_l.html "
typepad_basename: "breathe_fresh_l"
typepad_status: "Publish"
---

<p><a href="http://jtbworld.blogspot.com/2006/07/objectdcl-is-going-open-source.html">This recent entry</a> on Jimmy Bergmark's JTB World Blog brought to my attention the fact that ObjectDCL is about to become an Open Source project. Chad Wanless, the father of ObjectDCL, was a very active ADN member for many years, but - according to <a href="http://discussion.autodesk.com/thread.jspa?threadID=486856">this post</a> on the ObjectARX discussion group - is now unable to spend time working on ObjectDCL due to a severe medical condition. In case Chad is reading this... Chad - all of us here at ADN wish you a speedy recovery and all the best for your future endeavours.</p>

<p>Ignoring the background behind the decision to post the technology as Open Source, this is good news for developers with legacy codebases that include user interfaces implemented using DCL (Dialog Control Language).</p>

<p>I did want to talk a little about what other options are available to developers of LISP applications that make use of DCL today. There are a couple of approaches to calling modules implementing new user interfaces for LISP apps, whether through COM or through .NET. I'll talk about both, but I will say that .NET is the most future-proof choice at this stage.</p>

<p>Both techniques work on the principle that you redesign your user interface using VB6 or VB.NET/C#, and call through to these functions from LISP. Reality is often more complex - you may have more complex interactions from (for instance) particular buttons in your dialog - but these examples demonstrate what you can do to replace a fairly simple UI where you pass the initial variables into a function and receive the modified variables at the other end, once the user closes the dialog. You can also extend it to handle more complex situations, but there may be much more work needed - perhaps even use of AutoCAD's managed API from within the dialog code.</p>

<p><strong>COM: Using a VB ActiveX DLL from Visual LISP</strong></p>

<p>For an in-depth description of this technique, ADN members can find the information <a href="http://adn.autodesk.com/adn/servlet/devnote?siteID=4814862&amp;id=5408565&amp;linkID=4900509">here</a>. I apologise to those who are not able to access this content, but I don't want to dillute the issue by copying/pasting the whole article into this blog. Especially as this technique is describing the use of VB6, which is no longer at the forefront of Microsoft's development efforts.</p>

<p>The approach is to create an ActiveX DLL project in VB6, which is simply a COM module implementing code that can be referenced and called using a ProgID. AutoCAD's COM Automation interface exposes a method called GetInterfaceObject from the Application object that simply calls the equivalent of CreateObject on the ProgID passed in, but within AutoCAD's memory space. Once you've loaded a module using GetInterfaceObject, not only can you then call code displaying fancy VB-generated UIs from LISP, but because the code is in the same memory space as AutoCAD, it executes very quickly - on a par with VBA, ObjectARX or the managed API in terms of the speed with which it can access AutoCAD's object model.</p>

<p><strong>.NET: Defining LISP-callable functions from a .NET application</strong></p>

<p>The following technique is really the more future-proof approach, and has become possible since the implementation of &quot;LISP callable wrappers&quot; in AutoCAD 2007's managed API. Essentially it comes down to the ability to declare specific .NET functions as being LISP-callable. If you look back at <a href="http://through-the-interface.typepad.com/through_the_interface/2006/07/getting_started.html">one of my early posts</a> about creating a .NET application, you'll notice the use of an attribute to declare a command, such as &lt;CommandMethod(&quot;MyCommand&quot;)&gt;. With AutoCAD 2007 you can simply use &lt;LispFunction(&quot;MyLispFunction&quot;)&gt; to denote a function that can be called directly from LISP.</p>

<p>From there it's simply a matter of unpackaging the arguments passed in and packaging up the results (the bit in-between is where you get to have fun, using .NET capabilities to create beautiful user interfaces or to integrate with other systems etc., etc.). Here's some code to show the handling of arguments and packaging of the results:</p>

<p>&lt;LispFunction(<span style="color: #800000;">&quot;LISPfunction&quot;</span>)&gt; _<br /><span style="color: #0000ff;">Public</span> <span style="color: #0000ff;">Function</span> VBfunction(<span style="color: #0000ff;">ByVal</span> rbfArgs <span style="color: #0000ff;">As</span> ResultBuffer) <span style="color: #0000ff;">As</span> ResultBuffer<br /><br />&nbsp; &nbsp; <span style="color: #008000;">'Get the arguments passed in...</span><br />&nbsp; &nbsp; <span style="color: #0000ff;">Dim</span> arInputArgs <span style="color: #0000ff;">As</span> Array<br />&nbsp; &nbsp; <span style="color: #0000ff;">Dim</span> realArg1 <span style="color: #0000ff;">As</span> <span style="color: #0000ff;">Double</span><br />&nbsp; &nbsp; <span style="color: #0000ff;">Dim</span> intArg2 <span style="color: #0000ff;">As</span> <span style="color: #0000ff;">Integer</span><br />&nbsp; &nbsp; <span style="color: #0000ff;">Dim</span> strArg3 <span style="color: #0000ff;">As</span> <span style="color: #0000ff;">String</span><br />&nbsp; &nbsp; arInputArgs = rbfArgs.AsArray<br />&nbsp; &nbsp; realArg1 = <span style="color: #0000ff;">CType</span>(arInputArgs.GetValue(0), TypedValue).Value<br />&nbsp; &nbsp; intArg2 = <span style="color: #0000ff;">CType</span>(arInputArgs.GetValue(1), TypedValue).Value<br />&nbsp; &nbsp; strArg3 = <span style="color: #0000ff;">CType</span>(arInputArgs.GetValue(2), TypedValue).Value<br /><br />&nbsp; &nbsp; <span style="color: #008000;">'Do something interesting here...</span><br />&nbsp; &nbsp; <span style="color: #008000;">'...</span><br />&nbsp; &nbsp; <span style="color: #008000;">'...</span><br /><br />&nbsp; &nbsp; <span style="color: #008000;">'Package the results...</span><br />&nbsp; &nbsp; <span style="color: #008000;">'Use RTREAL (5001) for doubles</span><br />&nbsp; &nbsp; <span style="color: #008000;">'Use RTSTR (5003) for strings</span><br />&nbsp; &nbsp; <span style="color: #008000;">'Use RTSHORT (5005) for integers</span><br />&nbsp; &nbsp; <span style="color: #0000ff;">Dim</span> rbfResult <span style="color: #0000ff;">As</span> ResultBuffer<br />&nbsp; &nbsp; rbfResult = <span style="color: #0000ff;">New</span> ResultBuffer( _<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <span style="color: #0000ff;">New</span> TypedValue(<span style="color: #0000ff;">CInt</span>(5001), 3.14159), _<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <span style="color: #0000ff;">New</span> TypedValue(<span style="color: #0000ff;">CInt</span>(5003), 42), _<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <span style="color: #0000ff;">New</span> TypedValue(<span style="color: #0000ff;">CInt</span>(5005), <span style="color: #800000;">&quot;Goodbye!&quot;</span>))<br />&nbsp; &nbsp; <span style="color: #0000ff;">Return</span> rbfResult<br /><br /><span style="color: #0000ff;">End</span> <span style="color: #0000ff;">Function</span></p>

<p>The code assumes the first argument passed in will be a real, followed by an integer and then finally a string. Here's what happens if you call the code like this:</p><blockquote dir="ltr"><p>Command: (LISPfunction 1.234 9876 &quot;Hello!&quot;)<br />(3.14159 42 &quot;Goodbye!&quot;)</p></blockquote><p>Here are a couple of useful articles on the ADN site regarding this:</p><blockquote dir="ltr"><p><a href="http://adn.autodesk.com/adn/servlet/devnote?siteID=4814862&amp;id=7658042&amp;linkID=4900509">LispFunction examples for AutoLISP to .NET</a> <br /><a href="http://adn.autodesk.com/adn/servlet/devnote?siteID=4814862&amp;id=7184292&amp;linkID=4900509">.NET ResultBuffer returns dotted pairs to Visual LISP instead of normal list</a></p></blockquote>

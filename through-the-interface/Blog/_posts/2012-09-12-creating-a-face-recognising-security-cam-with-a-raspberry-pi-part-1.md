---
layout: "post"
title: "Creating a face-recognising security cam with a Raspberry Pi &ndash; Part 1"
date: "2012-09-12 07:45:26"
author: "Kean Walmsley"
categories:
  - "Raspberry Pi"
original_url: "https://www.keanw.com/2012/09/creating-a-face-recognising-security-cam-with-a-raspberry-pi-part-1.html "
typepad_basename: "creating-a-face-recognising-security-cam-with-a-raspberry-pi-part-1"
typepad_status: "Publish"
---

<p>This series of posts builds upon the mini-series on building a <a href="http://through-the-interface.typepad.com/through_the_interface/2012/08/creating-a-motion-detecting-security-cam-with-a-raspberry-pi-part-1.html" target="_blank">motion-detecting</a> <a href="http://through-the-interface.typepad.com/through_the_interface/2012/09/creating-a-motion-detecting-security-cam-with-a-raspberry-pi-part-2.html" target="_blank">security cam</a> based around the <a href="http://www.raspberrypi.org" target="_blank">Raspberry Pi</a>. Once you have your motion detecting security cam up and running, you should be able to move on to the next stage: enabling that system to recognize faces that it has been trained against.</p>  <p>My specific project (which I’m calling the Facecam, although I haven’t applied for a trademark ;-) pulls data down from <a href="http://www.facebook.com" target="_blank">Facebook</a> and uses that to train the face recognition system, but that’s far from being a requirement: it’s also very possible to train the database in other ways.</p>  <p>We’ll go into detail on the various parts over the coming weeks (probably once a week, as I want to continue blogging about other topics, too), but let’s start by introducing the project and the system architecture.</p>  <p>Here’s the elevator pitch: Facecam is a security camera that recognises a resident’s Facebook friends when they come to their front door and allows for tailored communication both to the resident and the visitor.</p>  <p>This would basically mean that instead of the resident receiving a notification email saying “You have a visitor” (as in the case of the motion-detection system we saw previously), the email would read “John Smith visited you”. And John could potentially receive a customized “we’re out” message while standing at the door and even a post on his Facebook wall thanking him for the visit.</p>  <p>A lot of this is clearly contingent on the accuracy of the facial recognition system – something we’ll look at much more closely later on. In case the accuracy isn’t adequate, it would be nice at least to provide some feedback to the visitor, saying “Welcome, John!” (even if it’s actually Megan at the door ;-).</p>  <p>Right, now let’s dive into the system architecture. Here’s a quick diagram of the Facecam system:</p>  <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2017d3bfcb797970c-pi" target="_blank"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 20px auto; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top: 0px; border-right: 0px; padding-top: 0px" title="Facecam system architecture" border="0" alt="Facecam system architecture" src="/assets/image_861866.jpg" width="470" height="262" /></a></p>  <p>Here’s a look at the new components (in addition to the “Motion detection” box we saw previously):</p>  <p><strong>1. A component to download information on the resident’s Facebook friends (.NET desktop application)</strong></p>  <p>This component will build a “friend” database (stored in a file named <em>facedata.xml</em>) to be used at runtime by the security cam. The database will be trained with the friends’ photos as downloaded from Facebook. So the component will need to access – for each friend – both their names and the photos in which they have been tagged (as well as the tag information, of course).</p>  <p>Using the tag information, the component will use <a href="http://opencv.org" target="_blank">OpenCV</a> to attempt to extract the friend’s face (by checking the list of detected faces against the tag location, to get the closest match), and – if it finds it – it will resize, crop and equalize the greyscale intensity of the image before saving it to disk for later use in the database training process.</p>  <p>This is ultimately an offline, CPU-intensive operation – we will simply need the database transferred across to the Raspberry Pi from time to time – so the approach we’ll take is to create a .NET desktop application that performs this task on a higher-powered device.</p>  <p><strong>2. A component to analyse frames saved by the motion-detection system, checking for friends (face recognition)</strong></p>  <p>This is the guts of the system: the runtime component that will again use OpenCV to process images captured from the webcam, detect faces and then check the results against the facial recognition database on the Raspberry Pi. This needs to be pretty efficient – as the feedback should be in close to real-time – which may be a challenge: given the relatively low power of the Raspberry Pi CPU, we’ll have to jump through some interesting hoops to get this working well enough.</p>  <p><strong>3. A component to provide feedback to the visitor (LED messaging)</strong></p>  <p>If we’re going to tell the visitor that they have been recognised (or in some way warn unwanted visitors that their photo has been sent to the property’s residents), then we’re going to need some kind of screen. The Raspberry Pi has both HDMI and component video outputs, but I’ve decided to go the way of <a href="http://www.dreamcheeky.com/led-message-board" target="_blank">a USB-powered LED message-board</a>. More on this in due course.</p>  <p>Right, that’s it for this introductory post. We’ll look in more detail at each of these components over the coming weeks, starting with the .NET desktop application to download friend information.</p>

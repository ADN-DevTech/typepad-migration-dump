---
layout: "post"
title: "Implementing a demo mode inside the Forge viewer &ndash; Part 1"
date: "2017-03-15 11:33:31"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Async"
  - "Autodesk Research"
  - "HTML"
  - "JavaScript"
original_url: "https://www.keanw.com/2017/03/implementing-a-demo-mode-inside-the-forge-viewer-part-1.html "
typepad_basename: "implementing-a-demo-mode-inside-the-forge-viewer-part-1"
typepad_status: "Publish"
---

<p>A request came up in a recent meeting talking about future features for <a href="http://dasher360.com" target="_blank">Dasher 360</a>. We want to be able to leave Dasher 360 running in “kiosk mode”, whereby if left unattended for some time it starts to run through some canned activities, showing off some of the tool’s capabilities. The mode should be interruptable: when the mouse moves the mode should stop, allowing the user to continue exploring on their own.</p> <p>This sounded like a really fun problem to tackle, so I started on it right away. My first avenue of research was around tools that already exist for capturing/playing back mouse activity in web-pages. The kind of thing you might use for automated testing, for instance.</p> <p>Very early on I realised that browsers don’t have this capability built-in: for lots of very good reasons you can’t control the mouse from within a web-page (e.g. via JavaScript). This is something we take for granted in the desktop world, but it’s just not available in the browser sandbox.</p> <p>That said, you can use an interesting (and slightly scary) technique called <a href="http://podlipensky.com/2012/08/cursor-spoofing-cursorjacking/" target="_blank">cursor spoofing or cursorjacking</a>. Which basically means you hide the cursor and display your own in its place (or rather in the place you want it). When used maliciously in web-sites this usually tracks relative to the existing cursor, tricking the user into clicking on things they shouldn’t. In our case we just want to move the cursor around and simulate using certain UI features.</p> <p>Some work is going to be needed from the features themselves to make them scriptable/clickable by a fake cursor. The goal is to implement this in a way that is:</p> <ol> <li>Easy to modify/extend to new features  <li>View-independent  <li>Not tied to a specific model<!--EndFragment-->  <li>Functional for any screen configuration/resolution</li></ol> <p>Which all means avoiding classic efforts to capture cursor movements/clicks and replay them back. We need to determine areas of interest based on 3D geometry as well as the UI that’s been added to the Forge viewer – ideally asking the various extensions to define the areas of interest and what happens when you hover over or click on them – and define some infrastructure to run the various operations in a loop.</p> <p>Sounds like fun, right? It did to me, too. :-)</p> <p>So, starting at the beginning, let’s look at some TypeScript code that spoofs the cursor – making the original invisible and displaying a fake one – and then scripts its movement from one place to another on the screen.</p> <p>Here’s how we hide the cursor – both for the Forge viewer’s canvas and for the UI elements we’ve added.</p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px"><span style="color: green">// We need to hide the cursors for both the canvas and the UI elements (toolbar buttons).</span></p> <p style="margin: 0px"><span style="color: green">// Store the values so that we can restore them at the end</span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px"><span style="color: blue">this</span>._savedCursor = <span style="color: blue">this</span>.viewer.canvas.style.cursor;</p> <p style="margin: 0px"><span style="color: blue">this</span>.viewer.canvas.style.cursor = <span style="color: #a31515">'none'</span>;</p> <p style="margin: 0px"><span style="color: blue">let</span> buttons = $(<span style="color: #a31515">'.adsk-button'</span>);</p> <p style="margin: 0px"><span style="color: blue">this</span>._buttonCursor = buttons[0].style.cursor;</p> <p style="margin: 0px">buttons.css(<span style="color: #a31515">'cursor'</span>, <span style="color: #a31515">'none'</span>);</p> <p style="margin: 0px">&nbsp;</p></div> <p>Here’s the code to dynamically create the cursor in the DOM; _cursorId and _cursorUrl are member variables that refer to what we’re calling our element and the image file representing the fake cursor.</p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px"><span style="color: blue">if</span> (!$(<span style="color: #a31515">'#'</span> + <span style="color: blue">this</span>._cursorId)[0]) {</p> <p style="margin: 0px">&nbsp; <span style="color: blue">let</span> $cursor = $(<span style="color: #a31515">'&lt;img src="'</span> + <span style="color: blue">this</span>._cursorUrl + <span style="color: #a31515">'" id="'</span> + <span style="color: blue">this</span>._cursorId + <span style="color: #a31515">'" /&gt;'</span>);</p> <p style="margin: 0px">&nbsp; $(<span style="color: #a31515">'body'</span>).append($cursor);</p> <p style="margin: 0px">}</p> <p style="margin: 0px">&nbsp;</p></div> <p>And here’s a function that moves the fake cursor from its current location (stored in _canvasX and _canvasY, which is set by a ‘mousemove’ handler) to a new location:</p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px">moveCursor(x: number, y: number, addHeader?: boolean): Promise&lt;any&gt; {</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp; <span style="color: blue">return</span> <span style="color: blue">new</span> Promise((resolve, reject) =&gt; {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">if</span> (<span style="color: blue">this</span>._inKioskMode) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">if</span> (addHeader) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = y + 51; <span style="color: green">// Our navigation header is 51 pixels high</span></p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> img = $(<span style="color: #a31515">'#'</span> + <span style="color: blue">this</span>._cursorId);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img.css(<span style="color: #a31515">'display'</span>, <span style="color: #a31515">'block'</span>);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img.css(<span style="color: #a31515">'position'</span>, <span style="color: #a31515">'absolute'</span>);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img.css(<span style="color: #a31515">'z-index'</span>, 9999);</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: green">// The Kiosk button is approximately 70% down the screen</span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> startX = <span style="color: blue">this</span>._canvasX || 25;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> startY = <span style="color: blue">this</span>._canvasY || window.innerHeight * 0.7;</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: green">// Base the number of steps on the distance to travel</span></p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: green">// (i.e. approximate a constant speed)</span></p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> xdiff = x - startX;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> ydiff = y - startY;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> steps = Math.floor(dist / 3);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> incX = xdiff / steps;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> incY = ydiff / steps;</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> pos = 0;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> id = setInterval(() =&gt; {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">if</span> (pos === steps) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearInterval(id);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resolve();</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span style="color: blue">else</span> {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos++;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> newX = startX + (pos * incX);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">let</span> newY = startY + (pos * incY);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img.css(<span style="color: #a31515">'left'</span>, newX + <span style="color: #a31515">'px'</span>);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; img.css(<span style="color: #a31515">'top'</span>, newY + <span style="color: #a31515">'px'</span>);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._canvasX = newX;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>._canvasY = newY;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }, 10);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp; });</p> <p style="margin: 0px">}</p> <p style="margin: 0px">&nbsp;</p></div> <p>You’ll notice that the code returns a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">Promise</a> – a piece of asynchronous code that can execute pseudo-synchronously – so that we can chain this operation together within a sequence.</p> <p>Let’s take a look at a sample piece of the sequence – here we get the screen location of a particular sensor (yes, hardcoded for testing purposes) in our model and then move the cursor to it.</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">Promise.resolve().then(() =&gt; {</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">&nbsp; <span style="color: blue">let</span> loc = <span style="color: blue">this</span>._dataModel.getSensorLocation(2338);</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">&nbsp; <span style="color: blue">let</span> pt = <span style="color: blue">this</span>.viewer.worldToClient(loc);</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">&nbsp; <span style="color: blue">this</span>.moveCursor(pt.x, pt.y, <span style="color: blue">true</span>);</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">}).then(() =&gt;</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">&nbsp; ...</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%">)</p> <p style="font-size: 8pt; font-family: courier new; background: white; color: black; margin: 0px; line-height: 140%" align="center">&nbsp;</p> <p>Here’s the code in action:</p> <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201bb0983c2e3970d-pi" target="_blank"><img title="Move cursor to sensor location" style="float: none; margin: 30px auto; display: block" alt="Move cursor to sensor location" src="/assets/image_423391.jpg" width="500" height="500"></a></p> <p>The beauty of this is this approach is that if we change the viewpoint it still moves the cursor to the same sensor. Which opens all kinds of possibilities.</p> <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201b7c8e08cde970b-pi" target="_blank"><img title="Move cursor to the same sensor in a different view" style="float: none; margin: 30px auto; display: block" alt="Move cursor to the same sensor in a different view" src="/assets/image_259167.jpg" width="500" height="500"></a></p>   <p>Pretty cool! In the next few posts we’ll see how we can take this further to create a full “kiosk mode” for an application based on the Forge viewer.</p>

---
layout: "post"
title: "Connecting Refinery to VR"
date: "2019-01-10 10:39:29"
author: "Kean Walmsley"
categories:
  - "Augmented Reality"
  - "Dynamo"
  - "Generative design"
  - "Geometry"
  - "JSON"
  - "Unity3D"
  - "Virtual Reality"
  - "Web/Tech"
original_url: "https://www.keanw.com/2019/01/connecting-refinery-to-vr.html "
typepad_basename: "connecting-refinery-to-vr"
typepad_status: "Publish"
---

<p>It’s time to talk about a little project I started over the holiday break: connecting <a href="https://www.keanw.com/2018/11/project-refinery-implement-generative-design-workflows-for-aec.html">Project Refinery</a> – the optimization engine for Dynamo that will help drive Generative Design workflows – to Virtual Reality. It’s a project I’ve been thinking about for some time, now, and was originally inspired by two things: the workflow <a href="https://www.vanwijnen.nl">Van Wijnen</a> uses Refinery for makes heavy use of VR for visualization – to evaluate designs with internal stakeholders – but right now they export the geometry from Dynamo to Revit and then use Enscape to visualize the scenes. It’s not a complicated process, but it takes a little time for each iteration.</p>
<p>The second inspiration came when I realised that Refinery had started capturing the 3D geometry for each solution, as you can see here in the Design Grid. Each of the below graphic thumbnails is actually a full 3D view you can zoom and rotate.</p>
<p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad3ad66a7200d-pi" rel="noopener" target="_blank"><img alt="3D thumbnails in Refinery&#39;s Design Grid" border="0" height="306" src="/assets/image_222528.jpg" style="margin: 30px auto; float: none; display: block; background-image: none;" title="3D thumbnails in Refinery&#39;s Design Grid" width="500" /></a></p>
<p>Digging around, I realised that the captured geometry was stored on the local file-system (currently under <em>%appdata%/Refinery/geometry</em>) in JSON format. This got me thinking… “what if I created a simple Unity scene that allowed you to load in the JSON for a particular view, and then display it in VR?”. So I started digging a little further, and then realised that the JSON format was actually a capture of mesh geometry for display via <a href="https://threejs.org" rel="noopener" target="_blank">Three.js</a>. This could, of course, be loaded into Unity and made sense of there, but why not just use <a href="https://webvr.info/" rel="noopener" target="_blank">WebVR</a> (or <a href="https://github.com/immersive-web/webxr" rel="noopener" target="_blank">WebXR</a>, the newer AR- and MR-capable version) – which is already Three.js-integrated – to display it on a variety of devices?</p>
<p>So it was that in the New Year I got started building a system to connect Refinery to VR via WebVR. I started by taking the content of one of the JSON files and building a web-page around it: there was a little work needed to take some logic from the 3D viewer built into Refinery to deserialize the JSON data into Three.js objects. But I managed to get a working view of a single solution.</p>
<p>The next step was to serve this JSON data up so that it could be controlled centrally (from the person running Refinery and browsing the results). For a while I went down a rabbithole of spinning up a local web-server on the system running Refinery – the JSON files were stored on the local file-system, so why not use Mongoose or Python to server up the JSON files, right? This worked, but once I started trying to work out how to map the ID used by Refinery for each solution to the JSON file on disk, I realised I could just use the Refinery server directly: there’s a simple REST endpoint that allows you to query the geometry for a specific ID (this is currently hosted on the local system running Refinery at <a href="http://localhost:8000/o2/v1/geometry/{id"><em>http://localhost:8000/o2/v1/geometry/{id</em></a><em>}</em>, although at some point it will end up somewhere in the cloud). Perfect!</p>
<p>This also simplified the communication of the geometry data to the various connected client web-pages: rather than loading the geometry and pushing it out to the various clients via WebSockets or WebRTC (which would either take some server infrastructure or some investment in making all the peer-to-peer plumbing work), I could just publish the ID of a particular result – which is basically a GUID – to a public location for the clients to query. When the clients receive a new ID (something they poll for), they can then query the Refinery server directly to get the geometry for that ID.</p>
<p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad3ccfb3c200b-pi" rel="noopener" target="_blank"><img alt="Architecture diagram" border="0" height="341" src="/assets/image_487001.jpg" style="margin: 30px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;" title="Architecture diagram" width="500" /></a></p>
<p>This is actually quite elegant, privacy-wise: there’s absolutely nothing of interest about the ID itself – so it can be placed anywhere on the web – it’s the geometry associated with the ID that’s potentially sensitive, and the clients access this locally from the Refinery server: if they’re not able to access the server on their local network, they won’t get the data.</p>
<p>I ended up using <a href="http://httprelay.io">http://httprelay.io</a> to store the IDs centrally: you can generate a new channel for each “customer” of the system, which is OK for testing/research purposes. I hacked the Refinery client to push the ID for a particular result to this service when it was double-clicked in the UI, and then the various client pages pull it down from there and then query the geometry directly from the Refinery server. As each page is polling for an update to the key, they’ll be able to update their geometry whenever a new one gets pushed: much in the same way as <a href="http://vrok.it" rel="noopener" target="_blank">Vrok-It</a> allows you to have multiple clients visualizing a common model via Forge (with a presenter managing the session and choosing which models to load and what operations to perform on them).</p>
<p>For now I’ve tested the solution with simple non-VR web-clients – it works fine on both desktop and mobile browsers – as well as mobile VR clients (Google Cardboard and Gear VR) and tethered VR clients (HTC Vive). I built in some rudimentary teleportation into the page, which is handy for exploring the model.</p>
<p>A huge thanks to Damon Hernandez from Samsung Research – who many of you will know as one of the founders of the AEC Hackathons – for giving me his personal Gear VR at Berlin’s AEC Hackathon: it’s largely thanks to this that I was able to make this project work well for mobile VR (with the very neat Gear VR controller). It’s really cool to be able to test the page on a browser on my PC, then on a Gear VR (still at my desk) before going down to my basement and loading the same page inside Firefox connected to the HTC Vive. All of which get updated with fresh geometry when a new solution is selected inside Refinery.</p>
<p class="p1">Here’s the loading view on the Gear VR: you can see how the page queries the IP or hostname for the system running Refinery, as it needs this to connect to the geometry service. The screen recording doesn’t follow into WebVR mode, though, so I’ve captured some via the HTC Vive for the other features.</p>
<p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad387580d200c-pi" rel="noopener" target="_blank"><img alt="Gear VR" height="292" src="/assets/image_32415.jpg" style="margin: 30px auto; float: none; display: block;" title="Gear VR" width="500" /></a></p>
<p>Here you can see the visualization of a residential layout, with the two Vive controllers represented.</p>
<p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad3ad66ba200d-pi" rel="noopener" target="_blank"><img alt="WebVR for Refinery" height="300" src="/assets/image_168091.jpg" style="margin: 30px auto; float: none; display: block;" title="WebVR for Refinery" width="500" /></a></p>
<p>If you pull the trigger on a controller it teleports to the location (or the ground location beneath it) that you point at…</p>
<p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad3ad66be200d-pi" rel="noopener" target="_blank"><img alt="Teleportation" height="300" src="/assets/image_448431.jpg" style="margin: 30px auto; float: none; display: block;" title="Teleportation" width="500" /></a></p>
<p>Unless you happen to point at the sky, at which point it toggles between day and night.</p>
<p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2022ad3ad66c5200d-pi" rel="noopener" target="_blank"><img alt="WebVR by night" height="300" src="/assets/image_768954.jpg" style="margin: 30px auto; float: none; display: block;" title="WebVR by night" width="500" /></a></p>
<p>What’s even more compelling about this approach is that it’s just a matter of time before WebXR (which I’ve also built a version for, even if it’s not quite ready for primetime) enables the display of these models in Mixed and Augmented Reality views: at some point it should be possible to use phone-based AR – with a “magic window” visualization approach – or proper MR via devices such as HoloLens – to integrate the 3D geometry into a more collaborative, shared experience.</p>
<p>Next steps for the project are to include some UI elements to display the goal scores for that particular result, along with some controls that would allow navigation between results (assuming you don’t want to have someone outside the VR experience managing it for you). It’ll be interesting to see how it goes!</p>

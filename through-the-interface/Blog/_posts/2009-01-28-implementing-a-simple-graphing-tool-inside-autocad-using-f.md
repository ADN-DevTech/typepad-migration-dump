---
layout: "post"
title: "Implementing a simple graphing tool inside AutoCAD using F#"
date: "2009-01-28 19:33:12"
author: "Kean Walmsley"
categories:
  - "AutoCAD"
  - "AutoCAD .NET"
  - "Concurrent programming"
  - "F#"
original_url: "https://www.keanw.com/2009/01/implementing-a-simple-graphing-tool-inside-autocad-using-f.html "
typepad_basename: "implementing-a-simple-graphing-tool-inside-autocad-using-f"
typepad_status: "Publish"
---

<p>Well, I couldn&#39;t resist... as I mentioned in <a href="http://through-the-interface.typepad.com/through_the_interface/2009/01/nesting-instincts-getting-more-out-of-transactions-inside-autocad-using-net.html">the last post</a> - where we looked at creating a simple graph inside AutoCAD as an example of modifying objects inside nested transactions - the idea of graphing inside AutoCAD is a good fit for F#. This is for a number of reasons: F# is very mathematical in nature and excels at processing lists of data. I also spiced it up a bit by adding some code to parallelise some of the mathematical operations, but that didn&#39;t turn out to be especially compelling with my dual-core laptop. More on that later.</p> <p>Here&#39;s the F# code:</p> <div style="font-size: 8pt; background: white; color: black; font-family: courier new"> <p style="margin: 0px"><span style="color: green">// Use lightweight F# syntax</span></p><br /> <p style="margin: 0px"><span style="color: blue">#light</span></p><br /> <p style="margin: 0px"><span style="color: green">// Declare a specific namespace and module name</span></p><br /> <p style="margin: 0px"><span style="color: blue">module</span> Grapher.Commands</p><br /> <p style="margin: 0px"><span style="color: green">// Import managed assemblies</span></p><br /> <p style="margin: 0px"><span style="color: blue">open</span> Autodesk.AutoCAD.Runtime</p> <p style="margin: 0px"><span style="color: blue">open</span> Autodesk.AutoCAD.ApplicationServices</p> <p style="margin: 0px"><span style="color: blue">open</span> Autodesk.AutoCAD.DatabaseServices</p> <p style="margin: 0px"><span style="color: blue">open</span> Autodesk.AutoCAD.Geometry</p><br /> <p style="margin: 0px"><span style="color: green">// Define a common normalization function which makes sure</span></p> <p style="margin: 0px"><span style="color: green">// our graph gets mapped to our grid</span></p><br /> <p style="margin: 0px"><span style="color: blue">let</span> normalize fn normFn x minInp maxInp maxOut =</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> res =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; fn ((maxInp - minInp) * x / maxOut)</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> normRes = normFn res</p> <p style="margin: 0px">&#0160; <span style="color: blue">if</span> normRes &gt;= 0.0 &amp;&amp; normRes &lt;= 1.0 <span style="color: blue">then</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160; normRes * (maxOut - 1.0)</p> <p style="margin: 0px">&#0160; <span style="color: blue">else</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160; -1.0</p><br /> <p style="margin: 0px"><span style="color: green">// Define some shortcuts to the .NET Math library</span></p> <p style="margin: 0px"><span style="color: green">// trigonometry functions</span></p><br /> <p style="margin: 0px"><span style="color: blue">let</span> sin x = System.Math.Sin x</p> <p style="margin: 0px"><span style="color: blue">let</span> cos x = System.Math.Cos x&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; </p> <p style="margin: 0px"><span style="color: blue">let</span> tan x = System.Math.Tan x&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; </p><br /> <p style="margin: 0px"><span style="color: green">// Implement our own normalized trig functions</span></p> <p style="margin: 0px"><span style="color: green">// which each map to the size of the grid passed in</span></p><br /> <p style="margin: 0px"><span style="color: blue">let</span> normSin max x =</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> nf a = (a + 1.0) / 2.0 <span style="color: green">// Normalise to 0-1</span></p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> res =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; normalize</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; sin nf (Int32.to_float x)</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; 0.0 (2.0 * System.Math.PI) (Int32.to_float max)</p> <p style="margin: 0px">&#0160; Int32.of_float res</p><br /> <p style="margin: 0px"><span style="color: blue">let</span> normCos max x =</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> nf a = (a + 1.0) / 2.0 <span style="color: green">// Normalise to 0-1</span></p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> res =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; normalize</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; cos nf (Int32.to_float x)</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; 0.0 (2.0 * System.Math.PI) (Int32.to_float max)</p> <p style="margin: 0px">&#0160; Int32.of_float res</p><br /> <p style="margin: 0px"><span style="color: blue">let</span> normTan max x =</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> nf a = (a + 3.0) / 6.0 <span style="color: green">// Normalise differently for tan</span></p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> res =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; normalize</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; tan nf (Int32.to_float x)</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; 0.0 (2.0 * System.Math.PI) (Int32.to_float max)</p> <p style="margin: 0px">&#0160; Int32.of_float res</p><br /> <p style="margin: 0px"><span style="color: green">// Now we declare our command</span></p><br /> <p style="margin: 0px">[&lt;CommandMethod(<span style="color: maroon">&quot;graph&quot;</span>)&gt;]</p> <p style="margin: 0px"><span style="color: blue">let</span> gridCommand() =</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// We&#39;ll time the command, so we can check the</span></p> <p style="margin: 0px">&#0160; <span style="color: green">// sync vs. async efficiency</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> starttime = System.DateTime.Now</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Let&#39;s get the usual helpful AutoCAD objects</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> doc =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; Application.DocumentManager.MdiActiveDocument</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> ed = doc.Editor</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> db = doc.Database</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// &quot;use&quot; has the same effect as &quot;using&quot; in C#</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">use</span> tr =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; db.TransactionManager.StartTransaction()</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Get appropriately-typed BlockTable and BTRs</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> bt =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; tr.GetObject</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; (db.BlockTableId,OpenMode.ForRead)</p> <p style="margin: 0px">&#0160;&#0160;&#0160; :?&gt; BlockTable</p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> ms =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; tr.GetObject</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; (bt.[BlockTableRecord.ModelSpace],</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; OpenMode.ForWrite)</p> <p style="margin: 0px">&#0160;&#0160;&#0160; :?&gt; BlockTableRecord</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Function to create a filled circle (hatch) at a</span></p> <p style="margin: 0px">&#0160; <span style="color: green">// specific location</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Note the valid use of tr and ms, as they are in scope</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> createCircle pt rad =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> hat = <span style="color: blue">new</span> Hatch()</p> <p style="margin: 0px">&#0160;&#0160;&#0160; hat.SetDatabaseDefaults();</p> <p style="margin: 0px">&#0160;&#0160;&#0160; hat.SetHatchPattern</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; (HatchPatternType.PreDefined,</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: maroon">&quot;SOLID&quot;</span>)</p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> id = ms.AppendEntity(hat)</p> <p style="margin: 0px">&#0160;&#0160;&#0160; tr.AddNewlyCreatedDBObject(hat, <span style="color: blue">true</span>)</p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: green">// Now we create the loop, which we make db-resident</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: green">// (appending a transient loop caused problems, so</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: green">// we&#39;re going to use the circle and then erase it)</span></p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> cir = <span style="color: blue">new</span> Circle()</p> <p style="margin: 0px">&#0160;&#0160;&#0160; cir.Radius &lt;- rad</p> <p style="margin: 0px">&#0160;&#0160;&#0160; cir.Center &lt;- pt</p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> lid = ms.AppendEntity(cir)</p> <p style="margin: 0px">&#0160;&#0160;&#0160; tr.AddNewlyCreatedDBObject(cir, <span style="color: blue">true</span>)</p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: green">// Have the hatch use the loop we created</span></p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> loops = <span style="color: blue">new</span> ObjectIdCollection()</p> <p style="margin: 0px">&#0160;&#0160;&#0160; loops.Add(lid) |&gt; ignore</p> <p style="margin: 0px">&#0160;&#0160;&#0160; hat.AppendLoop(HatchLoopTypes.Default, loops)</p> <p style="margin: 0px">&#0160;&#0160;&#0160; hat.EvaluateHatch(<span style="color: blue">true</span>)</p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: green">// Now we erase the loop</span></p><br /> <p style="margin: 0px">&#0160;&#0160;&#0160; cir.Erase()</p> <p style="margin: 0px">&#0160;&#0160;&#0160; id</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Function to create our grid of circles</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> createGrid size rad offset =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> ids = <span style="color: blue">new</span> ObjectIdCollection()</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">for</span> i = 0 <span style="color: blue">to</span> size - 1 <span style="color: blue">do</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: blue">for</span> j = 0 <span style="color: blue">to</span> size - 1 <span style="color: blue">do</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: blue">let</span> pt =</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: blue">new</span> Point3d</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; (offset * (Int32.to_float i),</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; offset * (Int32.to_float j),</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; 0.0)</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: blue">let</span> id = createCircle pt rad</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; ids.Add(id) |&gt; ignore</p> <p style="margin: 0px">&#0160;&#0160;&#0160; ids</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Function to change the colour of an entity</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> changeColour col (id : ObjectId) =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">if</span> id.IsValid <span style="color: blue">then</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: blue">let</span> ent =</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; tr.GetObject(id, OpenMode.ForWrite) :?&gt; Entity</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; ent.ColorIndex &lt;- col</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Shortcuts to make objects red and yellow</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> makeRed = changeColour 1</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> makeYellow = changeColour 2</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Function to retrieve the contents of our</span></p> <p style="margin: 0px">&#0160; <span style="color: green">// array of object IDs - this just calculates</span></p> <p style="margin: 0px">&#0160; <span style="color: green">// the index based on the x &amp; y values</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> getIndex fn size i =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">let</span> res = fn size i</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">if</span> res &gt;= 0 <span style="color: blue">then</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; (i * size) + res</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">else</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; -1</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Apply our function synchronously for each value of x</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> applySyncBelowMax size fn =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; [| <span style="color: blue">for</span> i <span style="color: blue">in</span> [0..size-1] <span style="color: blue">-&gt;</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; getIndex fn size i |]</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Apply our function asynchronously for each value of x</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> applyAsyncBelowMax size fn =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; Async.Run</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; (Async.Parallel</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; [ <span style="color: blue">for</span> i <span style="color: blue">in</span> [0..size-1] <span style="color: blue">-&gt;</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; async { <span style="color: blue">return</span> getIndex fn size i } ]) </p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Hardcode the size of the grid and create it</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> size = 50</p> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> ids = createGrid size 0.5 1.2</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Make the circles all red to start with</span></p><br /> <p style="margin: 0px">&#0160; Seq.iter makeRed (Seq.cast ids)</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// From a certain index in the list, get an object ID</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> getId i =</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">if</span> i &gt;= 0 <span style="color: blue">then</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; ids.[i]</p> <p style="margin: 0px">&#0160;&#0160;&#0160; <span style="color: blue">else</span></p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; ObjectId.Null</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Apply one of our trig functions, synchronously or</span></p> <p style="margin: 0px">&#0160; <span style="color: green">// otherwise, to our grid</span></p><br /> <p style="margin: 0px">&#0160; applySyncBelowMax size normSin |&gt;</p> <p style="margin: 0px">&#0160;&#0160;&#0160; Array.map getId |&gt;</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; Array.iter makeYellow</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Commit the transaction</span></p><br /> <p style="margin: 0px">&#0160; tr.Commit()</p><br /> <p style="margin: 0px">&#0160; <span style="color: green">// Check how long it took</span></p><br /> <p style="margin: 0px">&#0160; <span style="color: blue">let</span> elapsed =</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160; System.DateTime.op_Subtraction</p> <p style="margin: 0px">&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; (System.DateTime.Now, starttime)</p><br /> <p style="margin: 0px">&#0160; ed.WriteMessage</p> <p style="margin: 0px">&#0160;&#0160;&#0160; (<span style="color: maroon">&quot;\nElapsed time: &quot;</span> +</p> <p style="margin: 0px">&#0160;&#0160;&#0160; elapsed.ToString())</p></div> <p>&#0160;</p> <p>Here&#39;s what you see on AutoCAD&#39;s drawing canvas when you run the GRAPH command as it stands:</p> <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2010536fe5f53970c-pi"><img alt="Sine from F#" border="0" height="398" src="/assets/image_225737.jpg" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" width="398" /></a> </p> <p>If you want to play around with other functions, you can edit the call to applySyncBelowMax to pass normCos or normTan instead of normSin.</p> <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2010536f530df970b-pi"><img alt="Cosine from F#" border="0" height="396" src="/assets/image_275951.jpg" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" width="396" /></a> </p> <p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e2010536fe5fe9970c-pi"><img alt="Tangent from F#" border="0" height="395" src="/assets/image_615327.jpg" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" width="395" /></a> </p> <p>&#0160;</p> <p>As I mentioned earlier, if you swap the call to be applyAsyncBelowMax instead of applySyncBelowMax you will actually run the mathematics piece as asynchronous tasks. These are CPU-bound operations - they don&#39;t call across the network or write to a hard-drive, which might have increased the benefit of calling them asynchronously - so right now the async version actually runs more slowly than the sync version. If I were to have more processing cores available to me, it might also give us more benefit, but right now with my dual-core machine there&#39;s more effort spent coordinating the tasks than you gain from the parallelism. But I&#39;ll let you play around with that yourselves... you may get better results. One other note on that piece of the code: at some point I&#39;d like to make use of the Parallel Extensions for .NET (in particular the Task Parallel Library (TPL)), but for now I&#39;ve continued with what I know, the asynchronous worklows capability which is now standard in F#.</p> <p>I&#39;m travelling in India this week (and working from our Bangalore office next week), so this is likely to be my last post of the week.</p>

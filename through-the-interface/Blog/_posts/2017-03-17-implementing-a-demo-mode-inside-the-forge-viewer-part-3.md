---
layout: "post"
title: "Implementing a demo mode inside the Forge viewer &ndash; Part 3"
date: "2017-03-17 15:07:14"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Async"
  - "Autodesk Research"
  - "HTML"
  - "JavaScript"
  - "User interface"
original_url: "https://www.keanw.com/2017/03/implementing-a-demo-mode-inside-the-forge-viewer-part-3.html "
typepad_basename: "implementing-a-demo-mode-inside-the-forge-viewer-part-3"
typepad_status: "Publish"
---

<p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201bb09849417970d-pi" target="_blank"><img title="Another shot of Dasher 360 in kiosk mode" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin: 30px auto; border-left: 0px; display: block; padding-right: 0px" border="0" alt="Another shot of Dasher 360 in kiosk mode" src="/assets/image_292599.jpg" width="500" height="312"></a>In this final (for now, anyway) part of <a href="http://through-the-interface.typepad.com/through_the_interface/2017/03/implementing-a-demo-mode-inside-the-forge-viewer-part-1.html" target="_blank">the</a> <a href="http://through-the-interface.typepad.com/through_the_interface/2017/03/implementing-a-demo-mode-inside-the-forge-viewer-part-2.html" target="_blank">series</a>, we’re going to look at the approach taken in the Dasher 360 kiosk mode to loop the demo indefinitely (although with variations, as mentioned last time) until someone interrupts by moving the mouse.</p> <p>The first piece of this is to track the mouse. We do this by attaching an event handler to ‘mousemove’. Here’s the TypeScript code we’re using:</p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px">onMouseMove = (event: any): <span style="color: blue">void</span> =&gt; {</p> <p style="margin: 0px">&nbsp; <span style="color: blue">this</span>._canvasX = event.canvasX || event.clientX;</p> <p style="margin: 0px">&nbsp; <span style="color: blue">this</span>._canvasY = event.canvasY || event.clientY;</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp; <span style="color: blue">if</span> (<span style="color: blue">this</span>._startX !== <span style="color: blue">null</span> &amp;&amp; <span style="color: blue">this</span>._startY !== <span style="color: blue">null</span> &amp;&amp; <span style="color: blue">this</span>._inKioskMode &amp;&amp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp; (Math.abs(<span style="color: blue">this</span>._canvasX - <span style="color: blue">this</span>._startX) &gt; <span style="color: blue">this</span>._moveThreshold ||</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.abs(<span style="color: blue">this</span>._canvasY - <span style="color: blue">this</span>._startY) &gt; <span style="color: blue">this</span>._moveThreshold)) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">this</span>.endDemo();</p> <p style="margin: 0px">&nbsp; }</p> <p style="margin: 0px">}</p> <p style="margin: 0px">&nbsp;</p></div> <p>You’ll notice we do a little legwork before calling endDemo() (which resets state and sets a flag we check for in the main demo code). This was primarily because a colleague of mine has a very sensitive mouse – which apparently sits on an incline – and so the demo wouldn’t run for long before being interrupted. In fairness, it seemed reasonable to allow for mouse movement below a certain threshold distance to occur without cancelling the demo, so it was good he raised this early on. :-)</p> <p>In terms of looping the demo, it took me a while to get there, but the following TypeScript code works well.</p> <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%"> <p style="margin: 0px"><span style="color: blue">let</span> loopDemo = (): Promise&lt;any&gt; =&gt; {</p> <p style="margin: 0px">&nbsp; <span style="color: blue">if</span> (<span style="color: blue">this</span>._inKioskMode) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> <span style="color: blue">this</span>.performDemo().then(loopDemo);</p> <p style="margin: 0px">&nbsp; }</p> <p style="margin: 0px">};</p> <p style="margin: 0px">Promise.resolve().then(loopDemo).catch((error) =&gt;</p> <p style="margin: 0px">&nbsp; console.log(<span style="color: #a31515">'Error: '</span> + error)</p> <p style="margin: 0px">);</p> <p style="margin: 0px">&nbsp;</p></div> <p>It checks the flag that gets set by the endDemo() method, of course, but basically performs a recursive – potentially infinite – loop in a way that works with Promises. I’ve used Array.reduce() to good effect with iterative Promise calls, but that depends on a finite number of enumerable iterations (at least as far as I can tell). The above code works if you just want to keep on going until a certain condition is met.</p> <p>That’s it for this quick wrap-up of the series. We’re planning on pushing this version of <a href="http://dasher360.com" target="_blank">Dasher 360</a> to production in the coming week or so, so you’ll be able to a) try it for yourself and b) inspect the complete code from the live site.</p>

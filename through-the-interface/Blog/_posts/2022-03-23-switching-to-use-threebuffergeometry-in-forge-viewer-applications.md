---
layout: "post"
title: "Switching to use THREE.BufferGeometry in Forge viewer applications"
date: "2022-03-23 19:08:37"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Autodesk Research"
  - "IoT"
  - "Robotics"
original_url: "https://www.keanw.com/2022/03/switching-to-use-threebuffergeometry-in-forge-viewer-applications.html "
typepad_basename: "switching-to-use-threebuffergeometry-in-forge-viewer-applications"
typepad_status: "Publish"
---

<p>I talked some time ago about some work that has been needed to be done in <a href="https://dasher360.com" target="_blank">Project Dasher</a> – and other Forge viewer clients – in <a href="https://www.keanw.com/2021/11/getting-ready-for-tandem-a-call-to-action-for-forge-developers.html" target="_blank">anticipation of supporting viewers such as Tandem’s</a>. In this case it was fairly specifically about the need to support loading of multiple models inside the viewer, rather than working on the assumption that there’s a single model available.</p><p>For the last few days I’ve been looking at another area that by all accounts will be beneficial, whether driven by use of the Tandem viewer or the upcoming Forge viewer based on the latest Three.js version: I’ve gone through the codebase and replaced all use of THREE.Geometry with <a href="https://threejs.org/docs/#api/en/core/BufferGeometry" target="_blank">THREE.BufferGeometry</a>. This has been motivated by <a href="https://discourse.threejs.org/t/three-geometry-will-be-removed-from-core-with-r125/22401" target="_blank">the decision to completely drop support for the old THREE.Geometry implementation in Three.js</a>. At some point (and possibly quite soon) it’ll be important to have done this work in Forge viewer applications using THREE.Geometry.</p><p>The work needed to start using THREE.BufferGeometry is reasonably straightforward: <a href="https://sbcode.net/threejs/geometry-to-buffergeometry/" target="_blank">I found this guide to be quite useful</a>. In general you need to collect your points, normals, etc. in arrays before using them to populate the BufferGeometry state. I’ve tended to use the handy setFromPoints() helper method for this, but have also used the lower-level setAttribute() method on occasion (for the latter you need a flat array of the point/normal/etc. coordinate values).</p><p>Inside Dasher I needed to migrate the following sub-components to use THREE.BufferGeometry:</p><ul><li><a href="https://github.com/elifer5000/THREE.MeshLine/blob/work-with-r71/src/THREE.MeshLine.js" target="_blank">THREE.MeshLine</a></li><ul><li>This is used by a number of the following features.</li><li>I chose to migrate the existing r71-supporting code rather than use a newer version.</li></ul><li><a href="https://threejs.org/docs/#api/en/helpers/ArrowHelper" target="_blank">THREE.ArrowHelper</a></li><ul><li>We use this to display anemometer values, something I haven’t yet blogged about here.</li></ul><li><a href="https://www.keanw.com/2018/09/displaying-streamlines-in-the-forge-viewer.html" target="_blank">Streamlines</a></li><ul><li>This is our own version of the code that’s <a href="https://www.keanw.com/2021/10/streamlines-in-the-forge-viewer.html" target="_blank">now built into the Forge viewer</a>, so not strictly needed.</li><li>Based on MeshLine.</li></ul><li><a href="https://www.keanw.com/2018/09/displaying-skeletons-in-the-forge-viewer-part-3.html" target="_blank">Skeletons</a></li><ul><li>Based on MeshLine.</li></ul><li><a href="https://www.keanw.com/2018/09/animating-robots-in-the-forge-viewer.html" target="_blank">Robots</a></li><ul><li>Also needed work on the Collada loader.</li></ul></ul><p>Pretty much everything looks the same as it did, with the exception of robots. As you may remember, I made the decision to go with wireframe display of robots inside the Forge viewer, mainly because the rendering of materials didn’t work well with depthTest set to true. An unfortunate compromise, but not a huge issue.<br>This time around, though, I found that for the life of me I couldn’t get wireframe mode to work properly. In the end – out of sheer desperation – I switched to realistic (Phong) shading and set depthTest to true… and the results were stunning!</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e202788072742b200d-pi"><img width="500" height="263" title="Robot occluded by the bridge" style="margin: 30px auto; float: none; display: block;" alt="Robot occluded by the bridge" src="/assets/image_723496.jpg"></a></p><p>When animating I found I did have to call viewer.refresh(true) after modifying the robot’s geometry, but it still all worked with very decent performanvce.</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e202942fa0373a200c-pi"><img width="500" height="265" title="Spinning robot" style="margin: 30px auto; float: none; display: block;" alt="Spinning robot" src="/assets/image_338560.jpg"></a></p><p>It’s hard to know what has contributed to this now working: it could be performance improvements in the viewer, the use of THREE.BufferGeometry, or perhaps me making a silly mistake the last time around. Or all of the above. Whichever way I’m very happy with these results.</p><p>Next I’d like to find a way to detect when the robot is about to hit its surroundings – in this case the MX3D bridge – but it’s not at all sure that this is something that can be done without degrading performance significantly. We’ll see.</p>

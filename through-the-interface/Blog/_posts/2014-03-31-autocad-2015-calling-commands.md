---
layout: "post"
title: "AutoCAD 2015: calling commands"
date: "2014-03-31 15:34:32"
author: "Kean Walmsley"
categories:
  - "AutoCAD"
  - "AutoCAD .NET"
  - "AutoLISP / Visual LISP"
  - "Commands"
  - "Documents"
  - "ObjectARX"
  - "Runtime"
  - "Visual Basic &amp; VBA"
original_url: "https://www.keanw.com/2014/03/autocad-2015-calling-commands.html "
typepad_basename: "autocad-2015-calling-commands"
typepad_status: "Publish"
---

<p><a href="http://through-the-interface.typepad.com/.a/6a00d83452464869e201a511931fe0970c-pi" target="_blank"><img title="Execute" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin: 20px auto; display: block; padding-right: 0px; border-top-width: 0px" border="0" alt="Execute" src="/assets/image_105786.jpg" width="394" height="264" /></a></p>  <p align="right"><font color="#666666">photo credit: </font><a href="http://www.flickr.com/photos/mwichary/3300657149/"><font color="#666666">Marcin Wichary</font></a><font color="#666666"> via </font><a href="http://photopin.com"><font color="#666666">photopin</font></a><font color="#666666"> </font><a href="http://creativecommons.org/licenses/by/2.0/"><font color="#666666">cc</font></a></p>  <p>As mentioned in <a href="http://through-the-interface.typepad.com/through_the_interface/2014/03/autocad-2015-for-developers.html" target="_blank">the last post</a>, fibers are now inactive in AutoCAD 2015 (the code paths are still there, largely for testing purposes, but should not need to be enabled for typical usage of the product).</p>  <p>Fibers were a technology that Microsoft introduced way back when to help single document (and typically single-threaded) applications adapt more easily to the brave new world of <a href="http://en.wikipedia.org/wiki/Multiple_document_interface" target="_blank">MDI</a>. At least that’s my recollection and understanding. They were basically a mechanism by which applications such as AutoCAD could manage their per-document state, making the relevant data current depending on the activated document. I’ve heard fibers referred to as “manually-scheduled threads”, although that’s likely to be a simplification of <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx" target="_blank">the real situation</a>.</p>  <p>So what does this mean to AutoCAD developers, and why do we care?</p>  <p>Aside from making debugging more predictable – Visual Studio hasn’t allowed debugging of applications using fibers for a few releases – this work has brought significant benefits for developers.</p>  <p>The way I understand it – and it’s very likely that my understanding is either incomplete or flawed, as I haven’t spent a significant amount of time looking at the guts of this mechanism – AutoCAD commands depend on state associated with the current document. Moving away from fibers means the execution context of AutoCAD commands is quite different, but it also brings about opportunities that weren’t there before, as we’ve rationalized the way commands can be called, making them first-class, fully supported ways of making use of the huge amount of pre-existing code inside AutoCAD. Which essentially means AutoCAD developers should no longer feel bad (if they ever did ;-) about calling commands from their code. It’s now absolutely valid to do this – it’s just as valid to call commands as it is to make use of a lower-level API.</p>  <p>Prior to AutoCAD 2015, you would generally call AutoCAD commands by firing tokens – command names and the user inputs those commands expected – into AutoCAD’s input throat. From AutoCAD 2015 onwards, there are two approaches for calling commands: <strong>subroutine</strong> and <strong>coroutine</strong>. <a href="http://en.wikipedia.org/wiki/Subroutine" target="_blank">Subroutine</a> command-calling means that you want to execute a command in its entirety: you know exactly how the command should be called and don’t want things to be open-ended. <a href="http://en.wikipedia.org/wiki/Coroutine" target="_blank">Coroutine</a> command-calling is more open-ended: you don’t have all the arguments to provide to the command – and don’t know exactly how it’s going to proceed – so you’re really calling a partial command.</p>  <p>Without fibers acting as a support structure, these two styles of command-calling now need to be handled separately.</p>  <p>In <strong>ObjectARX</strong>, for instance, you’ll no longer find acedCommand() or acedCmd(), you have to use either acedCommandS()/acedCmdS() or acedCommandC()/acedCmdC(), depending on the command-calling style you choose. acedCommandS()/acedCmdS() are easy: they work in much the same way as acedCommand()/acedCmd() used to, but only with complete command/argument sets. acedCommandC()/acedCmdC() are more complicated: you need to provide a callback function that will be called to further process input tokens (it’s a form of <a href="http://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank">continuation passing</a> that is very common when dealing with asynchronous method calls, for example). ObjectARX developers should take a look at the ObjectARX Developer’s Guide as well as <em>acedCmdNF.h</em> (NF presumably stands for non-fiber in this context) for more information.</p>  <p>So ObjectARX developers have some work to do if they’re calling commands in AutoCAD 2015, then. What about the other programming environments?</p>  <p><strong>AutoLISP</strong> is much simpler: Autodesk has full control over the “virtual machine” that executes LISP code inside AutoCAD, so we can choose which of the two underlying ObjectARX functions to call, depending on the scenario and without requiring a change in the LISP calling code. That said, the ADN team tells me they’ve seen scenarios where a developer specifically needed to specify the subroutine style, at which point they’ve been able to call (command-<strong>s</strong> …) instead.</p>  <p>For <strong>VBA</strong> – which has now been updated to VBA 7.1 and is still available as a separate download – I don’t think anything has changed: it still has the AcadDocument.SendCommand() method, which seems to work with partial commands (I’ll update this post if I hear anything different on that front).</p>  <p><strong>.NET</strong> is also simple in its own way: subroutine calls are straightforward – they simply run synchronously via Editor.Command() – and because AutoCAD 2015 now makes use of .NET 4.5 – which provides C# with the async/await mechanism for calling asynchronous methods – we’ve been able to implement that mechanism for coroutine calls. These now make use of the compiler’s automatic callback generation via the await keyword to work asynchronously – e.g. await Editor.CommandAsync(…). You’ll need to tag any command method using CommandAsync() with the async modifier, just as you would when using other awaitable methods.</p>  <p>The difference between C# and C++ is analogous to general asynchronous coding: changes have been made at the language level to make asynchrony easier to handle from C#, and in time comparable extensions will make their way into C++ also.</p>  <p>Do bear in mind that to target .NET 4.5 – which is a requirement to use the API enhancements in AutoCAD 2015 – you will need to use Visual Studio 2012 or 2013: VS2010 cannot target .NET 4.5. (ObjectARX developers will have to use the toolset from VS2012 to compile their C++ modules, as that’s the compiler being used to build AutoCAD.) I’m personally now using VS2013 as a primary IDE, but make use of the VS2012 toolset when building ObjectARX modules.</p>  <p>If you’re still using VS2010, you *should* be able to target your .NET application against the class libraries for AutoCAD 2013 or 2014 (as long as you’re not making use of newer APIs) and run that code in AutoCAD 2015, but do make sure you test your application thoroughly.</p>  <p>In tomorrow’s post we’ll take a look at a new capability related to product theming that has been enabled in AutoCAD 2015.</p>  <p><strong><em>Update:</em></strong></p>  <p>To give a sense for the differences between Command() and CommandAsync() when used from C#, here are two commands, one that calls INSERT synchronously with the full set of arguments and one that calls it asynchronously, asking the user to enter the insertion point (a very common scenario, as jigging the block to show the block’s graphics is much more complicated than just calling INSERT).</p>  <div style="font-size: 8pt; font-family: courier new; background: white; color: black; line-height: 140%">   <p style="margin: 0px"><span style="color: blue">using</span> Autodesk.AutoCAD.ApplicationServices;</p>    <p style="margin: 0px"><span style="color: blue">using</span> Autodesk.AutoCAD.EditorInput;</p>    <p style="margin: 0px"><span style="color: blue">using</span> Autodesk.AutoCAD.Runtime;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px"><span style="color: blue">namespace</span> CommandCalling</p>    <p style="margin: 0px">{</p>    <p style="margin: 0px">&#160; <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">Commands</span></p>    <p style="margin: 0px">&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160; [<span style="color: #2b91af">CommandMethod</span>(<span style="color: #a31515">&quot;IBS&quot;</span>)]</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> InsertBlockSync()</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> doc =</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Application</span>.DocumentManager.MdiActiveDocument;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> ed = doc.Editor;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: green">// Our insertion point is hardcoded at 10,10</span></p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; ed.Command(<span style="color: #a31515">&quot;_.INSERT&quot;</span>, <span style="color: #a31515">&quot;TEST&quot;</span>, <span style="color: #a31515">&quot;10,10&quot;</span>, 1, 1, 0);</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; ed.WriteMessage(<span style="color: #a31515">&quot;\nWe have inserted our block.&quot;</span>);</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160; [<span style="color: #2b91af">CommandMethod</span>(<span style="color: #a31515">&quot;IBA&quot;</span>)]</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">async</span> <span style="color: blue">public</span> <span style="color: blue">void</span> InsertBlockAsync()</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> doc =</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Application</span>.DocumentManager.MdiActiveDocument;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> ed = doc.Editor;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: green">// Let's ask the user to select the insertion point</span></p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; <span style="color: blue">await</span> ed.CommandAsync(</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #a31515">&quot;_.INSERT&quot;</span>, <span style="color: #a31515">&quot;TEST&quot;</span>, <span style="color: #2b91af">Editor</span>.PauseToken, 1, 1, 0</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; );</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160; ed.WriteMessage(<span style="color: #a31515">&quot;\nWe have inserted our block.&quot;</span>);</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160; }</p>    <p style="margin: 0px">}</p> </div>

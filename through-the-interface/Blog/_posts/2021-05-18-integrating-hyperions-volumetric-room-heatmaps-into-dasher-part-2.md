---
layout: "post"
title: "Integrating Hyperion&rsquo;s volumetric room heatmaps into Dasher &ndash; Part 2"
date: "2021-05-18 12:12:23"
author: "Kean Walmsley"
categories:
  - "APS (Forge)"
  - "Autodesk Research"
  - "IoT"
original_url: "https://www.keanw.com/2021/05/integrating-hyperions-volumetric-room-heatmaps-into-dasher-part-2.html "
typepad_basename: "integrating-hyperions-volumetric-room-heatmaps-into-dasher-part-2"
typepad_status: "Publish"
---

<p>I was thinking back on last week’s post regarding the work needed to <a href="https://www.keanw.com/2021/05/integrating-hyperions-volumetric-heatmaps-into-dasher.html" target="_blank">integrate Hyperion’s volumetric heatmaps into Dasher</a>, and realised that – despite the relative length of the post – I’d really glossed over the process for integrating heatmaps and using them to display sensor data. So I’ve retroactively gone back and marked that post as “Part 1”, with this post being “Part 2”.</p><p>That’s not to say the process is especially complicated, but I felt it was a bit of a cop out to say “just follow the documentation”, as there was a little more to it (for us, anyway).</p><p>Here’s the basic process we now follow in Dasher to generate surface shading heatmaps using the Data Visualization Extension (i.e. Hyperion):</p><ol><li>Create a ModelStructureInfo for our model</li><ul><li>This doesn’t result in the proper data being populated for us, however – as we’re using Navisworks data – hence the need for step 2</li></ul><li>Build a LevelRoomsMap based on our levels, rooms and devices</li><ul><li>We saw the code for this in Part 1 of the series</li></ul><li>Call generateSurfaceShadingData(), passing in our devices and map</li><ul><li>In Dasher – as we’re using a Navisworks-based workflow – we currently have a separate step where we go through and create fragIds for each of our room’s dbIds: this shouldn’t be needed for Revit-based workflows, and will in any case happen automatically in an upcoming update to the Forge viewer</li></ul><li>Decide whether to create volumetric or planar heatmaps</li><ul><li>We’ll cover the latter option in an upcoming post</li></ul><li>Call setupSurfaceShading() with our model, shading data and configuration options</li><li>Call registerSurfaceShadingColors() for our various sensor types and their colour schemes</li><li>Call renderSurfaceShading() for the room or level and sensor type to be displayed, specifying the “sensor value” callback function</li><li>On regular intervals (such as time-change events fired by the timeline), call updateSurfaceShading() with the callback function<br></li><li>When done, call removeSurfaceShading()</li></ol><p>I’ve expressed a few times, now, that I was concerned about our ability to leverage Hyperion heatmaps, mainly because we have our own internally developed, back-end, time-series database. The good news is that the callback function you pass to renderSurfaceShading() and then updateSurfaceShading() (the function they use in the docs is called getSensorValue()) actually allows you to get your sensor value from anywhere: in Dasher we have a local, browser-resident data cache that is populated with sensor readings based on the time selection in the timeline – this allows us to avoid redundant network calls when the timeline’s playing loops or restarts – but you could theoretically get this data from anywhere (even a CSV file). This makes Hyperion a much more flexible and useful component.</p><p>Here’s how we’ve implemented our getSensorValue() callback function, bearing in mind that its implementation details only make sense for Dasher. Which means this code is really just for me to show that the mechanism works (honest!), rather than being of any real value for anyone implementing their own. (We did have to implement our own clamp() function, by the way, but that’s something that’s found easily on the interwebs, in case you don’t already have an equivalent utility function.)</p><p><div class="vscode" style="white-space: pre;"><div><span style="color: rgb(212, 212, 212);">&nbsp; </span><span style="color: rgb(220, 220, 170);">getSensorValue</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(156, 220, 254);">surfaceShadingPoint</span><span style="color: rgb(212, 212, 212);">: </span><span style="color: rgb(78, 201, 176);">any</span><span style="color: rgb(212, 212, 212);">, </span><span style="color: rgb(156, 220, 254);">sensorType</span><span style="color: rgb(212, 212, 212);">: </span><span style="color: rgb(78, 201, 176);">string</span><span style="color: rgb(212, 212, 212);">, </span><span style="color: rgb(156, 220, 254);">pd</span><span style="color: rgb(212, 212, 212);">: </span><span style="color: rgb(78, 201, 176);">any</span><span style="color: rgb(212, 212, 212);">): </span><span style="color: rgb(78, 201, 176);">number</span><span style="color: rgb(212, 212, 212);"> {</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">deviceId</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(156, 220, 254);">surfaceShadingPoint</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">id</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">let</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);">: [</span><span style="color: rgb(78, 201, 176);">any</span><span style="color: rgb(212, 212, 212);">, </span><span style="color: rgb(78, 201, 176);">any</span><span style="color: rgb(212, 212, 212);">];</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">if</span><span style="color: rgb(212, 212, 212);"> (</span><span style="color: rgb(86, 156, 214);">this</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">_latestSensorData</span><span style="color: rgb(212, 212, 212);">) {</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(86, 156, 214);">this</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">_latestSensorData</span><span style="color: rgb(212, 212, 212);">[</span><span style="color: rgb(79, 193, 255);">deviceId</span><span style="color: rgb(212, 212, 212);">];</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; }</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">if</span><span style="color: rgb(212, 212, 212);"> (!</span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);">) {</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">sm</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(86, 156, 214);">this</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">dataModel</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">sensorManager</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">si</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(79, 193, 255);">sm</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(220, 220, 170);">getSensorInfo</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(79, 193, 255);">deviceId</span><span style="color: rgb(212, 212, 212);">);</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(79, 193, 255);">si</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; }</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">val</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);">?.</span><span style="color: rgb(156, 220, 254);">length</span><span style="color: rgb(212, 212, 212);"> === </span><span style="color: rgb(181, 206, 168);">2</span><span style="color: rgb(212, 212, 212);"> ? </span><span style="color: rgb(220, 220, 170);">parseFloat</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(156, 220, 254);">latest</span><span style="color: rgb(212, 212, 212);">[</span><span style="color: rgb(181, 206, 168);">1</span><span style="color: rgb(212, 212, 212);">]) : </span><span style="color: rgb(181, 206, 168);">0.0</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">sett</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(86, 156, 214);">this</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">_settingsPanel</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">legendSettings</span><span style="color: rgb(212, 212, 212);">[</span><span style="color: rgb(156, 220, 254);">sensorType</span><span style="color: rgb(212, 212, 212);">];</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">if</span><span style="color: rgb(212, 212, 212);"> (</span><span style="color: rgb(79, 193, 255);">sett</span><span style="color: rgb(212, 212, 212);">) {</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">min</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(79, 193, 255);">sett</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">min</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">max</span><span style="color: rgb(212, 212, 212);"> = </span><span style="color: rgb(79, 193, 255);">sett</span><span style="color: rgb(212, 212, 212);">.</span><span style="color: rgb(156, 220, 254);">max</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(86, 156, 214);">const</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(79, 193, 255);">sensorValue</span><span style="color: rgb(212, 212, 212);"> = (</span><span style="color: rgb(79, 193, 255);">val</span><span style="color: rgb(212, 212, 212);"> - </span><span style="color: rgb(79, 193, 255);">min</span><span style="color: rgb(212, 212, 212);">) / (</span><span style="color: rgb(79, 193, 255);">max</span><span style="color: rgb(212, 212, 212);"> - </span><span style="color: rgb(79, 193, 255);">min</span><span style="color: rgb(212, 212, 212);">);</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">return</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(220, 220, 170);">clamp</span><span style="color: rgb(212, 212, 212);">(</span><span style="color: rgb(79, 193, 255);">sensorValue</span><span style="color: rgb(212, 212, 212);">, </span><span style="color: rgb(181, 206, 168);">0.0</span><span style="color: rgb(212, 212, 212);">, </span><span style="color: rgb(181, 206, 168);">1.0</span><span style="color: rgb(212, 212, 212);">);</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; }</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp;&nbsp;&nbsp; </span><span style="color: rgb(197, 134, 192);">return</span><span style="color: rgb(212, 212, 212);">&nbsp;</span><span style="color: rgb(86, 156, 214);">undefined</span><span style="color: rgb(212, 212, 212);">;</span></div><div><span style="color: rgb(212, 212, 212);">&nbsp; }</span></div></div><p>The fidelity of the volumetric heatmap rendering has been very good – admittedly not a huge surprise, as Hyperion’s implementation was based on Dasher’s. Having the 2D heatmaps – which are rendered using the original shader that’s (for now) still usable inside Dasher – provide a side-by-side view helps a great deal with this comparison:</p><p><a href="https://through-the-interface.typepad.com/.a/6a00d83452464869e2026bded26c53200c-pi" target="_blank"><img width="500" height="312" title="Validating surface shading" style="margin: 30px auto; float: none; display: block;" alt="Validating surface shading" src="/assets/image_751074.jpg"></a></p><p>This side-by-side verification has helped identify an area where the planar shading differs from the volumetric approach – something the Hyperion team is working on fixing right now. I’ll hopefully share more on planar heatmaps next week, once this fidelity issue has been addressed in an internal build.</p>

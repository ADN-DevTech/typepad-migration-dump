---
layout: "post"
title: "Tips for creating large assemblies using Inventor API"
date: "2013-07-28 14:07:34"
author: "Vladimir Ananyev"
categories:
  - "Inventor"
  - "Vladimir Ananyev"
original_url: "https://adndevblog.typepad.com/manufacturing/2013/07/tips-for-creating-large-assemblies-using-inventor-api.html "
typepad_basename: "tips-for-creating-large-assemblies-using-inventor-api"
typepad_status: "Publish"
---

<p>by <a href="http://adndevblog.typepad.com/manufacturing/vladimir-ananyev.html">Vladimir Ananyev</a></p>  <p>This DevNote touches upon some general tips on creating large assemblies using Inventor API. This does not deal with hardware configurations or recommendations.</p>  <p align="left">1.&#160; Use an in-process program such as an add-in. An out-of-process executable substantially deteriorates performance. Add-ins implemented with .Net can have a negative influence on performance because .Net runtime reserves 100 MB of address space away from Inventor. </p>  <p>2.&#160; Create the assembly with the assembly document invisible. </p>  <p>3.&#160; Make all work planes invisible. </p>  <p>4. Consider Substitute Level of Detail representation to use a part file in place of the assembly to improve capacity. </p>  <p>5.&#160; After applying constraints, remove them if the problem we are solving is only to position the components and delete the constraints. This is because when a constraint is applied, Inventor constraint solver checks for all the previously applied constraints. </p>  <p>6.&#160; If constraints need to be retained, one approach is to group the parts into subassemblies. This greatly decreases the maximum length of recalculated constraint chains. </p>  <p>7.&#160; If possible, identify unique and repeated subassemblies. If several subassemblies are repeated, structure the program so that only unique subassemblies are created and they are reused to represent the repeated subassemblies. </p>  <p>8.&#160; As large assemblies with several subassemblies are being generated, save, close, and reopen them. This will reduce the burden of saving a large assembly in one shot in the end. It has often been observed that it takes more time to save an assembly than to create it. If a subassembly needs to be made visible for some reason, then zoom into an area of constant color/ texture before saving it. This can have a positive influence on the saving process. </p>  <p>9.&#160; In case of designing an assembly configurator, input data is normally obtained from other programs such as Excel or Access. In this case, it is advantageous to read all the relevant data from Excel/ Access first and store them as global variables. This obviates the need to access Excel/ Access several times. </p>  <p>10.&#160; Whenever an object is no longer going to be used, set it to null or nothing. This releases memory (which is a constraint in large assembly creation). </p>  <p>11.&#160; If a 2D drawing (IDW) is generated from a huge assembly, it will be beneficial to write a program to close the assembly, reopen it invisibly, and then create the drawing. </p>

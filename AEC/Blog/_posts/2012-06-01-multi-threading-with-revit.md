---
layout: "post"
title: "Multi-threading with Revit"
date: "2012-06-01 11:42:40"
author: "Saikat Bhattacharya"
categories:
  - ".NET"
  - "Revit"
  - "Saikat Bhattacharya"
original_url: "https://adndevblog.typepad.com/aec/2012/06/multi-threading-with-revit.html "
typepad_basename: "multi-threading-with-revit"
typepad_status: "Publish"
---

<p>By <a href="http://adndevblog.typepad.com/aec/saikat-bhattacharya.html" target="_self">Saikat Bhattacharya</a></p>  <p>In this post, I am including inputs from our colleagues from the Revit API Development team on the above mentioned topic and believe it will help a lot of API users out there who have considered using multi-threading while working with the Revit API at some point or the other. </p>  <p>We have received a number of report in the past where API users (developers) have faced issues in Revit while using multi-threading or Revit API asynchronously. However, most of the reported problems were caused by not using the API &quot;properly&quot;. It cannot be said for sure how many improper ways of using the API exist, but it is known about one that is definitely quite dangerous. This post describes that one case and explain why it should be avoided: i.e., The danger of invoking Revit API asynchronously and the correct way of doing so.&#160; </p>  <p>The fact: Revit does not expect external applications calling the API from other than the main Revit thread. Although it is possible to access the API from other threads, and sometimes such calls may even succeed, it is not a recommended technique and the outcomes of such calls can be virtually unpredictable and often fatal. </p>  <p>To give you an example, the following is one of the unsupported API access workflows: </p>  <ol>   <li>Revit calls an external command by invoking the command’s Execute method. </li>    <li>The command collects data from Revit API, initiates a modeless dialog, and returns control back to Revit. </li>    <li>The modeless dialog waits for other data (could be the user’s input), and then calls the API. </li> </ol>  <p>The obvious reason for the above scenario is not holding down Revit while the external application is performing the task. Though this workflow is thoughtful and actually correct, it is not allowed in Revit because Revit does not have a multi-thread-ready API. Revit uses multi-threading internally to speed up certain processes, but Revit does not expect external applications to be executed outside of predefined workflows. Revit does safeguard the API in various ways, but it only has the guards the main entry points, not at each and every API method. When an external application bypasses the entry points (like in the case outlined above), a lot of things that should happen will not happen (or vice-versa): </p>  <ul>   <li>Transactions will not be protected properly. </li>    <li>Transaction mode and Regeneration mode cannot be set accordingly. </li>    <li>Revit will not be able to tell what is the active application's ID. </li>    <li>Revit cannot tell what depth-level the API is operating on, therefore events may behave unexpectedly. </li> </ul>  <p>Most of the above would either cause exceptions that would not happen otherwise, or miss on exceptions that should happen. Both cases could be equally dangerous. </p>  <p>When it was mentioned that Revit expects external applications to use one of the predefined workflows, it meant: </p>  <ul>   <li>The OnStartup and OnShutdown method of an external application. </li>    <li>The Execute method of an external command. </li>    <li>Execution of an event handler. </li>    <li>Execution of a VSTA (now, SharpDevelop) macro. </li>    <li>Execution of methods of an instance of the IUpdater interface (such as the Execute method). </li>    <li>Executions of method of a call-back Interface (such as ITransactionFinalizer::OnCommitted). </li> </ul>  <p>When Revit calls these methods in external applications it expects that whatever the method would do, it will do it while the execution was in that method. Once the method returns back to Revit, the calls is considered completed and the API closed for external calls (though it is not technically closed). </p>  <p>Now, when an external application steps outside of the predefined workflows, one of many things can happen: </p>  <ul>   <li>Nothing bad at all – the call succeeds and all is fine (this is really rare). </li>    <li>Calls appear all right and return successfully, though the gathered data are out of date or out of sync. </li>    <li>Calls fail, exceptions are thrown, Revit stops what it was doing at that moment (and this is actually a good scenario). </li>    <li>Revit crashes, document must be closed. </li>    <li>Revit model is corrupted by two independent processes executing at the same time trying to modify the same or related data. In a better scenario, Revit crashes before the corrupted model is saved. In the worst scenario, the data is saved, which makes the document unrecoverable later. </li> </ul>  <p>Consider for a moment one of the mildest scenarios when the asynchronous call (AC for short) &quot;just&quot; reads data from the model: </p>  <ol>   <li>AC calls to get one parameter of a wall. </li>    <li>Another application waiting for the Idling event was called and changed the type of the wall. </li>    <li>AC calls to get another parameter of the wall. </li>    <li>Third application’s updater reacts to the change of the type of the wall, and makes the wall deeper. </li>    <li>AC calls to get another parameter of the wall. </li> </ol>  <p>Though those three AC calls might very well be next to each other in the client’s code, they were technically executed at different times and the data acquired by each of the methods reflect the state of the model at those different times. Therefore, some or all of the gathered data might be wrong. </p>  <p>Naturally, we will expect some of you may ask if there is another way at all for using multiple threads (and/or modeless dialogs) in external applications and still be able to interact with Revit. The answer is Yes, there is. Revit does not mind if an external application uses more threads. Revit only requires that the application calls the API from the standard entry points only, such as commands and events, and from the thread in which the call was made. In scenarios that have been described to me so far, a quite simple workaround was possible. In most cases it meant utilizing the Idling event. I'll describe it in steps: </p>  <ol>   <li>Application registers itself and its commands. </li>    <li>On one command, it kicks off a working thread (or a modeless dialog) and leaves it there working (or waiting). </li>    <li>If the kick-off succeeded, the command registers a handler for the Idling event. </li>    <li>The command then returns, Revit continues running. </li>    <li>Whenever possible and appropriate, Revit will raise the Idling event. </li>    <li>The application's handler gets the call. </li>    <li>Now, it all depends on how the application communicates with its working thread (or the modeless dialog):      <ol>       <li>It could be that the thread periodically feeds data back to the application, so when the event is raised, the data is either there already or not. The event handlers then use the data and calls the API as needed. </li>        <li>Or it could be that the application queries the work thread somehow at the time of the event. If the thread is ready and waiting, the application gets data from it and uses it as it sees fit. </li>     </ol>   </li>    <li>When the work thread finishes, it signals the application, so when the next Idling event is raised (or another event, such as DocumentClosed), the application can unregister from it. </li> </ol>  <p>Of course, this workflow is not quite as good as if the API was perfectly multi-threaded, but it is as good a workaround as it gets. Like we discussed, most if not all the scenarios heard about so far could be accomplished this way. </p>

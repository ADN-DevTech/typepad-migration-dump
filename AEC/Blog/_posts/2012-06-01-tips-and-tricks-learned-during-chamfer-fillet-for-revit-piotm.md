---
layout: "post"
title: "Tips and Tricks learned during Chamfer Fillet for Revit PIOTM development"
date: "2012-06-01 11:27:52"
author: "Augusto Goncalves"
categories:
  - "Augusto Goncalves"
  - "Revit"
  - "Revit Architecture"
original_url: "https://adndevblog.typepad.com/aec/2012/06/tips-and-tricks-learned-during-chamfer-fillet-for-revit-piotm.html "
typepad_basename: "tips-and-tricks-learned-during-chamfer-fillet-for-revit-piotm"
typepad_status: "Publish"
---

<p>By <a href="http://adndevblog.typepad.com/autocad/augusto-goncalves.html">Augusto Goncalves</a></p>  <p>Here is a collection of lessons learned during this plug-in development. You can see all of that in action with the <a href="http://labs.autodesk.com/utilities/revit_chamferfillet/" target="_blank">source code available at Autodesk Labs</a>.</p>  <p><strong>Intersection points between walls</strong></p>  <p>Both Chamfer and Fillet uses a key method for this plug-in: <strong>Curve.Intersect</strong>. Basically, for a given wall, the command must access its underlying geometry, a curve (e.g. line), and through the Intersect method find the intersection point with another curve. It is very important to notice that <strong>LineSegment</strong> objects (i.e. finite lines) usually do not intersect each other, so it’s required to use the method <strong>Curve.MakeUnbound</strong> to create a <strong>Line</strong> object (i.e. infinite line). Note that this plug-in was designed to work on linear walls with one intersection point between them.</p>  <p><strong>Organize the underlying geometry to if necessary create the third wall with the correct orientation</strong></p>  <p>After access the curves of both walls (e.g. <strong>LineSegments</strong>), the command store <strong>XYZ</strong> directional vectors for both walls. All calculations are performed with vectors, which is more consistent. Notice that walls are created following that orientation, which affects the internal/external sides, which ultimately affects hosted elements (e.g. doors, windows).</p>  <p><strong>Chamfer</strong></p>  <p>As a chamfered intersection of walls consist in resizing two walls from its (projected) intersection point, this PIOTM created <strong>XYZ</strong> vectors from the intersection point to the closest point on the wall, which is used to find the next end point of the walls. Once resized, the new wall is created connecting them.</p>  <p><strong>Fillet</strong></p>  <p>This was the changeling one. To create a fillet with a previously defined radius, the command must calculate the deflection angle formed between the walls. This deflection angle is important because is used to obtain the tangent distance T in the image below. This external tangent length represents the necessary distance between the intersection point and the end point of the selected walls, used to create a curve with the desired radius. </p>  <p align="left"><a href="http://adndevblog.typepad.com/.a/6a0167607c2431970b0168ebffb5bc970c-pi"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="deflection_angle" border="0" alt="deflection_angle" src="/assets/image_921656.jpg" width="190" height="190" /></a>    <br />Image adapted from <a href="http://www.civilengineeringterms.com/surveying-and-levelling-2/layout-of-simple-circular-horizontal-curve-degree-of-curvature-length-of-curve-circular-curve-geometry/">Civil Engineering Terms</a> blog</p>  <p>To find the deflection angle, the command creates two concurrent <strong>XYZ</strong> vectors, from the farthest point of the walls to the intersection point, and then the <strong>Vector.AngleTo</strong> method gets the deflection angle. On important trick: the AngleTo method considers the vector orientation and, inside Revit API, is always counterclockwise, that’s why this plug-in recreates the concurrent vectors, which obeys the image above.</p>  <p><strong>Resizing connects/joined walls</strong></p>  <p>Revit does not accept changes on walls curves when the wall end is connected to another wall, so the trick here was call <strong>WallUtils.IsWallJoinAllowedAtEnd</strong> to check if that end was connected, then, if required, disconnect with a call to <strong>WallUtils.DisallowWallJoinAtEnd</strong>, followed by a call to connect them back with <strong>WallUtils.AllowWallJoinAtEnd</strong>.    </p>

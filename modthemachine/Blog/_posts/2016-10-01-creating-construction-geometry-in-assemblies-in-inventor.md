---
layout: "post"
title: "Creating Construction Geometry in Assemblies in Inventor"
date: "2016-10-01 06:52:01"
author: "Adam Nagy"
categories:
  - "Assemblies"
  - "Brian"
  - "Inventor"
original_url: "https://modthemachine.typepad.com/my_weblog/2016/09/creating-construction-geometry-in-assemblies-in-inventor.html "
typepad_basename: "creating-construction-geometry-in-assemblies-in-inventor"
typepad_status: "Publish"
---

<p>I was working on answering a question recently and put together a bit of code to make sure my answer was correct and thought it might be useful to some others so I want to share it here.</p> <p>The initial question was a good one. The question was how to create an offset work plane in an assembly using the API. The obvious thing is to use the AddByPlaneAndOffset method of the WorkPlanes collection but if you try it, it will fail and if you look at the help it will tell you that it’s not supported in assemblies, but it also doesn’t say how to do it.</p> <p>Assemblies and construction geometry are a bit strange. Working interactively with Inventor, work geometry seems to work just that same as when working in a part, but if you look close you’ll see a big difference. If you create an offset work plane using the UI in an assembly and then look at the result in the browser you’ll see the work plane in the browser just like you would in a part, except in an assembly the work plane browser node can be expanded and then you’ll see that there’s a flush constraint.&nbsp; Work geometry in a part has intelligence within itself to know what it’s related to and how it’s related so if that geometry is modified it can correctly re-compute itself.&nbsp; Work geometry in an assembly isn’t intelligent at all.&nbsp; It just exists in space and the intelligence to position it is done by adding constraints.&nbsp; </p> <p>The assembly work geometry commands have a lot of intelligence in them and will create the work geometry and automatically add the needed constraints to get the desired behavior.&nbsp; The API doesn’t do this. You can create a work plane in space but then you need to add the flush constraint as a separate step. In an assembly, the only way you can create work geometry is to use the AddFixed methods on each of the work geometry collections.</p> <p>Below is the VBA code I wrote to test this. It demonstrates getting a selected face and then creating a work plane on that face. I’m using an offset of 0, but any offset could be used.&nbsp; A fair amount of the code is just figuring out the orientation of the work plane.&nbsp; Although the orientation doesn’t really matter except for looks.&nbsp; To get a logical orientation it uses the longest linear edge on the selected face and if there aren’t any linear edges then it aligns it with one of the primary model axes. The UI command also does some additional work to size the created work plane to fit the geometry, which the API and this sample doesn’t do.&nbsp; The API does support setting the size of a work plane but I haven’t attempted that here.<br></p> <div style="font-size: 10pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%"> <p>Public Sub CreateWorkPlane()<br>&nbsp;&nbsp;&nbsp; Dim asmDoc As AssemblyDocument<br>&nbsp;&nbsp;&nbsp; Set asmDoc = ThisApplication.ActiveDocument<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Dim asmDef As AssemblyComponentDefinition<br>&nbsp;&nbsp;&nbsp; Set asmDef = asmDoc.ComponentDefinition<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <strong><font color="#0000ff">' Have a planar face selected.</font></strong><br>&nbsp;&nbsp;&nbsp; Dim selFace As Face<br>&nbsp;&nbsp;&nbsp; Set selFace = ThisApplication.CommandManager.Pick(kPartFacePlanarFilter, "Select planar face")<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' Get the underlying plane geometry from the face.<br></strong></font>&nbsp;&nbsp;&nbsp; Dim facePlane As Plane<br>&nbsp;&nbsp;&nbsp; Set facePlane = selFace.Geometry<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Dim tg As TransientGeometry<br>&nbsp;&nbsp;&nbsp; Set tg = ThisApplication.TransientGeometry<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' Find the longest linear edge on the face and use it as the X axis.</strong></font><br>&nbsp;&nbsp;&nbsp; Dim testEdge As Edge<br>&nbsp;&nbsp;&nbsp; Dim longDir As UnitVector<br>&nbsp;&nbsp;&nbsp; Dim longLength As Double<br>&nbsp;&nbsp;&nbsp; longLength = 0<br>&nbsp;&nbsp;&nbsp; For Each testEdge In selFace.Edges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If testEdge.GeometryType = kLineSegmentCurve Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim lengthVec As Vector<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set lengthVec = testEdge.StartVertex.Point.VectorTo(testEdge.StopVertex.Point)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If lengthVec.length &gt; longLength Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longLength = lengthVec.length<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set longDir = lengthVec.AsUnitVector<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp; Next<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Dim xVec As UnitVector<br>&nbsp;&nbsp;&nbsp; Dim yVec As UnitVector<br>&nbsp;&nbsp;&nbsp; Dim pi As Double<br>&nbsp;&nbsp;&nbsp; pi = Atn(1) * 4<br>&nbsp;&nbsp;&nbsp; If Not longDir Is Nothing Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' Use the longest edge as the x direction for the work plane.</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set xVec = longDir<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set yVec = facePlane.Normal.CrossProduct(xVec)<br>&nbsp;&nbsp;&nbsp; Else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' No linear edges was found so calculate another axis to use as the x axis.<br></strong></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' Use the model x, y, or z axis depending on which one is closest to 90 deg from the normal.</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim angleDiff As Double<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim testVec As UnitVector<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set testVec = tg.CreateUnitVector(1, 0, 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleDiff = Abs((pi / 2) - facePlane.Normal.AngleTo(testVec))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set xVec = testVec<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set testVec = tg.CreateUnitVector(0, 1, 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Abs((pi / 2) - facePlane.Normal.AngleTo(testVec)) &lt; angleDiff Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleDiff = Abs((pi / 2) - facePlane.Normal.AngleTo(testVec))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set xVec = testVec<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set testVec = tg.CreateUnitVector(0, 0, 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Abs((pi / 2) - facePlane.Normal.AngleTo(testVec)) &lt; angleDiff Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angleDiff = Abs((pi / 2) - facePlane.Normal.AngleTo(testVec))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set xVec = testVec<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set yVec = facePlane.Normal.CrossProduct(xVec)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set xVec = yVec.CrossProduct(facePlane.Normal)<br>&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' Create the "fixed" work plane.<br></strong></font>&nbsp;&nbsp;&nbsp; Dim wp As WorkPlane<br>&nbsp;&nbsp;&nbsp; Set wp = asmDef.WorkPlanes.AddFixed(facePlane.RootPoint, xVec, yVec)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; <font color="#0000ff"><strong>' Create a flush constraint between the face and the workplane with an offset of 0.</strong></font><br>&nbsp;&nbsp;&nbsp; Dim flush As FlushConstraint<br>&nbsp;&nbsp;&nbsp; Set flush = asmDef.Constraints.AddFlushConstraint(selFace, wp, 0, facePlane.RootPoint, facePlane.RootPoint)<br>End Sub</p></div> <p>-Brian</p>

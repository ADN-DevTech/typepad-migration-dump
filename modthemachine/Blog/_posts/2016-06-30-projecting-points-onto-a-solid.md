---
layout: "post"
title: "Projecting Points Onto a Solid"
date: "2016-06-30 19:28:58"
author: "Adam Nagy"
categories:
  - "Brian"
  - "Utilities"
original_url: "https://modthemachine.typepad.com/my_weblog/2016/06/projecting-points-onto-a-solid.html "
typepad_basename: "projecting-points-onto-a-solid"
typepad_status: "Publish"
---

<p>There was a recent Inventor question posted on <a href="https://stackoverflow.com/questions/38110160/get-the-points-coordinates-from-a-geometry-projection-over-a-solid-in-autodesk-i">stackoverflow</a> that I thought was interesting and decided to look at.&#0160; The question involved being able to project points from a sketch onto a solid.&#0160; Below is a picture of a sketch that contains many sketch center points.&#0160; In this case they were created by patterning a point to get a grid of points but they could be created in any way.&#0160; The goal is to project all of these points onto the solid.&#0160; For my program I chose to project them in the direction that is perpendicular (normal) to the sketch plane.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d1ff84db970c-pi"><img alt="ProjectPoints1" border="0" height="445" src="/assets/image_138631.jpg" style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-width: 0px;" title="ProjectPoints1" width="690" /></a>&#0160;</p>
<p>&#0160;</p>
<p>Here’s the result where the intersection points are created as work points.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b7c875b48a970b-pi"><img alt="ProjectPoints2" border="0" height="436" src="/assets/image_567292.jpg" style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-width: 0px;" title="ProjectPoints2" width="633" /></a></p>
<p>&#0160;</p>
<p>The sketch can be in any orientation in space, as shown in the picture below.&#0160; In this case the results were created as points within a 3D sketch.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d1ff84e3970c-pi"><img alt="ProjectPoints3" border="0" height="468" src="/assets/image_697174.jpg" style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-width: 0px;" title="ProjectPoints3" width="626" /></a></p>
<p>&#0160;</p>
<p>And here’s the VBA code that I came up with to do this.&#0160; It asks for the selection of a sketch (which you need to pick in the browser) and for a body.&#0160; The next section of code is the most confusing but it’s basically trying to determine where the selected sketch is relative to the selected body and then computing a value so that when it begins projecting the points, the point it projects is outside of the solid.&#0160; That’s actually the largest chunk of the code.&#0160; Towards the bottom of the macro you’ll see where the actual intersection work takes place.&#0160; It then prompts the user to select how to display the results where they can choose one of three ways; as work points, points in a 3D sketch, or written to a csv file.</p>
<div style="font-size: 9pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%;">
<p>Public Sub ProjectPoints()<br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Have the sketch that contains the points selected.<br /></strong></span>&#0160;&#0160;&#0160; Dim sk As PlanarSketch<br />&#0160;&#0160;&#0160; Set sk = ThisApplication.CommandManager.Pick(kSketchObjectFilter, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &quot;Select the sketch&quot;)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Have the body to project onto selected.</strong></span><br />&#0160;&#0160;&#0160; Dim body As SurfaceBody<br />&#0160;&#0160;&#0160; Set body = ThisApplication.CommandManager.Pick(kPartBodyFilter, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &quot;Select the body&quot;)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Get the part component definition.</strong></span><br />&#0160;&#0160;&#0160; Dim compDef As PartComponentDefinition<br />&#0160;&#0160;&#0160; Set compDef = body.Parent<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; *** Determine the side of the solid the sketch is on and if the<br /></strong></span>&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; *** sketch is outside the solid.<br /></strong></span>&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Get the normal vector of the selected sketch.</strong></span><br />&#0160;&#0160;&#0160; Dim skNormal As UnitVector<br />&#0160;&#0160;&#0160; Set skNormal = sk.PlanarEntityGeometry.Normal<br />&#0160;&#0160;&#0160; Dim skRootPoint As Point<br />&#0160;&#0160;&#0160; Set skRootPoint = sk.PlanarEntityGeometry.RootPoint<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Get the corners of the range box.</strong></span><br />&#0160;&#0160;&#0160; Dim tg As TransientGeometry<br />&#0160;&#0160;&#0160; Set tg = ThisApplication.TransientGeometry<br />&#0160;&#0160;&#0160; Dim cornerPoints(7) As Point<br />&#0160;&#0160;&#0160; Dim range As Box<br />&#0160;&#0160;&#0160; Set range = body.RangeBox<br />&#0160;&#0160;&#0160; Set cornerPoints(0) = range.MinPoint<br />&#0160;&#0160;&#0160; Set cornerPoints(1) = tg.CreatePoint(range.MinPoint.x, range.MinPoint.y, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; range.MaxPoint.Z)<br />&#0160;&#0160;&#0160; Set cornerPoints(2) = tg.CreatePoint(range.MinPoint.x, range.MaxPoint.y, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; range.MinPoint.Z)<br />&#0160;&#0160;&#0160; Set cornerPoints(3) = tg.CreatePoint(range.MinPoint.x, range.MaxPoint.y, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; range.MaxPoint.Z)<br />&#0160;&#0160;&#0160; Set cornerPoints(4) = range.MaxPoint<br />&#0160;&#0160;&#0160; Set cornerPoints(5) = tg.CreatePoint(range.MaxPoint.x, range.MinPoint.y, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; range.MaxPoint.Z)<br />&#0160;&#0160;&#0160; Set cornerPoints(6) = tg.CreatePoint(range.MaxPoint.x, range.MinPoint.y, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; range.MinPoint.Z)<br />&#0160;&#0160;&#0160; Set cornerPoints(7) = tg.CreatePoint(range.MaxPoint.x, range.MaxPoint.y, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; range.MinPoint.Z)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Construct a matrix where the X axis is along the sketch plane normal.</strong></span><br />&#0160;&#0160;&#0160; Dim xAxis As Vector<br />&#0160;&#0160;&#0160; Set xAxis = skNormal.AsVector<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim yAxis As Vector<br />&#0160;&#0160;&#0160; Set yAxis = tg.CreateVector(xAxis.x + 1, xAxis.y + 1, xAxis.Z + 1)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim zAxis As Vector<br />&#0160;&#0160;&#0160; Set zAxis = xAxis.CrossProduct(yAxis)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Set yAxis = zAxis.CrossProduct(xAxis)<br />&#0160;&#0160;&#0160; xAxis.Normalize<br />&#0160;&#0160;&#0160; yAxis.Normalize<br />&#0160;&#0160;&#0160; zAxis.Normalize<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim transform As Matrix<br />&#0160;&#0160;&#0160; Set transform = tg.CreateMatrix<br />&#0160;&#0160;&#0160; Call transform.SetCoordinateSystem(skRootPoint, xAxis, yAxis, zAxis)<br />&#0160;&#0160;&#0160; transform.Invert<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Transform the range box points and compare them to sketch plane.<br /></strong></span>&#0160;&#0160;&#0160; Dim i As Integer<br />&#0160;&#0160;&#0160; Dim smallX As Double<br />&#0160;&#0160;&#0160; For i = 0 To 7<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call cornerPoints(i).TransformBy(transform)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If i = 0 Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallX = cornerPoints(i).x<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Else<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If cornerPoints(i).x &lt; smallX Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallX = cornerPoints(i).x<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Determine the offset needed to position the points outside the solid.</strong></span><br />&#0160;&#0160;&#0160; Dim offset As Double<br />&#0160;&#0160;&#0160; If smallX &lt; 0 Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; offset = -(smallX + 10)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim tempNormal As Vector<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Set tempNormal = skNormal.AsVector<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call tempNormal.ScaleBy(-1)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Set skNormal = tempNormal.AsUnitVector<br />&#0160;&#0160;&#0160; Else<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; offset = 0<br />&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim offsetVector As Vector<br />&#0160;&#0160;&#0160; Set offsetVector = skNormal.AsVector<br />&#0160;&#0160;&#0160; Call offsetVector.ScaleBy(offset)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; *** Perform the intersection calculation of every center point in the sketch.<br /></strong></span>&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim resultPoints As ObjectCollection<br />&#0160;&#0160;&#0160; Set resultPoints = ThisApplication.TransientObjects.CreateObjectCollection<br />&#0160;&#0160;&#0160; Dim skPoint As SketchPoint<br />&#0160;&#0160;&#0160; For Each skPoint In sk.SketchPoints<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Check to see if the point is a center point.</strong></span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If skPoint.HoleCenter Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Get the sketch point as a transient 3D point.</strong><br /></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim pnt As Point<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Set pnt = skPoint.Geometry3d<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Move the point outside the solid.<br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call pnt.TranslateBy(offsetVector)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Intersect the point with the solid.<br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim foundEnts As ObjectsEnumerator<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim locPoints As ObjectsEnumerator<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call body.FindUsingRay(pnt, skNormal, 0.00001, foundEnts, locPoints, True)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; If an intersection was found, add it to the list.<br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If locPoints.count &gt; 0 Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call resultPoints.Add(locPoints.Item(1))<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Prompt the user for which type of output they want.</strong></span><br />&#0160;&#0160;&#0160; Dim result As String<br />&#0160;&#0160;&#0160; result = InputBox(&quot;Enter choice for output:&quot; &amp; vbCrLf &amp; &quot;1 - Work points&quot; &amp; _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; vbCrLf &amp; &quot;2 - 3D sketch&quot; &amp; vbCrLf &amp; &quot;3 - csv File&quot;, _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &quot;Enter output type&quot;, 3)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; If result = &quot;1&quot; Or result = &quot;2&quot; Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Start a transaction so that the creation is grouped in a single undo.</strong><br /></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim trans As Transaction<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Set trans = ThisApplication.TransactionManager.StartTransaction( _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; ThisApplication.ActiveDocument, &quot;Projected Points&quot;)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If result = &quot;1&quot; Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Create work points.</strong></span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; For i = 1 To resultPoints.count<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call compDef.WorkPoints.AddFixed(resultPoints.Item(i))<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If result = &quot;2&quot; Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Create a 3D sketch and points in the sketch.<br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim sk3D As Sketch3D<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Set sk3D = compDef.Sketches3D.Add()<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; For i = 1 To resultPoints.count<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call sk3D.SketchPoints3D.Add(resultPoints.Item(i))<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; trans.End<br />&#0160;&#0160;&#0160; ElseIf result = &quot;3&quot; Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"><strong>&#39; Write the points out to a file.</strong></span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Open &quot;C:\Temp\Points.csv&quot; For Output As #1<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; For i = 1 To resultPoints.count<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Print #1, Format(resultPoints.Item(i).x, &quot;0.00000000&quot;) &amp; &quot;,&quot; &amp; _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Format(resultPoints.Item(i).y, &quot;0.00000000&quot;) &amp; &quot;,&quot; &amp; _<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Format(resultPoints.Item(i).Z, &quot;0.00000000&quot;)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Close #1<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; MsgBox &quot;File written to &quot;&quot;C:\Temp\Points.csv&quot;&quot;&quot;<br />&#0160;&#0160;&#0160; Else<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; MsgBox &quot;Invalid Input&quot;<br />&#0160;&#0160;&#0160; End If<br />End Sub</p>
</div>
<p>Hopefully this is useful as a starting point for something you might want to do.&#0160; It at least demonstrates a couple of interesting things.</p>
<p>This is all Inventor but for those of you using Fusion, Fusion doesn’t currently have the API functionality to fire a ray through the model so this can’t be done in the same way.&#0160; I do expect that to be available at some point in the future though.</p>
<p>-Brian</p>

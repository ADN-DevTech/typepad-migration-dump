---
layout: "post"
title: "Thumbnail Viewer Component on a 64-Bit System"
date: "2012-05-03 22:12:11"
author: "Adam Nagy"
categories:
  - "Brian"
original_url: "https://modthemachine.typepad.com/my_weblog/2012/05/thumbnail-viewer-component-on-a-64-bit-system.html "
typepad_basename: "thumbnail-viewer-component-on-a-64-bit-system"
typepad_status: "Publish"
---

<p>In a <a href="http://modthemachine.typepad.com/my_weblog/2010/06/accessing-thumbnail-images.html">previous post</a> I discussed several way to access the thumbnail image that’s associated with each document.&#160; One of these ways is to use the ThumbnailView component.&#160; I received a question recently regarding the ThumbnailView component not working as expected.&#160; After quite a bit of digging and some testing I believe I know what the problem is and how to fix it.</p>  <p><strong><font color="#0000ff">I believe this an issue only if you’re using .Net (VB or C#) and are using 64-bit Windows.</font></strong>&#160; I don’t think there are problems with any other configurations but if there are, please let me know.</p>  <p><strong><font size="3">COM and .Net on a 64-Bit OS Overview</font></strong>     <br />Before I describe the solution, I think it might be worth taking a minute to describe what’s happening when you use a COM component (the thumbnail view component in this case) from .Net program on a 64-bit system.&#160; The picture below attempts to show all of the various pieces that need to play together to get this work.&#160; First, is the COM component itself.&#160; The thumbnail viewer was created using C++ and the resulting dll is compiled for either 32 or 64-bit.&#160; On a 32-bit system you can only use 32-bit components.&#160; On a 64-bit system you can use either 32 or 64-bit components because 64-bit windows supports an emulator that is able to run 32-bit applications.&#160; COM dll components run within the process of the program using it and a 32-bit component can only run within a 32-bit process and a 64-bit component can only run within a 64-bit process. </p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc68834016766153837970b-pi"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="64BitCOMComponent" border="0" alt="64BitCOMComponent" src="/assets/image_862758.jpg" width="403" height="314" /></a></p>  <p>The registry is used because COM components can be located anywhere on a computer but other programs need to be able to know they’re available and where they’re located.&#160; The components make themselves known by adding information to the registry.&#160; There are separate areas in the registry where 32-bit and 64-bit components register themselves.</p>  <p>Another piece that makes the 32-bit vs. 64-bit issue described above even more confusing is that when writing a .Net program you can specify that the runtime will be compatible with 32-bit (x86), 64-bit (x64), or “Any CPU” (both 32 and 64-bit).&#160; The “Any CPU” option is the interesting, and confusing, option.&#160; It’s the option I almost always use.&#160; The reason that .Net can support the “Any CPU” option is that when you compile your program, .Net compiles your program into MSIL (Microsoft Intermediate Language) which is a CPU independent set of instructions.&#160; When your program is run, it is converted by the JIT (Just-In-Time) compiler into native code. This means that even if your program was compiled for “Any CPU”, when it runs it will actually be running as a native 32-bit or 64-bit application.</p>  <p>Because the COM component runs in-process to your application it must match the bitness of the running application.&#160; For example, if you compile your application for “Any CPU” and run your program on a 64-bit machine, the .Net Framework will run it as a true 64-bit application and the 64-bit version of the thumbnail viewer will be required.&#160; If you compile your application for 32-bit and run it on a 64-bit machine, it will run as a 32-bit app and will require the 32-bit version of the thumbnail viewer.&#160; If the correct version of the COM component isn’t available, it will fail to run.</p>  <p>In addition to your program and the COM component, there is one other piece needed when using a COM component with .Net; an <em>Interop</em> assembly.&#160; Your .Net program can’t directly call a COM component.&#160; To provide support for COM, .Net uses the concept of Interop assemblies which are .Net components that provide a .Net interface to a COM component.&#160; When you use the COM component, your program is actually calling functions in the interop assembly, which translates those calls and makes the equivalent call in the COM component.&#160; The Interop serves as a wrapper for the COM component making it compatible with .Net.&#160; These interop assemblies are dll’s and can also be created for 64-bit, 32-bit, or <em>agnostic</em> (equivalent to “Any CPU”).&#160; But like the component, it must also match the bitness of the program it will be running within.</p>  <p>In summary, there are three runtime pieces; the COM component, the .Net Interop, and your program.&#160; If you’re running on a 32-bit system, all of them must be 32-bit.&#160; If you’re running on a 64-bit system you can run either 32-bit or 64-bit but all of the pieces must be 32-bit or 64-bit.&#160; You can’t mix and match the bitness.</p>  <p><strong><font size="3">The Problem        <br /></font></strong>When programming with .Net and using a COM component, it’s somewhat transparent that there is an interop assembly involved.&#160; When you reference the COM component into your project, Visual Studio automatically creates the interop behind the scenes.&#160; The problem is that it’s creating a 32-bit compatible interop.&#160; If you’re creating a 32-bit application, then everything is fine, but for a 64-bit application it’s not going to work.</p>  <p>I found the problem by doing some research on the web and discovering <a href="http://connect.microsoft.com/VisualStudio/feedback/details/711406/tlbimp-error-since-vs2010-a-single-valid-machine-type-compatible-with-the-input-type-library-must-be-specified">this article</a> on a Microsoft support site that gave me the clue I needed.&#160; It also indicates that this is fixed in VS 11.</p>  <p><font size="3"><strong>The Fix        <br /></strong></font>Here’s the fix that I’m using to get this to work.&#160; You need to manually create the interop for the thumbnail viewer component.&#160; By manually creating it, you can specify the machine type that it’s compatible with.&#160; In this case either “x64” or “Agnostic” will work because at runtime on an x64 machine they will both result in true X64 machine code.</p>  <p style="line-height: 140%; font-family: courier new; background: #eeeeee; color: black; font-size: 8pt">TlbImp.exe InventorThumbnailView.dll    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; /machine:Agnostic&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; /namespace:InventorThumbnailViewLib     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; /out:Interop.InventorThumbnailView.dll</p>  <p>Here’s a <a href="http://modthemachine.typepad.com/CreateInteropCommandLine.txt">link to a text file</a> that has the complete command line, with the full paths, so you can just copy and past this into a DOS command window.&#160; You will need to edit the path for the output interop dll to where your project is.</p>  <p>Once you’ve created the interop, Use the References command in Visual Studio to reference it into your project.&#160; Use the Browse tab on the References dialog so you can browse and select the interop dll.&#160; You’ll reference this instead of the InventorThumbNailView.dll file.&#160; Now it should all work.&#160; </p>  <p>Below is some code from a very simple Windows Forms project that I created.&#160; After creating the new project, I added a picture box control (with the SizeMode property set to “StretchImage”) and a button to the dialog.&#160; I also added an open file dialog.&#160; Finally, I added a reference to the .Net component “stdole”.&#160; Below is the code that’s contained within the Click event of the button.&#160; It uses the file dialog to get the filename of an Inventor file, uses the thumbnail view component to get the thumbnail from the Inventor file and then displays it.&#160; The component returns the image as an IPictureDisp object.&#160; Next, it converts this object to a .Net Image object, which it finally assigns to the picture box.&#160; See below for some more discussion about this conversion process.</p>  <p style="line-height: 140%; font-family: courier new; background: #eeeeee; color: black; font-size: 8pt"><strong><font color="#0000ff">' Code in the button Click event.</font></strong>     <br />With OpenFileDialog1     <br />&#160;&#160;&#160; .Filter = &quot;Inventor Files (*.ipt;*.iam;*.idw)|*.ipt;*.iam;*.idw&quot;     <br />&#160;&#160;&#160; If .ShowDialog() = System.Windows.Forms.DialogResult.OK Then     <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Create an instance of the thumbnail viewer component.        <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim thumbviewer As New _     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; InventorThumbnailViewLib.ThumbnailProvider     <br />    <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Use the component to get the thumbnail.        <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim pic As stdole.IPictureDisp = Nothing     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim handle As Long = 0     <br />    <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Use workaround to make sure handle is a positive number.        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Otherwise the call to PictureDispToImage will fail.         <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Do     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pic = thumbviewer.GetThumbnail(.FileName)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; handle = pic.Handle     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Loop While handle &lt; 0     <br />    <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Convert the IPictureDisp into an Image to&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' display it in the picture box.         <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim img As Image = AxHostConverter.PictureDispToImage(pic)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; PictureBox1.Image = img     <br />&#160;&#160;&#160; End If     <br />End With     <br /></p>  <p>The object that represents a bitmap image in COM is an IPictureDisp object, (which is defined in the stdole library).&#160; .Net represents a bitmap image using the Image object.&#160; This means there needs to be a conversion from an IPictureDisp objet to an Image object to be able to use the returned bitmap in .Net.&#160; There is a Visual Basic compatibility library that contains routines to do this.&#160; Unfortunately, if you use them with .Net 4, you’ll get a warning message that these functions are obsolete and are only supported on 32-bit.&#160; You can read more here: <a title="http://go.microsoft.com/fwlink/?linkid=160862" href="http://go.microsoft.com/fwlink/?linkid=160862">http://go.microsoft.com/fwlink/?linkid=160862</a>.</p>  <p>To avoid these warnings and possible problems in the future you’ll need to use something else.&#160; Unfortunately, Microsoft hasn’t provided a simple alternative.&#160; Below is a class that exposes some functions to do this conversion from one type to the other.&#160; I wraps some internal functionality on another Microsoft class to it can be used in a general way.&#160; To use it in your project, just copy the class below into your project.&#160; The PictureDispToImage function defined in this AxHostConverter class is used in the code above.</p>  <p>There’s also some funny code in the example above that’s a workaround to a problem I found while testing.&#160; When testing, it would periodically fail to do the conversion.&#160; The failure seemed random with a “A generic error occurred in GDI+” failure.&#160; I accidentally discovered that the failure was occurring whenever the Windows handle being provided by the IPictureDisp object was negative.&#160; The workaround I put in the code above keeps getting an new IPictureDisp until the handle is a positive number.&#160; I stress tested this through several thousand iterations and the most it ever looped to get a positive number was 10, so I think the chance of this being an endless loop is too small to worry about.&#160; About 85% the first return is positive, another 10% took two calls, and the remaining 5% is 3 or more calls.&#160; I believe the cause of this problem is that the number is actually an unsigned int, but it’s being treated as a regular int which results in a negative number for large numbers.&#160; Anyway, this seems to work around the problem.</p>  <p style="line-height: 140%; font-family: courier new; background: #eeeeee; color: black; font-size: 8pt"><strong><font color="#0000ff">' Utility class that provides support for converting between       <br /><strong><font color="#0000ff">' IPictureDisp and Image objects.</font></strong></font></strong>    <br />Friend Class AxHostConverter     <br />&#160;&#160;&#160; Inherits AxHost     <br />    <br />&#160;&#160;&#160; Private Sub New()     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MyBase.New(&quot;&quot;)     <br />&#160;&#160;&#160; End Sub     <br />    <br />&#160;&#160;&#160; Public Shared Function ImageToPictureDisp( _     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ByVal objImage As Image) As stdole.IPictureDisp     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Return DirectCast(GetIPictureDispFromPicture(objImage), _     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stdole.IPictureDisp)     <br />&#160;&#160;&#160; End Function     <br />    <br />&#160;&#160;&#160; Public Shared Function PictureDispToImage( _     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ByVal pictureDisp As stdole.IPictureDisp) As Image     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim objPicture As System.Drawing.Image     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; objPicture = CType(GetPictureFromIPicture(pictureDisp), _     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.Drawing.Image)     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Return objPicture     <br />&#160;&#160;&#160; End Function     <br />End Class</p> One final thing to remember is that you’ll need to deliver the interop with your program.&#160; Your program has two dependencies which you’ll need to deliver in addition to your exe; the thumbnail view component, (which also needs to be registered), and the interop dll.

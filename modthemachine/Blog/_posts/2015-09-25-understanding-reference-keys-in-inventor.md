---
layout: "post"
title: "Understanding Reference Keys in Inventor"
date: "2015-09-25 19:53:33"
author: "Adam Nagy"
categories:
  - "Attributes"
  - "Brian"
  - "Inventor"
original_url: "https://modthemachine.typepad.com/my_weblog/2015/09/understanding-reference-keys-in-inventor.html "
typepad_basename: "understanding-reference-keys-in-inventor"
typepad_status: "Publish"
---

<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401bb0877f799970d-pi"><img title="RefKeys01" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: right; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="RefKeys01" src="/assets/image_999172.jpg" width="234" align="right" height="156" /></a>Reference keys is a topic that not many people know about or understand and is an area I’ve seen people struggle with and misuse. Reference keys are not something you’ll use often in your programs but can be very handy in certain cases.</p>  <p>&#160;</p>  <p><strong><font size="5">What is a Reference Key?        <br /></font></strong>A reference key is the ID of an object within Inventor. You use the GetReferenceKey method of an object to get its ID, or “key”. You save the ID and at a later time use it to get the same object back. A reference key doesn’t have any time limits, which means you can get the reference key from an object, and the document can go through many changes and versions, and you can still use the reference key to find the same object, even though the object may have changed from when you originally got its reference key. Of course, this assumes the object still exists and hasn’t been deleted or removed through some edit operation.</p>  <p>Below is some sample code that gets the reference key from a selected assembly occurrence. By changing the selection filter the code below will work with any object that supports reference keys except for B-Rep objects (SurfaceBody, FaceShell, Face, Edge, Vertex, EdgeLoop, and EdgeUse) which are discussed later.</p>  <div style="font-size: 9pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%">   <p>Public Sub GetRefKey()      <br /><b><i><font color="#0000ff">&#160;&#160;&#160; ' Get the active document.            <br />&#160;&#160;&#160; </font></i></b>Dim doc As Document       <br />&#160;&#160;&#160; Set doc = ThisApplication.ActiveDocument       <br />      <br />&#160;&#160;&#160; <b><i><font color="#0000ff">' Have an object selected.</font>           <br />&#160;&#160;&#160; </i></b>Dim selection As Object       <br />&#160;&#160;&#160; Set selection = ThisApplication.CommandManager.Pick( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; kAssemblyOccurrenceFilter, _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Select an occurrence.&quot;)       <br />      <br /><b><i><font color="#0000ff">&#160;&#160;&#160; ' Get a reference key from the selected entity. This will            <br /></font></i></b><b><i><font color="#0000ff">&#160;&#160;&#160; ' fail if the selected object doesn't support reference keys.            <br /></font>&#160;&#160;&#160; </i></b>Dim refKey() As Byte       <br />&#160;&#160;&#160; Call selection.GetReferenceKey(refKey)       <br />      <br /><font color="#0000ff">&#160;&#160;&#160; </font><b><i><font color="#0000ff">' Convert the reference key to a string to make saving it easier.            <br /></font>&#160;&#160;&#160; </i></b>Dim strKey As String       <br />&#160;&#160;&#160; strKey = doc.ReferenceKeyManager.KeyToString(refKey)       <br />      <br /><font color="#0000ff">&#160;&#160;&#160; </font><b><i><font color="#0000ff">' Print out the reference key string.            <br /></font>&#160;&#160;&#160; </i></b>Debug.Print &quot;RefKey: &quot;&quot;&quot; &amp; strKey &amp; &quot;&quot;&quot;&quot;       <br />End Sub</p> </div>  <p>   <br />There are a couple of interesting things to note in the above sample. First, a reference key is an array of bytes. A byte is a number between 0 and 255 so a reference key is just a list of small numbers. Second, Inventor creates the reference key and returns it but it’s up to you to save it somewhere so you can use it later. If you’ll be writing out the reference key to a file it’s easier to deal with a String instead of an array of numbers. The KeyToString method does this for you by converting the array of bytes into a String. Later, when you need to use the key, you can use the StringToKey method to convert the String back into an array of bytes.&#160; The sample above just prints the result to the immediate window, which in my test resulted in: “AgEBAAQAAAABAAAA”.</p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d15da607970c-pi"><img title="RefKeys03" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: right; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="RefKeys03" src="/assets/image_115979.jpg" width="176" align="right" height="55" /></a>General reference key functionality is exposed through the ReferenceKeyManager object which is obtained from a Document object. Every object that supports reference keys has the GetReferenceKey method.</p>  <p>Now that you have a reference key you can use it at any time, with the same document, to get back the same object. The sample below demonstrates this.</p>  <div style="font-size: 9pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%">   <p>Public Sub BindRefKey()      <br />&#160;&#160;&#160; <strong><font color="#0000ff">' Get the active document.</font></strong>       <br />&#160;&#160;&#160; Dim doc As Document       <br />&#160;&#160;&#160; Set doc = ThisApplication.ActiveDocument       <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; <strong><font color="#0000ff">' Convert the string back into an array of bytes.</font></strong>       <br />&#160;&#160;&#160; Dim refKey() As Byte       <br />&#160;&#160;&#160; Call doc.ReferenceKeyManager.StringToKey(&quot;AgEBAAQAAAABAAAA&quot;, _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; refKey)</p>    <p>&#160;&#160;&#160; <font color="#0000ff"><strong>' Bind the key back to the object.</strong></font>       <br />&#160;&#160;&#160; Dim obj As Object       <br />&#160;&#160;&#160; Set obj = doc.ReferenceKeyManager.BindKeyToObject(refKey)       <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; <font color="#0000ff"><strong>' Select the object to be able to see the found object.</strong></font>       <br />&#160;&#160;&#160; doc.SelectSet.Clear       <br />&#160;&#160;&#160; Call doc.SelectSet.Select(obj)       <br />End Sub</p> </div>  <p>&#160;</p> <strong><font size="3"><font size="5">Basic Reference Key Workflow</font>&#160; <br /></font></strong>The concept of a reference key is fairly simple. The steps are:   <ol>   <li>Get a reference key from an object. </li>    <li>Save the reference key. </li>    <li>Use the reference key at a later time to get back the same object. </li> </ol>  <p>&#160;</p>  <p><strong><font size="5">Common Problems        <br /></font></strong>There are a few gotchas to be aware of that I’ve seen people struggle with before.</p>  <ul>   <li>A reference key is only good with the same document you originally got it from. </li>    <li>You should ignore the actual value of a reference key. You shouldn’t compare reference keys themselves to check if two reference keys came for the same object. It’s possible that reference keys with different values will bind back to the same object. Because of this you should always bind both reference keys back to their objects and then compare the objects to see if they’re the same. </li>    <li>You must use a reference key context when working with B-Rep entities. This is discussed below. It’s not needed with other types of objects. </li> </ul>  <p>&#160;</p>  <p><strong><font size="4"><font size="5">B-Rep Entities and Reference Keys</font>         <br /></font></strong>When using reference keys with B-Rep entities the concepts shown above still apply but there is some additional work that you need to do. B-Rep entities don’t have a simple internal identifier like other objects. It’s much more complicated for Inventor to be able to find a specific B-Rep entity because they can go through significant changes as modeling operations are performed. A way to visualize how Inventor can find a specific B-Rep entity is to think of the reference key as a set of instructions that identify a particular entity. For example a specific edge might be identified as the intersection of two faces and the faces might be identified by which sketch line was used to create that face as part of an extrusion. Because of the large amount of information that could be in these instructions, a reference key to a B-Rep entity can be quite large. In order to minimize the size of B-Rep reference keys and also improve performance, the idea of a <i>reference key context</i> was introduced. You can think of the context as a table where the instructions are saved. Several reference keys might use one or more of the same instructions.&#160; Having this information in a table allows individual instructions to be re-used. What this means is that a B-Rep reference key isn’t the full set of instructions but is a set of references into this table. This significantly reduces the size of each reference key.</p>  <p>Here is the process of using reference keys for a B-Rep entity, where the new steps are in bold.</p>  <ol>   <li><strong>Create a reference key context.</strong> </li>    <li>Ask an object for its reference key and also <strong>providing the key context</strong>. </li>    <li>Continue to get reference keys from other objects, <strong>using the same key context</strong>. </li>    <li>Save the reference keys. </li>    <li><strong>Save the key context</strong>. </li>    <li>Use the reference key <strong>and the key context</strong> at a later time to get back the same object. </li> </ol>  <p>The process is essentially the same as described above for non B-Rep entities except for when you ask an object for a reference key or bind back a reference key to an object you also need to provide the key context. The program below is similar to the previous sample except it works for B-Rep entities.</p>  <div style="font-size: 9pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%">   <p>Public Sub GetBRepRefKey()      <br />&#160;&#160;&#160; <strong><font color="#0000ff">' Get the active document.</font></strong>       <br />&#160;&#160;&#160; Dim doc As Document       <br />&#160;&#160;&#160; Set doc = ThisApplication.ActiveDocument       <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; <strong><font color="#0000ff">' Have a face and edge selected.</font></strong>       <br />&#160;&#160;&#160; Dim selFace As Face       <br />&#160;&#160;&#160; Set selFace = ThisApplication.CommandManager.Pick( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; kPartFaceFilter, &quot;Select face.&quot;)       <br />&#160;&#160;&#160; Dim selEdge As Edge       <br />&#160;&#160;&#160; Set selEdge = ThisApplication.CommandManager.Pick( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; kPartEdgeFilter, &quot;Select edge.&quot;)</p>    <p>&#160;&#160;&#160; <font color="#0000ff"><strong>' Set a reference to the ReferenceKeyManager object.</strong></font>       <br />&#160;&#160;&#160; Dim refKeyMgr As ReferenceKeyManager       <br />&#160;&#160;&#160; Set refKeyMgr = doc.ReferenceKeyManager</p>    <p>&#160;&#160;&#160; <font color="#0000ff"><strong>' Create a key context.</strong></font>       <br />&#160;&#160;&#160; Dim keyContext As Long       <br />&#160;&#160;&#160; keyContext = refKeyMgr.CreateKeyContext       <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; <font color="#0000ff"><strong>' Get reference keys from the selected entities.</strong></font>       <br />&#160;&#160;&#160; Dim faceRefKey() As Byte       <br />&#160;&#160;&#160; Call selFace.GetReferenceKey(faceRefKey, keyContext)       <br />&#160;&#160;&#160; Dim edgeRefKey() As Byte       <br />&#160;&#160;&#160; Call selEdge.GetReferenceKey(edgeRefKey, keyContext)</p>    <p><strong><font color="#0000ff">&#160;&#160;&#160; ' Get the key context as an array of bytes and          <br />&#160;&#160;&#160; ' convert it to a string.           <br /></font></strong>&#160;&#160;&#160; Dim contextArray() As Byte       <br />&#160;&#160;&#160; Call refKeyMgr.SaveContextToArray(keyContext, contextArray)       <br />&#160;&#160;&#160; Dim strContext As String       <br />&#160;&#160;&#160; strContext = refKeyMgr.KeyToString(contextArray)       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Convert the reference keys to strings to make saving it easier.          <br /></strong></font>&#160;&#160;&#160; Dim strFaceKey As String       <br />&#160;&#160;&#160; strFaceKey = doc.ReferenceKeyManager.KeyToString(faceRefKey)       <br />&#160;&#160;&#160; Dim strEdgeKey As String       <br />&#160;&#160;&#160; strEdgeKey = doc.ReferenceKeyManager.KeyToString(edgeRefKey)       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Save the results to a file.          <br /></strong></font>&#160;&#160;&#160; Open &quot;C:\Temp\RefKeys.txt&quot; For Output As #1       <br />&#160;&#160;&#160; Print #1, strContext       <br />&#160;&#160;&#160; Print #1, strEdgeKey       <br />&#160;&#160;&#160; Print #1, strFaceKey       <br />&#160;&#160;&#160; Close #1       <br />End Sub</p> </div>  <p>&#160;</p>  <p>You may have noticed in the last sample that the variable used for the key context is typed as a Long. Of course, this value isn’t the key context table but is a pointer to the context. Whenever a key context is needed you pass the pointer to the context and when you create a context, a pointer is returned for you to use. When you save the key context along with the reference keys you need to save the full table, not the pointer. The SaveContextToArray method returns an array of bytes that is the full table. This is the data that you need to save, along with any reference keys that were created. The code below binds back to the B-Rep entities.</p>  <div style="font-size: 9pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%">   <p>Public Sub BindBRepRefKey()      <br /><strong><font color="#0000ff">&#160;&#160;&#160; ' Get the active document.          <br /></font></strong>&#160;&#160;&#160; Dim doc As Document       <br />&#160;&#160;&#160; Set doc = ThisApplication.ActiveDocument       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Get a reference to the reference key manager.          <br /></strong></font>&#160;&#160;&#160; Dim refKeyMgr As ReferenceKeyManager       <br />&#160;&#160;&#160; Set refKeyMgr = doc.ReferenceKeyManager       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Read the reference key strings from the file.          <br /></strong></font>&#160;&#160;&#160; Dim context As String       <br />&#160;&#160;&#160; Dim edgeKey As String       <br />&#160;&#160;&#160; Dim faceKey As String       <br />&#160;&#160;&#160; Open &quot;C:\Temp\RefKeys.txt&quot; For Input As #1       <br />&#160;&#160;&#160; Line Input #1, context       <br />&#160;&#160;&#160; Line Input #1, edgeKey       <br />&#160;&#160;&#160; Line Input #1, faceKey       <br />&#160;&#160;&#160; Close #1       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Convert the string to byte arrays.          <br /></strong></font>&#160;&#160;&#160; Dim edgeRefKey() As Byte       <br />&#160;&#160;&#160; Dim faceRefKey() As Byte       <br />&#160;&#160;&#160; Dim contextArray() As Byte       <br />&#160;&#160;&#160; Call refKeyMgr.StringToKey(edgeKey, edgeRefKey)       <br />&#160;&#160;&#160; Call refKeyMgr.StringToKey(faceKey, faceRefKey)       <br />&#160;&#160;&#160; Call refKeyMgr.StringToKey(context, contextArray)</p>    <p><font color="#0000ff"><strong>&#160;&#160;&#160; ' Create the context by loading the data.          <br /></strong></font>&#160;&#160;&#160; Dim refKeyContext As Long       <br />&#160;&#160;&#160; refKeyContext = refKeyMgr.LoadContextFromArray(contextArray)       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Bind back the face and edge.          <br /></strong></font>&#160;&#160;&#160; Dim foundFace As Face       <br />&#160;&#160;&#160; Dim foundEdge As Edge       <br />&#160;&#160;&#160; Set foundFace = refKeyMgr.BindKeyToObject(faceRefKey, _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; refKeyContext)       <br />&#160;&#160;&#160; Set foundEdge = refKeyMgr.BindKeyToObject(edgeRefKey, _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; refKeyContext)       <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Highlight the found entities.          <br /></strong></font>&#160;&#160;&#160; doc.SelectSet.Clear       <br />&#160;&#160;&#160; doc.SelectSet.Select foundFace       <br />&#160;&#160;&#160; doc.SelectSet.Select foundEdge       <br />End Sub</p> </div>  <p>&#160;</p>  <p><b><font size="5">Differences with B-Rep Entities when Binding Back        <br /></font></b>There’s a difference when binding back B-Rep entities from other types of entities. The BindKeyToObject method can return an ObjectCollection in the case where the original B-Rep entity has been split into two or more pieces. The picture below shows the progression of a model and the changes that can take place to a face. In the last step face 2 is split into two pieces by an extrude feature. When binding back, both faces will be returned in an ObjectCollection.</p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401bb0877f7a1970d-pi"><img title="RefKeys02" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="RefKeys02" src="/assets/image_706475.jpg" width="488" height="192" /></a></p>  <p>Below is some modified code from the sample above that handles this case. When multiples are returned the first one in the collection is considered the “best” match with no priority for the rest of the entities.</p>  <div style="font-size: 9pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%">   <p><font color="#0000ff"><strong>' Bind back the face and edge.</strong></font>       <br />Dim foundFaces As Object       <br />Dim foundEdges As Object       <br />Set foundFaces = refKeyMgr.BindKeyToObject(faceRefKey, refKeyContext)       <br />Set foundEdges = refKeyMgr.BindKeyToObject(edgeRefKey, refKeyContext)</p>    <p><font color="#0000ff"><strong>' Highlight the found entities, special casing for the case where          <br />' more than one might have been returned</strong></font>       <br />doc.SelectSet.Clear       <br />If TypeOf foundFaces Is ObjectCollection Then       <br />&#160;&#160;&#160; Dim obj As Object       <br />&#160;&#160;&#160; For Each obj In foundFaces       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; doc.SelectSet.Select obj       <br />&#160;&#160;&#160; Next       <br />Else       <br />&#160;&#160;&#160; doc.SelectSet.Select foundFaces       <br />End If </p> </div>  <br />  <p><strong><font size="5">Important Points        <br /></font></strong>Here are a few points that I want to emphasize when using reference keys with B-Rep entities.</p>  <ul>   <li>A single context can be used, and is intended to be used, for multiple reference keys.&#160; That’s the reason that the concept of the reference key context was created; so that multiple keys can share the same set of instructions for finding specific entities. </li>    <li>A reference key context and reference keys will only work with the same document they were originally obtained from. </li>    <li>Reference keys will only work with the same reference key context they were originally created with. </li>    <li>When working with B-Rep entities, write code that can handle the return of either a single object or an ObjectCollection. </li>    <li>The BindKeyToObject method can fail if the entity is not available.&#160; The CanBindKeyToObject method can be used to first check to see if the key can bind back. </li> </ul>  <p>&#160;</p>  <p><strong><font size="5">Why Use Reference Keys?        <br /></font></strong>An expected question at this point might be why would anyone want to use reference keys? They’re a generic tool that can be used in many ways but here are some examples.</p>  <p><b>Support associativity in an external read-only application      <br /></b>This is one of the more common uses of reference keys. Applications are able to use Apprentice to read B-Rep data and display the model in their application. When the user selects geometry in their applications they’re able to get the corresponding geometry in Apprentice and get the reference key. For example, the geometry might used for a tool path or to position a load or constraint for analysis. Getting reference keys from objects does not require write access to the model. When the model is edited in Inventor they can read in the new geometry and use the reference keys to find the geometry and update their data if the geometry has changed.</p>  <p><b>Maintaining a reference over a re-compute      <br /></b>This is one of the more common general uses of the functionality. An example of this is if you want to write a program that finds all of the circular planar faces in a model and places a hole feature at the center of each one. The first part of your programs finds all of the circular planar faces and then it begins placing holes on each one. The problem is that any references to B-Rep entities are no longer valid after any change has been made to the model. Creating the first hole invalidated all of the references you have to the circular faces. You don’t want to do the analysis again to find circular faces because you’ve potentially added new circular faces by placing the new feature.</p>  <p>Reference keys can help you solve this. Instead of maintaining a reference to a Face object you can get the reference key of each circular planar face. Reference keys are still valid after a compute, so after you create the first hole you can find the next circular planar face by using the saved reference key.</p>  <p><b>Attributes      <br /></b>Attributes can be used in some cases to solve the same issues that reference keys do by providing a way of adding information to an object to find it later. Attributes have the advantage that they’re self-contained and you don’t have to save any information. They also have the advantage of supporting a more powerful search mechanism. They have the disadvantage that they require write access to the file and will require the document to be saved. They also have the disadvantage that they don’t return multiple objects in the case where B-Rep entities have been split.</p>  <p>&#160;</p> <strong><font size="5">What Are Transient Keys?      <br /></font></strong>There’s one more thing that I want to quickly touch on, which is <i>transient keys</i>. Transient key functionality is only available with B-Rep entities. Each of the B-Rep entities supports the TransientKey property which returns a Long value. This is a simple identifier for that specific B-Rep entity. You can bind back to the B-Rep entity with the transient key using the BindTransientKeyToObject method on the SurfaceBody object. This is much simpler than reference keys because it’s just a single Long and you don’t need a key context. However, there’s a BIG limitation with transient keys. They’re only good as long as the model has not been modified. They’re similar to a live reference to a B-Rep entity in that it doesn’t survive through a model compute.   <p>The purpose of transient keys is to provide the ability to match up B-Rep entities when copying bodies. For example, the AlternateBody property of the SurfaceBody returns a copy of the body it was called on. The new body may even be slightly different than the original body, (for example, some faces may have been split into two). The new body has transient keys that you can get from each B-Rep entity. You can use the BindTransientKeyToObject method to find the equivalent B-Rep entity on the original body. It’s also possible to write out a body as SAT where the transient keys are also output as attributes on the SAT data. This again allows you to match up the B-Rep entities from this output model to the original Inventor model, <u>as long as the model has not been edited</u> since the copy was created.</p>  <p>-Brian</p>

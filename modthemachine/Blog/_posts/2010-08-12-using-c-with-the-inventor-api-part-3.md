---
layout: "post"
title: "Using C# with the Inventor API (Part 3)"
date: "2010-08-12 18:46:02"
author: "Adam Nagy"
categories:
  - "Brian"
original_url: "https://modthemachine.typepad.com/my_weblog/2010/08/using-c-with-the-inventor-api-part-3.html "
typepad_basename: "using-c-with-the-inventor-api-part-3"
typepad_status: "Publish"
---

<p>Here’s my third installment on some of the differences between VBA and C# that you’ll encounter when using C# to program Inventor’s API.&#160; Here are links to the <a href="http://modthemachine.typepad.com/my_weblog/2010/07/using-c-with-the-inventor-api-part-1.html">first</a> and <a href="http://modthemachine.typepad.com/my_weblog/2010/08/using-c-with-the-inventor-api-part-2.html">second</a> posts.</p>  <p><strong><em><font size="3">Optional Arguments</font></em></strong>&#160; <br />Previous to C# 2010, C# didn’t support optional arguments so you need to provide every argument in a method call.&#160; If you’re already working with C# 2010 then you can ignore this section.</p>  <p>The thing that makes handling optional arguments in C# difficult is figuring out what value you need to supply to get the same default behavior as you would in another language that supports optional arguments.</p>  <p>Here’s one example using the Documents.Add method.&#160; If you look at this using the Object Browser in C# you won’t get much help in determine what values to provide for the optional arguments, since in C# they aren’t optional.</p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc688340133f306b79b970b-pi"><img title="CSharp2008ObjectBrowser" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="255" alt="CSharp2008ObjectBrowser" src="/assets/image_778557.jpg" width="454" border="0" /></a> </p>  <p>If you have Visual Studio, the Visual Basic Object Browser is a good way to determine what the expected input is.&#160; The Documents.Add method is shown below and its signature appears at the bottom of the browser.&#160; The first argument specifying the document type doesn’t have a default value and must always be supplied.&#160; The second argument specifying the template is optional, and defaults to an empty String.&#160; The third value is also optional Boolean and defaults to True.    <br />    <br /><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc688340133f306b7ba970b-pi"><img title="VB2008ObjectBrowser" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="222" alt="VB2008ObjectBrowser" src="/assets/image_573399.jpg" width="454" border="0" /></a></p>  <p>   <br />Here are examples of VBA and C# code calling the Documents.Add method where the desire is to take the default values for the optional arguments.</p>  <p><em>VBA</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; Dim doc As Document    <br />&#160;&#160;&#160; Set doc = ThisApplication.Documents.Add(kPartDocumentObject) </div>  <p></p>  <p><em>C#</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; Document doc;    <br />&#160;&#160;&#160; doc = invApp.Documents.Add(DocumentTypeEnum.kPartDocumentObject,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;&quot;, true); </div>  <p>The other case you’ll run into are arguments where the default value in Visual Basic is Nothing.&#160; This is demonstrated in the AssemblyConstraints.AddMate method where the last two arguments default to Nothing, as shown below.&#160; </p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc688340134862a3c7e970c-pi"><img title="VBObjectBrowserMate" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="197" alt="VBObjectBrowserMate" src="/assets/image_531122.jpg" width="454" border="0" /></a> </p>  <p>In C#, instead of Nothing you can use Type.Missing, as shown in the code below.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">MateConstraint mate;    <br />mate = asmDef.Constraints.AddMateConstraint(face1, face2, 0,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; InferredTypeEnum.kNoInference,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; InferredTypeEnum.kNoInference,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Type.Missing, Type.Missing); </div>  <p><strong><em><font size="3">Casting</font></em></strong>     <br />When making variable assignments, VBA and Visual Basic will automatically cast from one type to another when it’s possible.&#160; C# doesn’t do this automatically so you have to explicitly cast variables.&#160; Here’s some VBA code demonstrating the complete sample from above that places a mate constraint.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>Public Sub AddMate()      <br />&#160;&#160;&#160; Dim asmDoc As AssemblyDocument       <br />&#160;&#160;&#160; Set asmDoc = ThisApplication.ActiveDocument       <br />&#160;&#160;&#160; Dim asmDef As AssemblyComponentDefinition       <br />&#160;&#160;&#160; Set asmDef = asmDoc.ComponentDefinition       <br />      <br />&#160;&#160;&#160; Dim face1 As face       <br />&#160;&#160;&#160; Set face1 = ThisApplication.CommandManager.Pick( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SelectionFilterEnum.kPartFacePlanarFilter, _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Select planar face 1.&quot;)       <br />&#160;&#160;&#160; Dim face2 As face       <br />&#160;&#160;&#160; Set face2 = ThisApplication.CommandManager.Pick( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SelectionFilterEnum.kPartFacePlanarFilter, _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Select planar face 2.&quot;) </p>    <p>&#160;&#160;&#160; Dim mate As MateConstraint      <br />&#160;&#160;&#160; Set mate = asmDef.Constraints.AddMateConstraint(face1, face2, 0)       <br />End Sub</p> </div>  <p>Here’s the equivalent code in C#.&#160; There are several casts required to get this code to work.&#160; The casts are needed because those calls are typed to return a value different than the variable it’s being assigned to.&#160; For example, the Application.ActiveDocument property is typed to return an object of type Document and it’s being assigned to a variable typed as AssemblyDocument.&#160; Visual Basic and VBA handle this conversion automatically.&#160; In C# you need to tell it the conversion type by adding the <font face="Courier New">(AssemblyDocument)</font> cast.&#160; The same thing is required with the Pick method which is typed to return an Object.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>AssemblyDocument asmDoc = (AssemblyDocument)invApp.ActiveDocument;      <br />AssemblyComponentDefinition asmDef = asmDoc.ComponentDefinition; </p>    <p>Face face1 = (Face)invApp.CommandManager.Pick(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SelectionFilterEnum.kPartFacePlanarFilter,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Select planar face 1.&quot;);       <br />Face face2 = (Face)invApp.CommandManager.Pick(       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SelectionFilterEnum.kPartFacePlanarFilter,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Select planar face 2.&quot;); </p>    <p>MateConstraint mate;      <br />mate = asmDef.Constraints.AddMateConstraint(face1, face2, 0,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; InferredTypeEnum.kNoInference,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; InferredTypeEnum.kNoInference,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Type.Missing, Type.Missing); </p> </div>  <p>Casting problems are typically easy to catch because the error from Visual Studio tells you exactly what the problem is.</p>  <p>&#160;<a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc688340133f306b817970b-pi"><img title="CastingError" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="74" alt="CastingError" src="/assets/image_873549.jpg" width="470" border="0" /></a>     <br />    <br />Here’s another example that isn’t specifically a casting issue but is somewhat related and the easy way to solve the problem is by using casting.&#160; Below is some VBA code that gets the first body in the active part document.&#160; (Remember that a     <br />“ _” (space underscore) identifies a line continuation in Visual Basic.)</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">Dim body As SurfaceBody    <br />Set body = ThisApplication.ActiveDocument. _    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ComponentDefinition.SurfaceBodies.Item(1) </div>  <p></p>  <p>Here’s the same code converted to C#.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>SurfaceBody body;      <br />body = invApp.ActiveDocument.ComponentDefinition.SurfaceBodies[1]; </p> </div>  <p>The above code doesn’t work in C# and results in the error shown below.&#160; This is because the ActiveDocument property returns a Document object, not a PartDocument object, and the Document object does not support the ComponentDefinition property.</p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc688340134862a3c8e970c-pi"><img title="ComponentDefinitionError" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="78" alt="ComponentDefinitionError" src="/assets/image_791711.jpg" width="470" border="0" /></a> </p>  <p>Breaking the line up to first get the PartDocument object, which requires casting, and then using that object to get the body fixes the problem.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>PartDocument partDoc = (PartDocument) invApp.ActiveDocument;      <br />SurfaceBody body = partDoc.ComponentDefinition.SurfaceBodies[1]; </p> </div>  <p><strong><font size="3"><em>Declaring Arrays</em></font></strong>     <br />When you declare an array in VBA it is automatically initialized.&#160; In C# (and VB.Net) declaring an array does not initialize it.&#160; You need to add a bit more to the declaration to cause the initialization.&#160; If you don’t initialize the array you’ll get an error when you pass the array as a method argument. </p>  <p><em>VBA</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; Dim stuff() As Double </div>  <p><em>VB.Net</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; Dim stuff() As Double = {} </div>  <p><em>C#</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; double[] stuff = new double[] {}; </div>  <br /><strong><font size="3"><em>Resizing an Array</em></font></strong>   <br />In VB/VBA you can resize an array and maintain its current contents by using the Redim statement using the Preserve option.&#160; C# can’t dynamically resize an array so to accomplish the equivalent you create a new array of the desired size and copy the original array into it.   <br />  <p><em>VBA</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; Dim newSize As Integer    <br />&#160;&#160;&#160; newSize = 500     <br />&#160;&#160;&#160; Redim Preserve stuff(newSize) </div>  <p><em>C#</em>     <br /></p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; int newSize = 500;</div>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; int[] newStuff = new int[newSize]; </div>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">&#160;&#160;&#160; stuff.CopyTo(newStuff, 0);</div>

---
layout: "post"
title: "Getting the Overall Size of Parts"
date: "2017-06-06 21:12:02"
author: "Adam Nagy"
categories:
  - "Brian"
  - "Fusion 360"
  - "Inventor"
  - "Utilities"
original_url: "https://modthemachine.typepad.com/my_weblog/2017/06/getting-the-overall-size-of-parts.html "
typepad_basename: "getting-the-overall-size-of-parts"
typepad_status: "Publish"
---

<p>The question of getting the size of a part frequently comes up and I wanted to spend some time discussing the existing functionality and other options. The discussion here applies to both Fusion 360 and Inventor (and probably most other CAD systems).</p>
<p><span style="font-size: large;"><strong>What is a Bounding Box?<br /></strong></span>The easiest way to get a size of a part is to get the bounding box (also called the range box) of the object.&#0160; Let’s look at what a bounding box is by looking at some simple 2D examples first.&#0160; A 2D bounding box is a rectangle that encompasses the object. Below is an example of a part (the shaded area) and it’s bounding rectangle (dashed lines).&#0160; If we measured the size of this box I think we would all agree that it looks like an accurate measure of the overall size of the part.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d28a0d49970c-pi"><img alt="Range1" border="0" height="238" src="/assets/image_350392.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="Range1" width="318" /></a></p>
<p>&#0160;</p>
<p>A typical bounding box is defined using just two points; the minimum and maximum points.&#0160; The picture below shows the two 2D points used to define the bounding box. A limitation with defining a bounding box in this way is that the rectangle is oriented such that it’s edges are always parallel to the x and y model axes.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d28a0d4e970c-pi"><img alt="Range2" border="0" height="224" src="/assets/image_207206.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="Range2" width="293" /></a></p>
<p>&#0160;</p>
<p>Below is the same part that has been rotated and its bounding box is displayed. In this case the size of the bounding box probably isn’t what you wanted and in most cases is not particularly usefu<a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b7c8ffef4c970b-pi">l</a>.<a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401bb09a2fd9b970d-pi"><img alt="range3" border="0" height="300" src="/assets/image_60557.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="range3" width="304" /></a></p>
<p>What you probably really wanted was this bounding box but that box can’t be defined by a simple two points and needs additional information to define the orientation.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401bb09a2f82d970d-pi"><img alt="Range4" border="0" height="341" src="/assets/image_584108.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="Range4" width="349" /></a></p>
<p>Bounding boxes aren’t something specific to the Inventor and Fusion 360 API’s but are a basic concept in computer graphics. The usual intent of a bounding box is not to provide a tight fitting, orientated box around a part but instead to provide a very fast box that fits around a certain piece of geometry. The only thing guaranteed is that the object is completely contained within the box and there is no guarantee about how tight the box fits around the object. In many cases, like in the first example, the size of the range box is the same as the physical size of the part but there are cases when this is not the case. Below, on the left, is an example from Inventor where the bounding box is quite a bit larger than the visible part. At first glance this would seem to be a bug in the calculation but the bounding box is including the control polygon of the spline surface, as shown on the right. So it may not be what you want but it is arguably correct and is the simplest for Inventor to calculate.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d28a0d5e970c-pi"><img alt="range5" border="0" height="351" src="/assets/image_153604.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="range5" width="414" /></a></p>
<p>Bounding boxes are intended to be used in more complex operations where you need to first determine if a particular object should be considered in a calculation. To determine if an object should be included you can often use it’s bounding box to see if it’s within the area to be calculated. This is a very simple and fast calculation that can be performed to determine if the object can be eliminated from the more complicated and costly computations.&#0160; Operations with bounding boxes like this are also very simple.&#0160; For example you can combine bounding boxes to create a new box that contains the originals.</p>
<p>The Inventor API has the Box and Box2d objects that are used to pass back the bounding box information and these objects also provide properties and methods to let you work with the box information.&#0160; The Fusion 360 API has the BoundingBox3D and BoundingBox2D objects that provide the equivalent functionality.&#0160; The most important feature of these objects is that they return the coordinates of the min and max points.</p>
<p><span style="font-size: large;"><strong>Getting Accurate Bounding Boxes</strong></span><br />As discussed above, the bounding box returned by the Inventor RangeBox property and returned by the Fusion360 boundingBox property may not be what you need.&#0160; Unfortunately, a bounding box that is always tight fitting to the visible graphics is not currently provided by either Inventor or Fusion 360. However, it is possible to calculate a very close approximation on your own using other API functionality. What I’m going to show you here will create a tight range box but it will still be oriented so it’s parallel to the world XYZ planes. The ability to automatically calculate a bounding box that is oriented to get the tightest fitting box possible is a very difficult problem that I haven’t seen a solution to. It’s something you could probably write a PhD paper on. The easiest approach to the orientation problem is to ask the user for help by lettin them define the coordinate system the bounding box should be calculated in, essentially defining the directions for the length, width and height. That’s possible but a little more than I wanted to go into in this post so I’ll limit this discussion to calculating a tight fitting bounding box that’s oriented parallel to the world XYZ planes.</p>
<p>To do this you can use a triangular mesh representation of the model and calculate your own bounding box by including all of the vertices of the mesh. The result will be as accurate as the mesh. In both Inventor and Fusion 360 you can calculate a mesh representation to any tolerance you want or you can get the existing mesh that Inventor or Fusion 360 is using for the display of the model.&#0160; The actual model is made up of accurate smooth surfaces, but a mesh representation is created and used internally to display the model. Using the existing mesh is faster that calculating a new one but if accuracy is critical you might want to calculate a new mesh. The shape of the model will also affect the accuracy. A model made up entirely of planes will result in an exact mesh representation regardless of the tolerance of the mesh because the triangles exactly represent those faces.&#0160; If a model has any curved surfaces, even as simple as a cylinder, then the mesh is an approximation.&#0160; I’ve tried to illustrate this in the picture below.&#0160; On the left are the original models where one model is made entirely of planes and the other has planes, cylinders, and a sphere.&#0160; On the right is the triangular mesh representations of the two parts.&#0160; The first model is an exact representation because the shape can be exactly represented by the triangles.&#0160; However, the second model has curved surfaces and has to be approximated by the triangles.&#0160; The accuracy of the bounding box you build will depend on their being a triangle vertex at the minimum and maximum X, Y, and Z sizes of the model.&#0160; The more triangles, the more likely you’ll have vertices at those locations but it also means more processing for Inventor or Fusion to calculate the mesh and more processing for you to analyze the mesh to build the range box.&#0160;</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401bb09a2f836970d-pi"><img alt="MeshExample" border="0" height="302" src="/assets/image_567524.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="MeshExample" width="974" /></a></p>
<p>&#0160;</p>
<p>I’ve used the code similar to that below in a few programs I’ve posted previously. The calculateTightBoundingBox function takes in a body and optional tolerance and returns the tight fitting bounding box.&#0160; If no tolerance is provided, the existing display mesh is used. There can be more than one display mesh because Inventor and Fusion will generate different meshes depending on how close you zoom into the model so the display always appears smooth. When using the display mesh, this function will use the highest quality display mesh that exists. If a tolerance is provided, then a new mesh is calculated using that tolerance. There is a test function for each that is used to test the calculateTightBoundingBox function.&#0160; Samples below are provided in Python for Fusion 360 and VBA and Visual Basic for Inventor.&#0160; Below is the result on the previous model where the bounding box returned by Inventor was much larger.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d28a0d63970c-pi"><img alt="NewRange" border="0" height="387" src="/assets/image_699755.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="NewRange" width="493" /></a></p>
<p><span style="font-size: large;"><strong>Fusion 360 Python</strong></span></p>
<pre><span style="color: #0000ff;"># Function to test the calculateTightBoundingBox function.<br /></span>def run(context):<br />&#0160;&#0160;&#0160; ui = None <br />&#0160;&#0160;&#0160; try:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; app = adsk.core.Application.get()<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; ui = app.userInterface<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; des = adsk.fusion.Design.cast(app.activeProduct)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; bodySelect = ui.selectEntity(&#39;Select the body.&#39;, &#39;Bodies&#39;)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; body = adsk.fusion.BRepBody.cast(bodySelect.entity)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># Call the function to get the tight bounding box.<br /></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; bndBox= calculateTightBoundingBox(body)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># Draw the bounding box using a sketch.<br /></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; sk = des.rootComponent.sketches.add(des.rootComponent.xYConstructionPlane)&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines = sk.sketchCurves.sketchLines<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; minXYZ = bndBox.minPoint<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; minXYmaxZ = adsk.core.Point3D.create(bndBox.minPoint.x, bndBox.minPoint.y, bndBox.maxPoint.z)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; minXmaxYZ = adsk.core.Point3D.create(bndBox.minPoint.x, bndBox.maxPoint.y, bndBox.maxPoint.z)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; minXZmaxY = adsk.core.Point3D.create(bndBox.minPoint.x, bndBox.maxPoint.y, bndBox.minPoint.z)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; maxXYZ = bndBox.maxPoint<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; maxXYminZ = adsk.core.Point3D.create(bndBox.maxPoint.x, bndBox.maxPoint.y, bndBox.minPoint.z)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; maxXZminY = adsk.core.Point3D.create(bndBox.maxPoint.x, bndBox.minPoint.y, bndBox.maxPoint.z)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; maxXminYZ = adsk.core.Point3D.create(bndBox.maxPoint.x, bndBox.minPoint.y, bndBox.minPoint.z)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXYZ, minXYmaxZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXYZ, minXZmaxY)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXZmaxY, minXmaxYZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXYmaxZ, minXmaxYZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(maxXYZ, maxXYminZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(maxXYZ, maxXZminY)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(maxXYminZ, maxXminYZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(maxXZminY, maxXminYZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXYZ, maxXminYZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXYmaxZ, maxXZminY)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXmaxYZ, maxXYZ)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; lines.addByTwoPoints(minXZmaxY, maxXYminZ) <br />&#0160;&#0160;&#0160; except:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if ui:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; ui.messageBox(&#39;Failed:\n{}&#39;.format(traceback.format_exc()))</pre>
<p><br /><span style="color: #0000ff;"># Calculates a tight bounding box around the input body.&#0160; An optional<br /># tolerance argument is available.&#0160; This specificies the tolerance in <br /># centimeters.&#0160; If not provided the best existing display mesh is used.</span><br />def calculateTightBoundingBox(body, tolerance = 0):<br />&#0160;&#0160;&#0160; try:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># If the tolerance is zero, use the best display mesh available.</span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if tolerance &lt;= 0:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># Get the best display mesh available.</span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; triMesh = body.meshManager.displayMeshes.bestMesh<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; else:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># Calculate a new mesh based on the input tolerance.<br /></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; meshMgr = adsk.fusion.MeshManager.cast(body.meshManager)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; meshCalc = meshMgr.createMeshCalculator()<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; meshCalc.surfaceTolerance = tolerance<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; triMesh = meshCalc.calculate()<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># Calculate the range of the mesh.</span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt = adsk.core.Point3D.cast(triMesh.nodeCoordinates[0])<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt = adsk.core.Point3D.cast(triMesh.nodeCoordinates[0])<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; vertex = adsk.core.Point3D.cast(None)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; for vertex in triMesh.nodeCoordinates:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if vertex.x &lt; smallPnt.x:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt.x = vertex.x<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if vertex.y &lt; smallPnt.y:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt.y = vertex.y<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if vertex.z &lt; smallPnt.z:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt.z = vertex.z<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if vertex.x &gt; largePnt.x:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt.x = vertex.x<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if vertex.y &gt; largePnt.y:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt.y = vertex.y<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; if vertex.z &gt; largePnt.z:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt.z = vertex.z <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># Create and return a BoundingBox3D as the result.<br /></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; return(adsk.core.BoundingBox3D.create(smallPnt, largePnt))<br />&#0160;&#0160;&#0160; except:<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;"># An error occurred so return None.</span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; return(None)</p>
<p>&#0160;</p>
<p><span style="font-size: large;"><strong>Inventor VBA</strong></span></p>
<pre>Public Sub TestTightBoundingBox()<br />&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Have a body selected.<br /></span>&#0160;&#0160;&#0160; Dim body As SurfaceBody<br />&#0160;&#0160;&#0160; Set body = ThisApplication.CommandManager.Pick(kPartBodyFilter, &quot;Select the body.&quot;)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Call the function to get the tight bounding box.<br /></span>&#0160;&#0160;&#0160; Dim bndBox As Box<br />&#0160;&#0160;&#0160; Set bndBox = calculateTightBoundingBox(body)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Draw the bounding box using a 3D sketch.</span><br />&#0160;&#0160;&#0160; Dim partDoc As PartDocument<br />&#0160;&#0160;&#0160; Set partDoc = ThisApplication.ActiveDocument<br />&#0160;&#0160;&#0160; Dim sk As Sketch3D<br />&#0160;&#0160;&#0160; Set sk = partDoc.ComponentDefinition.Sketches3D.Add()<br />&#0160;&#0160;&#0160; Dim lines As SketchLines3D<br />&#0160;&#0160;&#0160; Set lines = sk.SketchLines3D<br /><br />&#0160;&#0160;&#0160; Dim tg As TransientGeometry<br />&#0160;&#0160;&#0160; Set tg = ThisApplication.TransientGeometry<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim minXYZ As Point<br />&#0160;&#0160;&#0160; Dim minXYmaxZ As Point<br />&#0160;&#0160;&#0160; Dim minXmaxYZ As Point<br />&#0160;&#0160;&#0160; Dim minXZmaxY As Point<br />&#0160;&#0160;&#0160; Set minXYZ = bndBox.MinPoint<br />&#0160;&#0160;&#0160; Set minXYmaxZ = tg.CreatePoint(bndBox.MinPoint.x, bndBox.MinPoint.y, bndBox.MaxPoint.Z)<br />&#0160;&#0160;&#0160; Set minXmaxYZ = tg.CreatePoint(bndBox.MinPoint.x, bndBox.MaxPoint.y, bndBox.MaxPoint.Z)<br />&#0160;&#0160;&#0160; Set minXZmaxY = tg.CreatePoint(bndBox.MinPoint.x, bndBox.MaxPoint.y, bndBox.MinPoint.Z)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim maxXYZ As Point<br />&#0160;&#0160;&#0160; Dim maxXYminZ As Point<br />&#0160;&#0160;&#0160; Dim maxXZminY As Point<br />&#0160;&#0160;&#0160; Dim maxXminYZ As Point<br />&#0160;&#0160;&#0160; Set maxXYZ = bndBox.MaxPoint<br />&#0160;&#0160;&#0160; Set maxXYminZ = tg.CreatePoint(bndBox.MaxPoint.x, bndBox.MaxPoint.y, bndBox.MinPoint.Z)<br />&#0160;&#0160;&#0160; Set maxXZminY = tg.CreatePoint(bndBox.MaxPoint.x, bndBox.MinPoint.y, bndBox.MaxPoint.Z)<br />&#0160;&#0160;&#0160; Set maxXminYZ = tg.CreatePoint(bndBox.MaxPoint.x, bndBox.MinPoint.y, bndBox.MinPoint.Z)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXYZ, minXYmaxZ)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXYZ, minXZmaxY)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXZmaxY, minXmaxYZ)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXYmaxZ, minXmaxYZ)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(maxXYZ, maxXYminZ)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(maxXYZ, maxXZminY)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(maxXYminZ, maxXminYZ)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(maxXZminY, maxXminYZ)<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXYZ, maxXminYZ)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXYmaxZ, maxXZminY)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXmaxYZ, maxXYZ)<br />&#0160;&#0160;&#0160; Call lines.AddByTwoPoints(minXZmaxY, maxXYminZ)<br />End Sub</pre>
<p><br /><span style="color: #0000ff;">&#39; Calculates a tight bounding box around the input body.&#0160; An optional<br />&#39; tolerance argument is available.&#0160; This specificies the tolerance in<br />&#39; centimeters.&#0160; If not provided the best existing display mesh is used.<br /></span>Public Function calculateTightBoundingBox(body As SurfaceBody, Optional Tolerance As Double = 0) As Box<br />&#0160;&#0160;&#0160; On Error GoTo ErrorFound<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim vertCount As Long<br />&#0160;&#0160;&#0160; Dim facetCount As Long<br />&#0160;&#0160;&#0160; Dim vertCoords() As Double<br />&#0160;&#0160;&#0160; Dim normVectors() As Double<br />&#0160;&#0160;&#0160; Dim vertInds() As Long<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; If the tolerance is zero, use the best display mesh available.<br /></span>&#0160;&#0160;&#0160; If Tolerance &lt;= 0 Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Get the best display mesh available.</span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim tolCount As Long<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim tols() As Double<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call body.GetExistingFacetTolerances(tolCount, tols)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim i As Integer<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim bestTol As Double<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; bestTol = tols(0)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; For i = 1 To tolCount - 1<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If tols(i) &lt; bestTol Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; bestTol = tols(i)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call body.GetExistingFacets(bestTol, vertCount, facetCount, vertCoords, normVectors, vertInds)<br />&#0160;&#0160;&#0160; Else<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Calculate a new mesh based on the input tolerance.</span><br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call body.CalculateFacets(Tolerance, vertCount, facetCount, vertCoords, normVectors, vertInds)<br />&#0160;&#0160;&#0160; End If<br /><br />&#0160;&#0160;&#0160; Dim tg As TransientGeometry<br />&#0160;&#0160;&#0160; Set tg = ThisApplication.TransientGeometry<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Calculate the range of the mesh.</span><br />&#0160;&#0160;&#0160; Dim smallPnt As Point<br />&#0160;&#0160;&#0160; Dim largePnt As Point<br />&#0160;&#0160;&#0160; Set smallPnt = tg.CreatePoint(vertCoords(0), vertCoords(1), vertCoords(2))<br />&#0160;&#0160;&#0160; Set largePnt = tg.CreatePoint(vertCoords(0), vertCoords(1), vertCoords(2))<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; For i = 1 To vertCount - 1<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim vertX As Double<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim vertY As Double<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Dim vertZ As Double<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; vertX = vertCoords(i * 3)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; vertY = vertCoords(i * 3 + 1)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; vertZ = vertCoords(i * 3 + 2)<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If vertX &lt; smallPnt.x Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt.x = vertX<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If vertY &lt; smallPnt.y Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt.y = vertY<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If vertZ &lt; smallPnt.Z Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; smallPnt.Z = vertZ<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If vertX &gt; largePnt.x Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt.x = vertX<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If vertY &gt; largePnt.y Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt.y = vertY<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If vertZ &gt; largePnt.Z Then<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; largePnt.Z = vertZ<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If<br />&#0160;&#0160;&#0160; Next<br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; <span style="color: #0000ff;">&#39; Create and return a Box as the result.<br /></span>&#0160;&#0160;&#0160; Set calculateTightBoundingBox = tg.CreateBox()<br />&#0160;&#0160;&#0160; calculateTightBoundingBox.MinPoint = smallPnt<br />&#0160;&#0160;&#0160; calculateTightBoundingBox.MaxPoint = largePnt<br />&#0160;&#0160;&#0160; Exit Function<br />ErrorFound:<br />&#0160;&#0160;&#0160; Set calculateTightBoundingBox = Nothing<br />&#0160;&#0160;&#0160; Exit Function<br />End Function</p>
<p>&#0160;</p>
<p><span style="font-size: large;"><strong>Inventor Visual Basic (iLogic)</strong></span></p>
<pre>Public Sub TestTightBoundingBox()
    Dim invApp As Inventor.Application = GetObject(, &quot;Inventor.Application&quot;)
    &#39; Have a body selected.
    Dim body As SurfaceBody
    body = invApp.CommandManager.Pick(SelectionFilterEnum.kPartBodyFilter, &quot;Select the body.&quot;)

    &#39; Call the function to get the tight bounding box.
    Dim bndBox As Box = calculateTightBoundingBox(body)

    &#39; Draw the bounding box using a 3D sketch.
    Dim partDoc As PartDocument = invApp.ActiveDocument
    Dim sk As Sketch3D = partDoc.ComponentDefinition.Sketches3D.Add()
    Dim lines As SketchLines3D = sk.SketchLines3D

    Dim tg As TransientGeometry = invApp.TransientGeometry

    Dim minXYZ As Point = bndBox.MinPoint
    Dim minXYmaxZ As Point = tg.CreatePoint(bndBox.MinPoint.X, bndBox.MinPoint.Y, bndBox.MaxPoint.Z)
    Dim minXmaxYZ As Point = tg.CreatePoint(bndBox.MinPoint.X, bndBox.MaxPoint.Y, bndBox.MaxPoint.Z)
    Dim minXZmaxY As Point = tg.CreatePoint(bndBox.MinPoint.X, bndBox.MaxPoint.Y, bndBox.MinPoint.Z)

    Dim maxXYZ As Point = bndBox.MaxPoint
    Dim maxXYminZ As Point = tg.CreatePoint(bndBox.MaxPoint.X, bndBox.MaxPoint.Y, bndBox.MinPoint.Z)
    Dim maxXZminY As Point = tg.CreatePoint(bndBox.MaxPoint.X, bndBox.MinPoint.Y, bndBox.MaxPoint.Z)
    Dim maxXminYZ As Point = tg.CreatePoint(bndBox.MaxPoint.X, bndBox.MinPoint.Y, bndBox.MinPoint.Z)

    lines.AddByTwoPoints(minXYZ, minXYmaxZ)
    lines.AddByTwoPoints(minXYZ, minXZmaxY)
    lines.AddByTwoPoints(minXZmaxY, minXmaxYZ)
    lines.AddByTwoPoints(minXYmaxZ, minXmaxYZ)

    lines.AddByTwoPoints(maxXYZ, maxXYminZ)
    lines.AddByTwoPoints(maxXYZ, maxXZminY)
    lines.AddByTwoPoints(maxXYminZ, maxXminYZ)
    lines.AddByTwoPoints(maxXZminY, maxXminYZ)

    lines.AddByTwoPoints(minXYZ, maxXminYZ)
    lines.AddByTwoPoints(minXYmaxZ, maxXZminY)
    lines.AddByTwoPoints(minXmaxYZ, maxXYZ)
    lines.AddByTwoPoints(minXZmaxY, maxXYminZ)
End Sub


&#39; Calculates a tight bounding box around the input body.  An optional
&#39; tolerance argument is available.  This specificies the tolerance in
&#39; centimeters.  If not provided the best existing display mesh is used.
Public Function calculateTightBoundingBox(body As SurfaceBody, Optional Tolerance As Double = 0) As Box
    Try
        Dim vertCount As Integer
        Dim facetCount As Integer
        Dim vertCoords() As Double = {}
        Dim normVectors() As Double = {}
        Dim vertInds() As Integer = {}

        &#39; If the tolerance is zero, use the best display mesh available.
        If Tolerance &lt;= 0 Then
            &#39; Get the best display mesh available.
            Dim tolCount As Long
            Dim tols() As Double = {}
            Call body.GetExistingFacetTolerances(tolCount, tols)
            Dim bestTol As Double
            bestTol = tols(0)
            For i As Integer = 1 To tolCount - 1
                If tols(i) &lt; bestTol Then
                    bestTol = tols(i)
                End If
            Next

            body.GetExistingFacets(bestTol, vertCount, facetCount, vertCoords, normVectors, vertInds)
        Else
            &#39; Calculate a new mesh based on the input tolerance.
            body.CalculateFacets(Tolerance, vertCount, facetCount, vertCoords, normVectors, vertInds)
        End If

        Dim tg As TransientGeometry = body.Application.TransientGeometry

        &#39; Calculate the range of the mesh.
        Dim smallPnt As Point = tg.CreatePoint(vertCoords(0), vertCoords(1), vertCoords(2))
        Dim largePnt As Point = tg.CreatePoint(vertCoords(0), vertCoords(1), vertCoords(2))
        For i As Integer = 1 To vertCount - 1
            Dim vertX As Double = vertCoords(i * 3)
            Dim vertY As Double = vertCoords(i * 3 + 1)
            Dim vertZ As Double = vertCoords(i * 3 + 2)

            If vertX &lt; smallPnt.X Then
                smallPnt.X = vertX
            End If

            If vertY &lt; smallPnt.Y Then
                smallPnt.Y = vertY
            End If

            If vertZ &lt; smallPnt.Z Then
                smallPnt.Z = vertZ
            End If

            If vertX &gt; largePnt.X Then
                largePnt.X = vertX
            End If

            If vertY &gt; largePnt.Y Then
                largePnt.Y = vertY
            End If

            If vertZ &gt; largePnt.Z Then
                largePnt.Z = vertZ
            End If
        Next

        &#39; Create and return a Box as the result.
        Dim newBox As Box = tg.CreateBox()
        newBox.MinPoint = smallPnt
        newBox.MaxPoint = largePnt
        Return newBox
    Catch ex As Exception
        Return Nothing
    End Try
End Function
</pre>
<p>&#0160;</p>
<p>-Brian</p>

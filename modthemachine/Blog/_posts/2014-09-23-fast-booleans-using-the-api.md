---
layout: "post"
title: "Fast Booleans Using the API"
date: "2014-09-23 22:26:16"
author: "Adam Nagy"
categories:
  - "Brian"
  - "Inventor"
  - "Parts"
  - "Visual Basic for Applications (VBA)"
original_url: "https://modthemachine.typepad.com/my_weblog/2014/09/fast-booleans-using-the-api.html "
typepad_basename: "fast-booleans-using-the-api"
typepad_status: "Publish"
---

<p>The Inventor API supports some functionality that’s relatively new (since Inventor 2009) and is not very well known.&#0160; It’s called Transient B-Rep and is accessed through the TransientBRep property on the Application object.&#0160; It supports some relatively simple functionality and also some of the more complicated capabilities provided by the API.&#0160; Luckily you don’t have to understand the complicated in order to use the simple.&#0160;</p>
<p>There was a question on the Inventor Customization Forum recently that asked about being able to quickly perform many Boolean operations on a body by repeatedly moving another body and doing a difference operation.&#0160; They didn’t need the resulting model to have any intelligence (i.e. be parametric) but just needed accurate geometry.&#0160; The TransientBRep object supports functionality that makes this possible.</p>
<p>The Inventor API uses the term <em>Transient</em> to mean data that is not seen or saved in the document.&#0160; It’s data that exists outside of the model.&#0160; The TransientBRep object provides functions that are a very light wrapper over the Autodesk Shape Manager (ASM) modeling core.&#0160; When you create a feature in Inventor, it’s also using ASM to do the actual model computations but it is also doing a lot more work to remember all of the feature input, adding additional information to the resulting model to allow for associativity, creating data in the browser to represent the feature, and updating the graphics to display the modified model.&#0160; Although a key part of the process, the actual modeling is just a piece of all of the work that’s done.&#0160; Using the TransientBRep functionality allows you to do just the modeling work without all of the overhead of creating a standard feature.</p>
<p>I’ve created a small sample to demonstrate the concept and illustrate how to use the API.&#0160; I have a part model that contains two bodies.&#0160; The yellow body will be used as the base or main part material.&#0160; The red part is used as the tool.&#0160; In this case it can be thought of as a punch that will be used to remove material from the base part.&#0160; The punch has been built relative to the model origin, as can be seen by the base work planes.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d06fd15c970c-pi"><img alt="TransBRep1" border="0" height="328" src="/assets/image_155612.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="TransBRep1" width="504" /></a></p>
<p>In addition to the two bodies you can also see several work points that have been created. They’re normal work points except they’ve been named “Punch#”. as shown below. The points are used to specify locations where the tool is to be subtracted from the base.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401bb078af267970d-pi"><img alt="TransBRep2" border="0" height="354" src="/assets/image_829557.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border-width: 0px;" title="TransBRep2" width="224" /></a></p>
<p>When the macro is run it prompts you to select the base and tool bodies and then uses the TransientBrep functionality to create transient copies of those and then performs multiple Boolean operations by moving the tool and subtracting it from the base.&#0160; Finally it creates a base feature using the modified base body and turns off the display of the tool and the base body so the result can be seen, which is shown below.</p>
<p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401b8d06fd167970c-pi"><img alt="TransBRep3" border="0" height="415" src="/assets/image_354378.jpg" style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border: 0px;" title="TransBRep3" width="504" /></a></p>
<p>Below is the sample macro and here is the <a href="http://modthemachine.typepad.com/PunchBooleanExample.ipt">sample part</a> that I used to test it.&#0160; The part is an Inventor 2015 model, but this macro will work in previous versions of Inventor too.</p>
<div style="font-size: 8pt; font-family: courier new; background: #eeeeee; color: black; line-height: 140%;">
<p>Public Sub SampleBoolean() <br />&#0160;&#0160;&#0160; Dim partDoc As PartDocument <br />&#0160;&#0160;&#0160; Set partDoc = ThisApplication.ActiveDocument <br />&#0160;&#0160;&#0160; Dim partDef As PartComponentDefinition <br />&#0160;&#0160;&#0160; Set partDef = partDoc.ComponentDefinition <br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim tg As TransientGeometry <br />&#0160;&#0160;&#0160; Set tg = ThisApplication.TransientGeometry <br />&#0160;&#0160;&#0160; Dim tb As TransientBRep <br />&#0160;&#0160;&#0160; Set tb = ThisApplication.TransientBRep <br />&#0160;&#0160;&#0160; Dim tObjs As TransientObjects <br />&#0160;&#0160;&#0160; Set tObjs = ThisApplication.TransientObjects <br />&#0160;&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Have the bodies selected. <br /></strong></span>&#0160;&#0160;&#0160; Dim baseBody As SurfaceBody <br />&#0160;&#0160;&#0160; Set baseBody = ThisApplication.CommandManager.Pick( _ <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; kPartBodyFilter, _ <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &quot;Select the base body&quot;) <br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim toolBody As SurfaceBody <br />&#0160;&#0160;&#0160; Set toolBody = ThisApplication.CommandManager.Pick( _ <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; kPartBodyFilter, _ <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &quot;Select the tool body&quot;) <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Copy the two bodies to create transient copies. <br /></strong></span>&#0160;&#0160;&#0160; Dim transBase As SurfaceBody <br />&#0160;&#0160;&#0160; Set transBase = tb.Copy(baseBody) <br />&#0160;&#0160;&#0160; Dim transTool As SurfaceBody <br />&#0160;&#0160;&#0160; Set transTool = tb.Copy(toolBody) <br />&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Create a matrix and a point to use in positioning <br />&#0160;&#0160;&#0160; &#39; the punch.&#0160; The matrix is initialized to an identity <br />&#0160;&#0160;&#0160; &#39; matrix the point is (0,0,0). <br /></strong></span>&#0160;&#0160;&#0160; Dim trans As Matrix <br />&#0160;&#0160;&#0160; Set trans = tg.CreateMatrix <br />&#0160;&#0160;&#0160; Dim lastPosition As Point <br />&#0160;&#0160;&#0160; Set lastPosition = tg.CreatePoint <br />&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Process each work point whose name starts with &quot;Punch&quot; <br />&#0160;&#0160;&#0160; &#39; by performing a boolean with the tool at that location. <br /></strong></span>&#0160;&#0160;&#0160; Dim wp As WorkPoint <br />&#0160;&#0160;&#0160; For Each wp In partDef.WorkPoints <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; If Left$(UCase(wp.Name), 5) = &quot;PUNCH&quot; Then <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &#39; Transform the tool body to the position of the x and <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &#39; y coordinates work point, leaving the z as-is.&#0160; The&#0160; <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &#39; punch is at the last punch so the transform defines <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &#39; the difference between the last and the current. <br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; trans.Cell(1, 4) = wp.Point.X - lastPosition.X <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; trans.Cell(2, 4) = wp.Point.Y - lastPosition.Y <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call tb.Transform(transTool, trans) <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &#39; Do the boolean operation. <br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Call tb.DoBoolean(transBase, transTool, _ <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; kBooleanTypeDifference) <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; &#39; Save the last position. <br /></strong></span>&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; Set lastPosition = wp.Point <br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; End If <br />&#0160;&#0160;&#0160; Next <br />&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Create a base body feature of the result. <br /></strong></span>&#0160;&#0160;&#0160; Dim nonParamFeatures As NonParametricBaseFeatures <br />&#0160;&#0160;&#0160; Set nonParamFeatures = partDef.Features.NonParametricBaseFeatures <br />&#0160;&#0160;&#0160; Dim nonParamDef As NonParametricBaseFeatureDefinition <br />&#0160;&#0160;&#0160; Set nonParamDef = nonParamFeatures.CreateDefinition <br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Dim objs As ObjectCollection <br />&#0160;&#0160;&#0160; Set objs = tObjs.CreateObjectCollection <br />&#0160;&#0160;&#0160; Call objs.Add(transBase) <br />&#0160;&#0160;&#0160; nonParamDef.BRepEntities = objs <br />&#0160;&#0160;&#0160; nonParamDef.OutputType = kSolidOutputType <br />&#0160;&#0160;&#0160; <br />&#0160;&#0160;&#0160; Call nonParamFeatures.AddByDefinition(nonParamDef) <br />&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Turn off the display of the original two <br />&#0160;&#0160;&#0160; &#39; features to see the result.</strong></span> <br />&#0160;&#0160;&#0160; baseBody.Visible = False <br />&#0160;&#0160;&#0160; toolBody.Visible = False <br />&#0160;&#0160;&#0160; <br /><span style="color: #0000ff;"><strong>&#0160;&#0160;&#0160; &#39; Force a refresh of the view. <br /></strong></span>&#0160;&#0160;&#0160; ThisApplication.ActiveView.Update <br />End Sub</p>
</div>
<p>-Brian</p>

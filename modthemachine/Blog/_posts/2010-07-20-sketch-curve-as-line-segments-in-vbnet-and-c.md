---
layout: "post"
title: "Sketch Curve as Line Segments in VB.Net and C#"
date: "2010-07-20 18:15:58"
author: "Adam Nagy"
categories:
  - "Brian"
original_url: "https://modthemachine.typepad.com/my_weblog/2010/07/sketch-curve-as-line-segments-in-vbnet-and-c.html "
typepad_basename: "sketch-curve-as-line-segments-in-vbnet-and-c"
typepad_status: "Publish"
---

<p>Here’s the VB.Net and C# versions of the <a href="http://modthemachine.typepad.com/my_weblog/2010/07/approximating-a-sketch-curve-with-line-segments.html">VBA program from previous post</a>.&#160; To go from that VBA program to this VB.Net version was fairly easy.&#160; I just copied and pasted the VBA code into a new VB.Net project.&#160; The primary changes that I had to make were primarily to the array declarations.&#160; Another change, although it wasn’t required, was to change the error handling from the On Error style to Try Catch.&#160; I prefer the Try Catch style of error handling.&#160; </p>  <p>The array declaration change is because in .Net declaring an array isn’t enough to&#160; initialize it.&#160; The VBA version of one of the declarations is here:</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim startCoord() As Double</p> </div>  <p>Here’s the .Net version of the same array.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim startCoord() As Double = {}      <br /></p> </div>  <p>Here’s the full VB.Net program.&#160; The Inventor Application object is passed in as an argument.&#160; The act of pasting the VBA code into a .Net program automatically removed all of the Set statements because they’re not longer needed in .Net, which is nice.&#160; I also like to enclose arguments to a method within parentheses.&#160; In VBA the parentheses are optional and use have to use the Call statement to have them.&#160; In VB.Net parentheses are required and using a Call statement is optional.&#160; Other than these minor changes, it’s the same code as the original VBA version.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>Public Sub CreateSegmentedCurve(ByVal invApp As Inventor.Application)      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Check to see that a curved sketch entity is selected.          <br /></strong></font>&#160;&#160;&#160; Dim entity As SketchEntity       <br />&#160;&#160;&#160; Try       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; entity = invApp.ActiveDocument.SelectSet.Item(1)       <br />&#160;&#160;&#160; Catch ex As Exception       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MsgBox(&quot;A curved sketch entity must be selected.&quot;)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Exit Sub       <br />&#160;&#160;&#160; End Try&#160; <br />      <br />&#160;&#160;&#160; If TypeOf entity Is SketchPoint Or _&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160; TypeOf entity Is SketchLine Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MsgBox(&quot;A curved sketch entity must be selected.&quot;)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Exit Sub       <br />&#160;&#160;&#160; End If&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Ask for the number of segments to break the curve into.          <br /></strong></font>&#160;&#160;&#160; Dim prompt As String       <br />&#160;&#160;&#160; prompt = &quot;Enter the number of segments for the curve.&quot;       <br />&#160;&#160;&#160; Dim segmentCount As Integer       <br />&#160;&#160;&#160; segmentCount = Val(InputBox(prompt, &quot;Number of Segments&quot;, &quot;10&quot;))       <br />&#160;&#160;&#160; If segmentCount = 0 Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MsgBox(&quot;Invalid segment count.&quot;)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Exit Sub       <br />&#160;&#160;&#160; End If </p>    <p><font color="#0000ff"><strong>&#160;&#160;&#160; ' Get the parent sketch.          <br /></strong></font>&#160;&#160;&#160; Dim sk As Sketch = entity.Parent&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Get the evaluator from the associate geometry.          <br /></strong></font>&#160;&#160;&#160; Dim curveEval As Curve2dEvaluator = entity.Geometry.Evaluator       <br />&#160;&#160;&#160; Dim minU As Double       <br />&#160;&#160;&#160; Dim maxU As Double&#160; <br />&#160;&#160;&#160; curveEval.GetParamExtents(minU, maxU)&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Determine if the entity is open or closed (circle,          <br />&#160;&#160;&#160; ' ellipse, or closed spline)           <br /></strong></font>&#160;&#160;&#160; Dim curveIsClosed As Boolean = False       <br />&#160;&#160;&#160; If TypeOf entity Is SketchCircle Or _       <br />&#160;&#160;&#160;&#160;&#160;&#160; TypeOf entity Is SketchEllipse Or _       <br />&#160;&#160;&#160;&#160;&#160;&#160; TypeOf entity Is SketchSpline Or _       <br />&#160;&#160;&#160;&#160;&#160;&#160; TypeOf entity Is SketchOffsetSpline Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; If TypeOf entity Is SketchSpline Or _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TypeOf entity Is SketchOffsetSpline Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; If entity.Closed Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveIsClosed = True       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; End If       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveIsClosed = True       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; End If       <br />&#160;&#160;&#160; End If       <br />      <br />&#160;&#160;&#160; Dim tg As TransientGeometry = invApp.TransientGeometry&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Determine if start point is at the min or max parameter.          <br /></strong></font>&#160;&#160;&#160; Dim startPoint As SketchPoint = Nothing       <br />&#160;&#160;&#160; Dim endPoint As SketchPoint = Nothing       <br />&#160;&#160;&#160; If Not curveIsClosed Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim startCoord() As Double = {}       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim endCoord() As Double = {}&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveEval.GetEndPoints(startCoord, endCoord)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; If entity.StartSketchPoint.Geometry.IsEqualTo( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tg.CreatePoint2d(startCoord(0), startCoord(1))) Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startPoint = entity.StartSketchPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; endPoint = entity.EndSketchPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; endPoint = entity.StartSketchPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startPoint = entity.EndSketchPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; End If       <br />&#160;&#160;&#160; End If&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Get the curve length.          <br /></strong></font>&#160;&#160;&#160; Dim length As Double&#160; <br />&#160;&#160;&#160; curveEval.GetLengthAtParam(minU, maxU, length)&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Determine the length between segments.          <br /></strong></font>&#160;&#160;&#160; Dim offset As Double       <br />&#160;&#160;&#160; offset = length / segmentCount&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Start a transaction to wrap the sketch creation as a          <br />&#160;&#160;&#160; ' single undo operation.           <br /></strong></font>&#160;&#160;&#160; Dim trans As Transaction = Nothing       <br />&#160;&#160;&#160; Try       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim transMgr As TransactionManager       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; transMgr = invApp.TransactionManager       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans = transMgr.StartTransaction( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; invApp.ActiveDocument, &quot;Segment Curve&quot;)&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Defer updates on the sketch while the sketch entities          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' are being created.&#160; This will significantly improve           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' performance.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.DeferUpdates = True&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Calculate the points and create a sketch          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' point at each position.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim points() As SketchPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ReDim points(segmentCount)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim currentLength As Double = 0       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; For i As Integer = 0 To segmentCount       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim currentParam As Double&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveEval.GetParamAtLength(minU, currentLength, _&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; currentParam)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; currentLength = currentLength + offset&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim params(0) As Double       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; params(0) = currentParam       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim coords() As Double = {}&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveEval.GetPointAtParam(params, coords)&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; If i = 0 Then       <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Special case for the first point.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; If Not curveIsClosed Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(i) = startPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(i) = sk.SketchPoints.Add( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tg.CreatePoint2d(coords(0), coords(1)), _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; False)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; endPoint = points(i)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; End If       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ElseIf i = segmentCount Then       <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Special case for the last point          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(i) = endPoint       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(i) = sk.SketchPoints.Add( _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tg.CreatePoint2d(coords(0), coords(1)), _       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; False)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; End If       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Next&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Connect the points with lines.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; For i As Integer = 0 To segmentCount - 1&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.SketchLines.AddByTwoPoints(points(i), points(i + 1))       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Next&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Make the selected entity construction geometry.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; entity.Construction = True&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' There's a current problem that when setting the          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' construction property, the display isn't updated           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' to reflect this change until something causes the           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' sketch to recompute.&#160; This performs a change on           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' the sketch to kick a recompute.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim originalPoint As Point2d       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; originalPoint = points(0).Geometry&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(0).MoveTo(tg.CreatePoint2d( _&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(0).Geometry.X + 0.001, _&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(0).Geometry.Y))&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; points(0).MoveTo(originalPoint)&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ' Turn off the defer to the sketch will recompute normally.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.DeferUpdates = False&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans.End()       <br />&#160;&#160;&#160; Catch ex As Exception       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.DeferUpdates = False&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; If Not trans Is Nothing Then       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans.Abort()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; End If&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MsgBox(&quot;Unexpected error segmenting curve.&quot;)       <br />&#160;&#160;&#160; End Try       <br />End Sub</p> </div>  <p>Here’s a C# version of the same program.&#160; I’m not going to go into a lot of details now about the differences other than to say that there are several.&#160; I’m working on an upcoming post that will describe the various issues when using C# to program Inventor.&#160; The majority of this code was created using a VB.Net to C# converter, but there were still significant changes that had to be made after that to get it to run.</p>  <div style="font-size: 8pt; background: #eeeeee; color: black; line-height: 140%; font-family: courier new">   <p>static void CreateSegmentedCurve(Inventor.Application invApp)      <br />{       <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Check to see that a curved sketch entity is selected.          <br /></strong></font>&#160;&#160;&#160; SketchEntity entity = null;       <br />&#160;&#160;&#160; try       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; entity = (SketchEntity) invApp.ActiveDocument.SelectSet[1];       <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; catch&#160; <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MessageBox.Show(&quot;A curved sketch entity must be selected.&quot;);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return;       <br />&#160;&#160;&#160; }&#160; <br />      <br />&#160;&#160;&#160; if (entity is SketchPoint | entity is SketchLine)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MessageBox.Show(&quot;A curved sketch entity must be selected.&quot;);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return;       <br />&#160;&#160;&#160; }&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Ask for the number of segments to break the curve into.          <br /></strong></font>&#160;&#160;&#160; string prompt = null;       <br />&#160;&#160;&#160; prompt = &quot;Enter the number of segments for the curve.&quot;;       <br />&#160;&#160;&#160; int segmentCount = 0;       <br />&#160;&#160;&#160; segmentCount = (int) Conversion.Val(Interaction.InputBox(prompt,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Number of Segments&quot;, &quot;10&quot;, 20, 20));       <br />&#160;&#160;&#160; if (segmentCount == 0)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MessageBox.Show(&quot;Invalid segment count.&quot;);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return;       <br />&#160;&#160;&#160; }&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Get the parent sketch.          <br /></strong></font>&#160;&#160;&#160; Sketch sk = entity.Parent;&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Get the geometry associated with the sketch entity.&#160; Since          <br />&#160;&#160;&#160; // the Geometry property will return one of various types of          <br />&#160;&#160;&#160; // objects, we need to use late binding here which C# doesn't          <br />&#160;&#160;&#160; // handle very nicely.           <br /></strong></font>&#160;&#160;&#160; object geom = entity.GetType().InvokeMember(&quot;Geometry&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BindingFlags.GetProperty , null, entity, null);&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Get the curve evaluator from the geometry.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160; Curve2dEvaluator curveEval =       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (Curve2dEvaluator) geom.GetType().InvokeMember(&quot;Evaluator&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BindingFlags.GetProperty, null, geom, null);       <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Get the evaluator from the associate geometry.          <br /></strong></font>&#160;&#160;&#160; double minU = 0;       <br />&#160;&#160;&#160; double maxU = 0;       <br />&#160;&#160;&#160; curveEval.GetParamExtents(out minU, out maxU);&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Determine if the entity is open or closed (circle,          <br />&#160;&#160;&#160; // ellipse, or closed spline)           <br /></strong></font>&#160;&#160;&#160; bool curveIsClosed = false;       <br />&#160;&#160;&#160; if (entity is SketchCircle | entity is SketchEllipse |       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; entity is SketchSpline | entity is SketchOffsetSpline)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (entity is SketchSpline | entity is SketchOffsetSpline)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bool isClosed = (bool) entity.GetType().InvokeMember(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Closed&quot;, BindingFlags.GetProperty,&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; null, entity, null);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (isClosed)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveIsClosed = true;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveIsClosed = true;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; TransientGeometry tg = invApp.TransientGeometry;&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Determine if start point is at the min or max parameter.          <br /></strong></font>&#160;&#160;&#160; SketchPoint startPoint = null;       <br />&#160;&#160;&#160; SketchPoint endPoint = null;       <br />&#160;&#160;&#160; if (!curveIsClosed)       <br />&#160;&#160;&#160; {       <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Get the start and end sketch points from the curve.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; SketchPoint tempStartPoint =       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (SketchPoint) entity.GetType().InvokeMember(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;StartSketchPoint&quot;, BindingFlags.GetProperty,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; null, entity, null);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; SketchPoint tempEndPoint =       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (SketchPoint) entity.GetType().InvokeMember(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;StartSketchPoint&quot;, BindingFlags.GetProperty,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; null, entity, null);&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Get the coordinate, as a Point object from          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // the start sketch point.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Point2d tempStartCoord =       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (Point2d) tempStartPoint.GetType().InvokeMember(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Geometry&quot;, BindingFlags.GetProperty, null,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tempStartPoint, null);&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; double[] startCoord = {};       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; double[] endCoord = {};       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveEval.GetEndPoints(ref startCoord, ref endCoord);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (tempStartCoord.IsEqualTo(tg.CreatePoint2d(startCoord[0],      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startCoord[1]), tg.PointTolerance))       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startPoint = tempStartPoint;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; endPoint = tempEndPoint;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; endPoint = tempStartPoint;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startPoint = tempEndPoint;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160; }&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Get the curve length.          <br /></strong></font>&#160;&#160;&#160; double length = 0;       <br />&#160;&#160;&#160; curveEval.GetLengthAtParam(minU, maxU, out length);&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Determine the length between segments.          <br /></strong></font>&#160;&#160;&#160; double offset = length / segmentCount;&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160; // Start a transaction to wrap the sketch creation as a          <br />&#160;&#160;&#160; // single undo operation.           <br /></strong></font>&#160;&#160;&#160; Transaction trans = null;       <br />&#160;&#160;&#160; try       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TransactionManager transMgr = null;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; transMgr = invApp.TransactionManager;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans = transMgr.StartTransaction(invApp.ActiveDocument,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Segment Curve&quot;);&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Defer updates on the sketch while the sketch entities          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // are being created.&#160; This will significantly improve           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // performance.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.DeferUpdates = true;&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Calculate the points and create a sketch          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // point at each position.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; SketchPoint[] points = new SketchPoint[segmentCount+1];       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; double currentLength = 0;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt;= segmentCount; i++) {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; double currentParam = 0;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveEval.GetParamAtLength(minU, currentLength,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; out currentParam);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; currentLength = currentLength + offset;&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; double[] crvParams = new double[1];       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; crvParams[0] = currentParam;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; double[] coords = {};       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; curveEval.GetPointAtParam(ref crvParams, ref coords);&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (i == 0) {       <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Special case for the first point.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!curveIsClosed)&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points[i] = startPoint;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points[i] = sk.SketchPoints.Add(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tg.CreatePoint2d(coords[0],       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; coords[1]), false);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; endPoint = points[i];       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else if (i == segmentCount)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Special case for the last point          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points[i] = endPoint;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; points[i] = sk.SketchPoints.Add(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tg.CreatePoint2d(coords[0],       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; coords[1]), false);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Connect the points with lines.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt;= segmentCount - 1; i++)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.SketchLines.AddByTwoPoints(points[i], points[i + 1]);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Make the selected entity construction geometry.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; entity.Construction = true;&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // There's a current problem that when setting the         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // construction property, the display isn't updated to          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // reflect this change until something causes the sketch          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // to recompute.&#160; This performs a change on the sketch to          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // kick a recompute.           <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Point2d originalPoint = default(Point2d);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; originalPoint = points[0].Geometry;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; points[0].MoveTo(tg.CreatePoint2d(points[0].Geometry.X +      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0.001, points[0].Geometry.Y));       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; points[0].MoveTo(originalPoint);&#160; <br />      <br /><font color="#0000ff"><strong>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Turn off the defer to the sketch will recompute normally.          <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.DeferUpdates = false;&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans.End();       <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; catch (Exception)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; sk.DeferUpdates = false;&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ((trans != null))       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans.Abort();       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160; <br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; MessageBox.Show(&quot;Unexpected error segmenting curve.&quot;);       <br />&#160;&#160;&#160; }       <br />}</p> </div>

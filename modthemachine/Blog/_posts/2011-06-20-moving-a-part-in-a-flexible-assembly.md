---
layout: "post"
title: "Moving a Part in a Flexible Assembly"
date: "2011-06-20 23:27:38"
author: "Adam Nagy"
categories:
  - "Brian"
original_url: "https://modthemachine.typepad.com/my_weblog/2011/06/moving-a-part-in-a-flexible-assembly.html "
typepad_basename: "moving-a-part-in-a-flexible-assembly"
typepad_status: "Publish"
---

<p>I recently received a question that I thought there might be some general interest in the answer.&#160; Here’s the problem.&#160; I have the assembly shown below.&#160; It’s free to move in the ways you would expect; it can pivot about the base and the arm can extend.&#160; Everything is fine so far.</p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc68834014e8944fce9970d-pi"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="ArmAssembly" border="0" alt="ArmAssembly" src="/assets/image_934273.jpg" width="321" height="321" /></a></p>  <p>Next I insert the arm assembly shown above into a new assembly.&#160; Then I insert the yellow block part into the assembly and constrain it to the tip of the arm, as shown below.</p>  <p><a href="http://modthemachine.typepad.com/.a/6a00e553fcbfc6883401538f51b99b970b-pi"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="ArmAssemblyFull" border="0" alt="ArmAssemblyFull" src="/assets/image_691116.jpg" width="313" height="327" /></a></p>  <p>First, the arm assembly is rigid if I try to move any of its parts.&#160; That’s the behavior I would expect because, by default, subassemblies are rigid within an assembly.&#160; However, you can set the subassembly occurrence to be “flexible” so that it will behave the same as it does when the subassembly is active.&#160; That is, the arms can be dragged and the positions of all of the connected parts will update.&#160; I can also drag the yellow block and that will cause the arms to reposition to follow the block.</p>  <p>The question posed was how to move the block using the API and still get the arms to follow.&#160; The expectation, which I shared, is that setting the transformation for the yellow block to reposition it should automatically reposition everything else that’s connected to it.&#160; This is probably how it should behave but it’s not.&#160; When setting the position of the yellow block nothing happens.&#160; The yellow block doesn’t move and the arm subassembly doesn’t move.</p>  <p>I played around with a couple of ideas and one of them does work.&#160; It’s simple to implement so should be an acceptable workaround.&#160; It temporarily grounds the part that’s being moved.&#160; The API to move a part will move a grounded part and when the assembly computes, the grounded part has a higher priority in the solver than the flexible assembly so the flexible assembly adjusts to the change.</p>  <p>Here’s the code I used to test this.</p>  <p style="line-height: 140%; font-family: courier new; background: #eeeeee; color: black; font-size: 8pt">Public Sub MovePart()    <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Have the occurrence that will be moved selected.        <br /></strong></font>&#160;&#160;&#160; Dim occ As ComponentOccurrence     <br />&#160;&#160;&#160; Set occ = ThisApplication.CommandManager.Pick( _&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; kAssemblyOccurrenceFilter, _&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Select an occurrence.&quot;)     <br />    <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Get the current grounded state of the selected occurrence.&#160; <br /></strong></font>&#160;&#160;&#160; Dim groundState As Boolean     <br />&#160;&#160;&#160; groundState = occ.Grounded     <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Ground the occurrence.        <br /></strong></font>&#160;&#160;&#160; occ.Grounded = True     <br />&#160;&#160;&#160; <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Change the position of the occurrence.&#160; This repositions it        <br />&#160;&#160;&#160; ' in a series of steps to create a short animation.&#160; It moves         <br />&#160;&#160;&#160; ' it 0.5 cm in the Y direction for each step.         <br /></strong></font>&#160;&#160;&#160; Dim i As Integer     <br />&#160;&#160;&#160; For i = 1 To 10     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dim trans As Matrix     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Set trans = occ.Transformation     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; trans.Cell(2, 4) = trans.Cell(2, 4) + .5     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; occ.Transformation = trans     <br />&#160;&#160;&#160; Next    <br />    <br /><font color="#0000ff"><strong>&#160;&#160;&#160; ' Reset the grounded state of the occurrence back to        <br />&#160;&#160;&#160; ' its original state.         <br /></strong></font>&#160;&#160;&#160; occ.Grounded = groundState     <br />End Sub</p>

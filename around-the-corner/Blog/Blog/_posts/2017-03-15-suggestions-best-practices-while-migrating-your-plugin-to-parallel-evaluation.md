---
layout: "post"
title: "Suggestions &amp; Best practices while migrating your plugin to Parallel Evaluation"
date: "2017-03-15 12:19:00"
author: "Zhong Wu"
categories:
  - "Animation"
  - "C++"
  - "Maya"
  - "Plug-in"
  - "Zhong Wu"
original_url: "https://around-the-corner.typepad.com/adn/2017/03/suggestions-best-practices-while-migrating-your-plugin-to-parallel-evaluation.html "
typepad_basename: "suggestions-best-practices-while-migrating-your-plugin-to-parallel-evaluation"
typepad_status: "Publish"
---

<p>As we know, starting from Maya 2016, Maya introduces a new evaluation model that enabled better utilization of computer resources by distributing computation over all available cores and taking advantage of GPU compute power. Unlike previous versions of Maya, which was limited to node-level parallelisms, Maya now includes a mechanism for scene-level analysis and parallelization. For example, if your scene contains different characters that are unconstrained to one another, Maya can evaluates each character at the same time. </p>  <p><a href="http://around-the-corner.typepad.com/.a/6a0163057a21c8970d01bb099a17f4970d-pi"><img title="dag-holly_0" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; border-top-width: 0px; margin-right: auto" border="0" alt="dag-holly_0" src="/assets/image_fc4296.jpg" width="323" height="389" /></a>     <br />At the heart of Mayaâ€™s new evaluation architecture is an <b><b>Evaluation Manager (EM)</b></b>, responsible for creating a parallel-friendly description of your scene, called the <b><b>Evaluation Graph (EG)</b></b>. The EM schedules EG nodes across available compute resources. If you are not familiar with Maya EM/EG, and want to have a deep idea about the background, I suggest you can check the in-depth technical doc at <a href="http://www.autodesk.com/using-parallel-maya">Using Parallel Maya</a>.     <br />Here, I just want to bring up some best practice and suggestions to avoid some issues while migrating or make use of the Maya Parallel Evaluation in your plugin.     <br />In general, if your plug-in plays by the DG rules, there is not much you need to change in your plug-in to make it work in Parallel mode. Porting your plug-in so it works in Parallel may be as simple as recompiling it against the latest version of OpenMaya. But, if the EM generates different results than DG-based evaluation, you need to check these items to make sure that your plug-in follow best practices:</p>  <ul>   <li><b>Be careful with MPxNode::setDependentsDirty().</b> </li> </ul>  <blockquote>   <p>If your scene uses custom plug-ins that rely on the <code>MPxNode::setDependentsDirty</code> function to manage attribute dirtying, this may cause some problems. Plug-in developer sometimes use <code>MPxNode::setDependentsDirty</code> to avoid expensive calculations in <code>MPxNode::compute</code> by monitoring and/or altering dependencies and storing computed results for later re-use. </p>    <p>Since the EM relies on dirty propagation to create the EG, any custom plug-in logic that alters dependencies may interfere with the construction of a correct EG. Furthermore, since the EM evaluation does not propagate dirty messages, any custom caching or computation in <code>MPxNode::setDependentsDirty</code> is not called while the EM is evaluating. I will talk detail about the solution in next blog post. </p> </blockquote> <b></b>  <ul>   <li><b>Handles requests for evaluation at all levels of the plug tree. </b></li> </ul>  <blockquote>   <p>While the DG can request plug values at any level, the EM always requests the root plug. This mostly happen when you have a compound attribute, for example, for plug N.gp[0].p[1], your compute() method must handle requests for evaluation of N.gp, N.gp[0], N.gp[0].p, and N.gp[0].p[1]. Recently we happen to see an issue which is caused by not including the root plug in compute() method.&#160;&#160; </p> </blockquote>  <ul>   <li><b><b>Overrides MPxNode::compute(). </b></b></li> </ul>  <blockquote>   <p>This is especially true of classes extending MPxTransform which previously relied on asMatrix(). See the rockingTransform SDK sample. For classes deriving from MPxDeformerNode and MPxGeometryFilter, override the deform() method. </p> </blockquote> Besides the above suggestions, there are some other recommended best practices include:   <ul>   <li><b><b>Avoid storing state in static variables.</b></b> Store node state/settings in attributes. This has the additional benefit of automatically saving/restoring the plug-in state when Maya files are written/read. </li>    <li><b><b>Node computation should not have any dependencies beyond input values.</b></b> Maya nodes should be like functions. Output values should be computed from input state and node-specific internal logic. Your node should never walk the graph or try to circumvent the DG. </li> </ul>

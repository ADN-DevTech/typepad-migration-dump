---
layout: "post"
title: "How to write an Arnold Translator for MPxSurfaceShapes"
date: "2017-05-15 02:37:06"
author: "Cheng Xi Li"
categories:
  - "Cheng Xi Li"
  - "Maya"
  - "Plug-in"
  - "Rendering"
  - "Samples"
original_url: "https://around-the-corner.typepad.com/adn/2017/05/how-to-write-an-arnold-translator-for-mpxsurfaceshapes.html "
typepad_basename: "how-to-write-an-arnold-translator-for-mpxsurfaceshapes"
typepad_status: "Publish"
---

<p>If you are wondering why your fancy geometry created with MPxSurfaceShape is not working in renderers like Arnold, then this article is for you. Before rendering them, you&#39;ll need to create a translator or shader for your renderer.<br /><br />For Arnold, it&#0160;can be handled using extensions. To make a 3rd-party plugin work with Arnold, you&#39;ll need to write translator extension for it.There are three SDKs you are going to refer to in your project. Arnold SDK, mtoa SDK and Maya SDK.<br /><br />First, you&#39;ll need to download Arnold SDK from <a href="https://www.solidangle.com/arnold/download/">here</a>.&#0160; I am using 4.2.16.1 when writing this sample on windows platform. The SDK might be changed in the future, if you find the sample is not working anymore, please let me know.&#0160;<br /><br />Arnold extensions are dynamic libraries. So, we&#39;ll need to create a dll project in Visual Studio. Two functions are required to export in your extension. They are initializeExtension and deinitializeExtension. For the apiMeshShape extension, we only need to implement intializeExtention and leave deinitializeExtension blank.</p>
<pre id="YedACALCvn0">#include &lt;extension//Extension.h&gt;<br />#include &quot;apiMeshShapeTranslator.h&quot;<br />extern &quot;C&quot;<br />{<br />&#0160;&#0160; &#0160;DLLEXPORT void initializeExtension ( CExtension&amp; extension )<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;MStatus status;<br /><br />&#0160;&#0160; &#0160; &#0160; &#0160;extension.RegisterTranslator(&quot;apiMesh&quot;,<br />&#0160;&#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160;&quot;&quot;,<br />&#0160;&#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160; &#0160;CApiMeshShapeTranslator::creator);<br />&#0160;&#0160; &#0160; &#0160; &#0160;<br />&#0160;&#0160; &#0160;}<br /><br />&#0160;&#0160; &#0160;DLLEXPORT void deinitializeExtension ( CExtension&amp; extension )<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160;}<br /><br />}</pre>
<p>CExtension::RegisterTranslator takes 4 parameters, first is the Maya node type name. For apiMeshShape, it is apiMesh. The second parameter is the Arnold extension name, it can be empty. The third one is a creator function pointer which like Maya creator functions, returning an instance of your translator class. The forth one is optional, which is the node initialize function.<br /><br />Then we are going to write our translator. You&#39;ll need to create Arnold nodes based on your nodes info. There are different kinds of Arnold nodes, like procedural, bump2d, nurbs, etc... We are going to create an Arnold <a href="https://support.solidangle.com/display/NodeRef/polymesh">polymesh </a>node for the apiMeshShape and fill the attributes with apiMeshShape&#39;s geometry.</p>
<pre id="YedACANGZ9d">#include &lt;translators/shape/ShapeTranslator.h&gt;<br /><br />#include &lt;translators/NodeTranslator.h&gt;<br /><br />class CApiMeshShapeTranslator:public CShapeTranslator<br />{<br />public:<br />&#0160;&#0160; &#0160;virtual AtNode* CreateArnoldNodes();<br />&#0160;&#0160; &#0160;virtual void Export(AtNode* polymesh);<br />&#0160;&#0160; &#0160;virtual void Update(AtNode* polymesh);<br />&#0160;&#0160;&#0160;&#0160;<br />&#0160;&#0160; &#0160;void Export(AtNode* polymesh, bool isUpdate);<br />&#0160;&#0160; &#0160;void ExportRenderParameters(AtNode* polymesh);<br />&#0160;&#0160; &#0160;void ExportMeshData(AtNode* polymesh);<br />&#0160;&#0160; &#0160;void ExportMeshShaders(AtNode* polymesh);<br /><br />&#0160;&#0160; &#0160;static void* creator()<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;cout &lt;&lt; &quot;ApiMeshShapeTranlator loaded.&quot; &lt;&lt;endl; &#0160; &#0160; &#0160; &#0160;<br />&#0160;&#0160; &#0160; &#0160; &#0160;return new CApiMeshShapeTranslator();<br />&#0160;&#0160; &#0160;}<br />};</pre>
<p>We have to implement at least three functions to make apiMeshShape visible in Arnold. They are CreateArnoldNodes, Export and Update.<br /><br />CreateArnoldNodes will create a basic arnold type node. We are going to create and return a new polymesh here.</p>
<pre id="YedACApNfjP">AtNode* CApiMeshShapeTranslator::CreateArnoldNodes()<br />{<br />&#0160;&#0160; &#0160;return AddArnoldNode(&quot;polymesh&quot;);<br />}</pre>
<p>Export and Update are related functions, Arnold will call export at the beginning to export attributes which are not going to be changed during the IPR session and calling update later when attributes changes happened. In our scenario, geometry won&#39;t be changed, so geometry is going to be exported while lightning, shaders and transforms are going to be always updated. So, I&#39;ve created an overload function for Export&#0160;like below:</p>
<pre id="YedACASFwAX">void CApiMeshShapeTranslator::Export(AtNode* polymesh, bool isUpdate)<br />{<br />&#0160;&#0160;&#0160; //Export transforms<br />&#0160;&#0160; &#0160;ExportMatrix(polymesh);<br /><br />&#0160;&#0160; &#0160;//Export rendering parameters<br />&#0160;&#0160; &#0160;ProcessRenderFlags(polymesh);<br />&#0160;&#0160; &#0160;<br />&#0160;&#0160; &#0160;//Export light linking<br />&#0160;&#0160; &#0160;ExportLightLinking(polymesh); &#0160; &#0160;<br /><br />&#0160;&#0160; &#0160;// We could enable/disable motion deform here, but I&#39;ll ignore it and make it never deforming.<br />&#0160;&#0160; &#0160;m_motionDeform = false;<br /><br />&#0160;&#0160; &#0160;//Export shaders<br />&#0160;&#0160; &#0160;ExportMeshShaders(polymesh);<br />&#0160;&#0160; &#0160;<br />&#0160;&#0160; &#0160;//If it is an update call, we won&#39;t need to export geometry again.<br />&#0160;&#0160; &#0160;if(!isUpdate)<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160;&#0160;&#0160;&#0160;&#0160;&#0160; //Export geometry<br />&#0160;&#0160; &#0160; &#0160; &#0160;ExportMeshData(polymesh);<br />&#0160;&#0160; &#0160;}<br />}</pre>
<p>ExportMatrix, ProcessRenderFlags and ExportLightLinking are provided by Arnold itself. If you want your shape to have motion deform, you&#39;ll need to set m_motionDeform true and implement ExportMotion. Maya provids source code for xgenTranslator. It is a good reference for how to implement motion in Arnold. In this sample, I am going to ignore it.<br /><br />During the export, I am going to export shaders first. Just provide the MObject of the dagNode to the Arnold, it will do the querying job for you.</p>
<pre id="YedACAlv2R1">void CApiMeshShapeTranslator::ExportMeshShaders(AtNode* polymesh)<br />{ &#0160; &#0160;<br />&#0160;&#0160; &#0160;//Get dag node from dagPath<br />&#0160;&#0160; &#0160;MFnDagNode fnDagNode(m_dagPath);<br />&#0160;&#0160; &#0160;<br />&#0160;&#0160; &#0160;//Get shader node from the dagNode and set it to shader attribute.<br />&#0160;&#0160; &#0160;MPlugArray connections;<br />&#0160;&#0160; &#0160;auto shadingGroup = GetNodeShadingGroup(fnDagNode.object(), 0);<br />&#0160;&#0160; &#0160;auto shader = ExportConnectedNode(shadingGroup);<br /><br />&#0160;&#0160; &#0160;AiNodeSetPtr(polymesh, &quot;shader&quot;, shader);<br />}</pre>
<p>Then, I&#39;ll need to export the meshData from apiMeshShape. apiMeshShape uses apiMeshGeom to store the geometry data and I&#39;ll get them from it. To make it possible, we&#39;ll need to modify apiMeshShape sample a little bit: making meshGeom() exported in the .lib file.</p>
<pre id="YedACAAlqeE">&#0160;&#0160;&#0160; //Modify apiMeshGeom* meshGeom(); in the apiMeshShape.h<br />&#0160;&#0160;&#0160;&#0160;__declspec(dllexport) apiMeshGeom* &#0160; &#0160; __cdecl meshGeom();</pre>
<p>Now we can get the apiMeshGeom easily in our translator. There are normals, vertices, faceCount, faceIds provided with the apiMeshGeom(UVs are not available for the sphere in the sample). So, we are going to fill nsides, vidxs, nidxs, vlist and nlist attribute of the polymesh node.</p>
<pre id="YedACADsR8z">void CApiMeshShapeTranslator::ExportMeshData(AtNode* polymesh)<br />{<br />&#0160;&#0160; &#0160;// Usually this kind of method should be with an extra parameter, step for motion blur. <br />&#0160;&#0160; &#0160;// I&#39;ll ignore it in here to make the sample as simple as possible.<br />&#0160;&#0160; &#0160;MStatus status;<br />&#0160;&#0160; &#0160;m_dagPath.extendToShape();<br />&#0160;&#0160; &#0160;MFnDagNode fnDag(m_dagPath); &#0160; &#0160;<br /><br />&#0160;&#0160; &#0160;// Get apiMeshShape node first<br />&#0160;&#0160; &#0160;auto apiMeshNode = dynamic_cast&lt;apiMesh*&gt;(fnDag.userNode());<br />&#0160;&#0160; &#0160;if(NULL == apiMeshNode)<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;MGlobal::displayError(&quot;Failed to convert apiMeshShape&quot;);<br />&#0160;&#0160; &#0160; &#0160; &#0160;return;<br />&#0160;&#0160; &#0160;}<br /><br />&#0160;&#0160; &#0160;<br />&#0160;&#0160; &#0160;auto geom = apiMeshNode-&gt;meshGeom();<br />&#0160;&#0160; &#0160;auto verticesArray = geom-&gt;vertices;<br />&#0160;&#0160; &#0160;unsigned int numVertices = verticesArray.length();<br />&#0160;&#0160; &#0160;unsigned int numNormals = geom-&gt;normals.length();<br />&#0160;&#0160; &#0160;unsigned int numPolygons = geom-&gt;faceCount;<br />&#0160;&#0160; &#0160;auto vertices = new float[verticesArray.length() * 3];<br />&#0160;&#0160; &#0160;auto normals = new float[numNormals * 3];<br />&#0160;&#0160; &#0160;<br />&#0160;&#0160; &#0160;// Get raw vertices<br />&#0160;&#0160; &#0160;for (int i = 0; i &lt; numVertices; ++i)<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;vertices[i*3] = verticesArray[i].x; &#0160; &#0160;<br />&#0160;&#0160; &#0160; &#0160; &#0160;vertices[i*3 + 1] = verticesArray[i].y;<br />&#0160;&#0160; &#0160; &#0160; &#0160;vertices[i*3 + 2] = verticesArray[i].z; &#0160; &#0160; &#0160; &#0160;<br />&#0160;&#0160; &#0160;}<br /><br />&#0160;&#0160; &#0160;// Get raw normals<br />&#0160;&#0160; &#0160;// We need to export normals if it is smoothShading and doesn&#39;t have arnold subdivision properties. For apiMeshShape, export always.<br />&#0160;&#0160; &#0160;for (int i = 0; i &lt; numNormals; ++i)<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;normals[i*3] = geom-&gt;normals[i].x; &#0160; &#0160;<br />&#0160;&#0160; &#0160; &#0160; &#0160;normals[i*3 + 1] = &#0160;geom-&gt;normals[i].y;<br />&#0160;&#0160; &#0160; &#0160; &#0160;normals[i*3 + 2] = &#0160;geom-&gt;normals[i].z; &#0160; &#0160; &#0160; &#0160;<br />&#0160;&#0160; &#0160;}<br /><br />&#0160;&#0160; &#0160; &#0160; &#0160; &#0160; &#0160;<br />&#0160;&#0160; &#0160;// We always export the first frame.<br />&#0160;&#0160; &#0160;// Please check XGen&#39;s sample for how to export shapes in motion.<br />&#0160;&#0160; &#0160;// We are going just export basic geometry infos(vertices, normals), <br />&#0160;&#0160; &#0160;// there could be other info like references or color sets etc... I&#39;ll skip it here.<br />&#0160;&#0160; &#0160;AtArray* uvs = nullptr;<br />&#0160;&#0160; &#0160;AtArray* nsides = nullptr;<br />&#0160;&#0160; &#0160;AtArray* vertexIndices = nullptr;<br />&#0160;&#0160; &#0160;AtArray* normalIndices = nullptr;<br /><br /><br />&#0160;&#0160; &#0160;// Component IDs<br />&#0160;&#0160; &#0160;// Vertices per polygon count<br />&#0160;&#0160; &#0160;nsides = AiArrayAllocate(numPolygons,1,AI_TYPE_UINT);<br />&#0160;&#0160; &#0160;unsigned int polygonVertexCount = 0;<br />&#0160;&#0160; &#0160;for(unsigned int i = 0; i &lt; numPolygons; ++i)<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;auto numPolygonVertexCount = geom-&gt;face_counts[i];<br />&#0160;&#0160; &#0160; &#0160; &#0160;polygonVertexCount += numPolygonVertexCount;<br />&#0160;&#0160; &#0160; &#0160; &#0160;AiArraySetUInt(nsides, i, numPolygonVertexCount);<br />&#0160;&#0160; &#0160;}<br /><br />&#0160;&#0160; &#0160;// Vertex indices and normal indices<br />&#0160;&#0160; &#0160;vertexIndices = AiArrayAllocate(polygonVertexCount, 1, AI_TYPE_UINT);<br />&#0160;&#0160; &#0160;normalIndices = AiArrayAllocate(polygonVertexCount, 1, AI_TYPE_UINT);<br /><br />&#0160;&#0160; &#0160;MIntArray polygonVertexIndices;<br />&#0160;&#0160; &#0160;unsigned int vertexIndex = 0;<br />&#0160;&#0160; &#0160;for(unsigned int polygon_id =0; polygon_id &lt; geom-&gt;face_connects.length(); ++polygon_id)<br />&#0160;&#0160; &#0160;{<br />&#0160;&#0160; &#0160; &#0160; &#0160;AiArraySetUInt(vertexIndices, polygon_id, geom-&gt;face_connects[polygon_id]); &#0160; &#0160; &#0160; &#0160;<br />&#0160;&#0160; &#0160; &#0160; &#0160;AiArraySetUInt(normalIndices, polygon_id, geom-&gt;face_connects[polygon_id]);<br /><br />&#0160;&#0160; &#0160;}<br /><br />&#0160;&#0160; &#0160;// Set array parameters<br />&#0160;&#0160; &#0160;AiNodeSetArray(polymesh, &quot;vlist&quot;, AiArrayConvert(numVertices * 3, 1, AI_TYPE_FLOAT, vertices));<br />&#0160;&#0160; &#0160;AiNodeSetArray(polymesh, &quot;nlist&quot;, AiArrayConvert(numNormals * 3, 1, AI_TYPE_FLOAT, normals));<br /><br />&#0160;&#0160; &#0160;AiNodeSetArray(polymesh, &quot;nsides&quot;, nsides);<br />&#0160;&#0160; &#0160;AiNodeSetArray(polymesh, &quot;vidxs&quot;, vertexIndices);<br />&#0160;&#0160; &#0160;AiNodeSetArray(polymesh,&quot;nidxs&quot;, normalIndices); &#0160; &#0160;<br />}</pre>
<p>Finally, here is Export and Update functions.</p>
<pre id="YedACAQnXEy">void CApiMeshShapeTranslator::Update(AtNode* polymesh)<br />{<br />&#0160;&#0160; &#0160;Export(polymesh, true);<br />}<br /><br />void CApiMeshShapeTranslator::Export(AtNode* polymesh)<br />{<br />&#0160;&#0160; &#0160;Export(polymesh, false);<br />}</pre>
<p>After building it, copy the ArnoldTranslator.dll into mtoadeploy/2017/extension folder. After reloading the mtoa plugin in Maya, you can find the apiMesh is rendered in Arnold Renderer. Hooray!&#0160;Solidangle&#0160;also provides a <a href="https://support.solidangle.com/display/AFMUG/Translator+of+a+custom+node">tutorial </a>on their website.&#0160;You can also use it as a reference.&#0160;&#0160;<br /><br /></p>
<div data-section-style="11"><img alt="" height="366" id="YedACAOBena" src="/assets/image_68f717.jpg" width="800" /></div>
<p>The full sample code is available on the GitHub, here is the <a href="https://github.com/iamsleepy/ApiMeshShapeArnoldTranslator">link</a>.</p>

---
layout: "post"
title: "Possible Misuse of MScriptUtil in Maya"
date: "2013-03-22 04:39:13"
author: "Cyrille Fauvel"
categories:
  - "Cyrille Fauvel"
  - "Maya"
  - "Python"
original_url: "https://around-the-corner.typepad.com/adn/2013/03/possible-misuse-of-mscriptutil-in-maya.html "
typepad_basename: "possible-misuse-of-mscriptutil-in-maya"
typepad_status: "Publish"
---

<p>Many of Maya&#39;s C++ API methods require that one or more of their parameters be passed as pointers or references. Their return values, too, can be pointers or references.</p>
<p>In Python parameters of class types are passed by reference but parameters of simple types, like integers and floats, are passed by value, making it impossible to call those API methods from Python as Maya the Python API was mainly generated automatically using Swig (let&#39;s call it Python 1.0). The <a href="http://docs.autodesk.com/MAYAUL/2013/ENU/Maya-API-Documentation/cpp_ref/class_m_script_util.html" title="Utility class for working with pointers and references in Python.">MScriptUtil</a>&#0160;class bridges this gap by providing methods which return pointers to values of simple types and which can extract values from such pointers. These pointers can also be used wherever an API method requires a reference to a simple type or an array of a simple type.</p>
<p>For example,&#0160;<a href="http://docs.autodesk.com/MAYAUL/2013/ENU/Maya-API-Documentation/cpp_ref/class_m_transformation_matrix.html#a4b5db5c3abe827a9e7c8b549893ff9e4" title="Set the shear component of the transformation matrix.">MTransformationMatrix::setShear()</a>&#0160;requires as its first parameter an array of three values of simple type &#39;double&#39;. To call setShear() from Python requires using&#0160;<a href="http://docs.autodesk.com/MAYAUL/2013/ENU/Maya-API-Documentation/cpp_ref/class_m_script_util.html" title="Utility class for working with pointers and references in Python.">MScriptUtil</a>&#0160;to create the array of doubles.</p>
<p>But because of its design, MScriptUtil is very easy to misuse and doing so can lead 
to errors and crashes in Maya. There are three main ways in which MScriptUtil is 
misused:&#0160;</p>
<p>
<a class="asset-img-link" href="http://around-the-corner.typepad.com/.a/6a0163057a21c8970d017ee9a55018970d-pi" style="display: inline;"><img alt="Misuse" border="0" class="asset  asset-image at-xid-6a0163057a21c8970d017ee9a55018970d" src="/assets/image_6e6efa.jpg" style="display: block; margin-left: auto; margin-right: auto;" title="Misuse" /></a></p>
<ol>
<li>Failing to initialize an MScriptUtil object&#39;s internal 
storage to the correct size.<br /><br />If you create an MScriptUtil object using 
the default constructor, e.g:<br />
<pre class="brush: python; toolbar: false;">su = OpenMaya.MScriptUtil()</pre>
<br />the object will have no internal storage allocated. If you subsequently 
attempt to get a pointer to its internal storage, e.g:<br />
<pre class="brush: python; toolbar: false;">ptr = su.asIntPtr()</pre>
<br />you will be getting back a pointer to a zero-sized memory 
block, which is not capable of holding anything and will likely crash if you 
attempt to use it.<br /><br />You must first ensure that the MScriptUtil object&#39;s 
internal storage is set for the number of elements you need. You can do this by 
either supplying initial values to the constructor:<br />
<pre class="brush: python; toolbar: false;">su = OpenMaya.MScriptUtil(1, 2) # Allocates storage for 2 elements.</pre>
<br />or 
calling one of the &#39;create&#39; methods:<br />
<pre class="brush: python; toolbar: false;">su = OpenMaya.MScriptUtil()
su.createFromInt(1, 2) # Allocates storage for 2 elements.
su.createFromDouble(5.7) # Allocates storage for 1 element.
su.createFromList([6, 12, -5, 9, 11]) # Allocates storage for 5 elements.</pre>
</li>
<li>Using an MScriptUtil pointer after its corresponding 
MScriptUtil object has been destroyed.<br />This most commonly manifests 
itself in the following way:<br />
<pre class="brush: python; toolbar: false;">ptr = OpenMaya.MScriptUtil(0).asIntPtr()
... go on to use ptr ...</pre>
<br />All 
of the as*Ptr() methods of MScriptUtil return pointers to storage internal to 
the MScriptUtil object. If the object is destroyed then the pointers become 
invalid and any attempt to use them will result in errors or crashes. In the 
example above the MScriptUtil object generated by the OpenMaya.MScriptUtil(0) 
call is destroyed as soon as the asIntPtr() has returned, so &#39;ptr&#39; will be 
invalid.<br /><br />To make this work properly, you must hang on to the MScriptUtil 
object until you no longer need its pointer:<br />
<pre class="brush: python; toolbar: false;">su = OpenMaya.MScriptUtil(0)
ptr = su.asIntPtr()
... go on to use ptr ...</pre>
</li>
<li>Using the same MScriptUtil object for multiple simultaneous 
pointers.<br />Each MScriptUtil object only contains a single block of 
storage. All calls to as*Ptr() will return pointers to the same block of 
storage. So if you do something like this:<br />
<pre class="brush: python; toolbar: false;">su = om.MScriptUtil(0.0)
xptr = su.asFloatPtr()
yptr = su.asFloatPtr()
zptr = su.asFloatPtr()
OpenMaya.MSomething.someFunc(xptr, yptr, zptr)</pre>
<br />it will either crash or you&#39;ll find that all three pointers point to the 
same value after the call.<br /><br />To make this work you must create a separate 
MScriptUtil object for each pointer:<br />
<pre class="brush: python; toolbar: false;">xsu = om.MScriptUtil(0.0)
xptr = xsu.asFloatPtr()
ysu = OpenMaya.MScriptUtil(0.0)
yptr = ysu.asFloatPtr()
zsu = OpenMaya.MScriptUtil(0.0)
zptr = zsu.asFloatPtr()
OpenMaya.MSomething.someFunc(xptr, yptr, zptr)</pre>
<br />Note that it is fine to reuse an MScriptUtil object for a new 
pointer so long as you no longer need the old pointer. E.g:<br />
<pre class="brush: python; toolbar: false;">su = om.MScriptUtil(0.0)
distPtr = su.asFloatPtr()
OpenMaya.MSomething.getDist(distPtr)
dist = su.getFloat(distPtr)
countPtr = su.asIntPtr()
OpenMaya.MSomething.getCount(countPtr)
count = su.getInt(countPtr)</pre>
</li>
</ol>
<h3>The good news</h3>
<p>The good news is that there is a second version of the Maya Python API (Python 2.0) which is better written and will get rid of the MScriptUtil class.</p>
<p>The Maya Python API 2.0 is a new version of the Maya Python API which provides a more Pythonic workflow and improved performance. Both the new and old APIs can co-exist in the same script but objects from the two different APIs cannot be used interchangeably.</p>
<p>The Python API 2.0 has a number of advantages over the original API:</p>
<ul>
<li>Array types are full Python sequences, including slice support.</li>
<li>Methods which take Maya array parameters will usually also take native Python sequences, such as arrays and tuples. Exceptions are made in some case for performance reasons.</li>
<li>The outputs of methods are usually returned in their return values, not through their parameter lists. Exceptions are made in some cases for performance reasons.</li>
<li>Methods which return multiple values (e.g. MFnFluid.getResolution) return them as a tuple or list, eliminating the need for MScriptUtil.</li>
<li>Object attributes are preferred over rather than set/get methods. For example you can now write <em>array.sizeIncrement=64</em>.</li>
<li>There are more types of exceptions used when methods fail. Not everything is a RuntimeError, as was the case in the old API.</li>
<li>The new API is generally faster than the old. Up to three times faster in some cases.</li>
</ul>
<h3>Using the Python API 2.0</h3>
<p>The new Python API modules are found in <em>maya.api</em>. For example:</p>
<pre class="brush: python; toolbar: false;">import maya.api.OpenMaya as om
</pre>
<p>Module names are the same as in the old API with the exception that the proxy classes (i.e. those beginning with <em>MPx</em>) no longer have their own module but reside in the same modules as other related classes. This more closely resembles the C++ API.</p>
<p>Class names are the same as in the old Python API and the C++ API. Method names are mostly the same with some differences where it affects the workflow. Some methods which simply get or set values on an object have been replaced with Python object attributes.</p>
<p>New and old API classes can be used within the same script, but their objects are not interchangeable. Thus, you can do this:</p>
<pre class="brush: python; toolbar: false;">import maya.api.OpenMaya as newOM
import maya.OpenMaya as oldOM

newAttrObj = newOM.MObject()
oldNodeObj = oldOM.MObject()
...
newAttrFn = newOM.MFnAttribute(newAttrObj)
oldNodeFn = oldOM.MFnDependencyNode(oldNodeObj)

# OKAY: Print names from old and new function sets.
print(&quot;Attribute name is %s.%s&quot; % (oldNodeFn.name(), newAttrFn.name))
</pre>
<p>but not this:</p>
<pre class="brush: python; toolbar: false;">import maya.api.OpenMaya as newOM
import maya.OpenMaya as oldOM

newAttrObj = newOM.MObject()
oldNodeObj = oldOM.MObject()
...

# BAD: Passing an old API MObject to a new API method.
newPlug = newOM.MPlug(oldNodeObj, newAttrObj)
</pre>
<p>Given that the class and method names are mostly identical between the two APIs there is a lot of potential for confusion so it&#39;s best not to mix them if you can avoid it.</p>
<p>When writing a plugin which uses the new API, the plugin must define a function called <em>maya_useNewAPI</em> so that Maya will know to pass it objects from the new API rather than the old one. E.g:</p>
<pre class="brush: python; toolbar: false;">def maya_useNewAPI():
    pass
</pre>
<a class="asset-img-link" href="http://around-the-corner.typepad.com/.a/6a0163057a21c8970d017ee9a567cb970d-pi" style="display: inline;"><img alt="Feedback" border="0" class="asset  asset-image at-xid-6a0163057a21c8970d017ee9a567cb970d" src="/assets/image_a41652.jpg" style="display: block; margin-left: auto; margin-right: auto;" title="Feedback" /></a>
<p>We encourage users to provide feedback on this new Python API through the online Suggestion site available from the Maya Help Menu and through the Autodesk Developer Network.</p>
<p>&#0160;</p>

---
layout: "post"
title: "Use a node as input for your custom node"
date: "2016-12-11 23:00:46"
author: "Cheng Xi Li"
categories:
  - "C++"
  - "Cheng Xi Li"
  - "Maya"
  - "Plug-in"
original_url: "https://around-the-corner.typepad.com/adn/2016/12/use-a-node-as-input-for-your-custom-node.html "
typepad_basename: "use-a-node-as-input-for-your-custom-node"
typepad_status: "Publish"
---

<p>Sometimes we want to use a node as input for our custom nodes, and would like our custom node to be updated whenever our input is changed. Usually, we will create a message attribute with MFnMessageAttribute on our custom node and register callbacks to deal with it. The message attributes will never participate in dirty propagation, it is only for making connections.<br /> <br /> For example, sometimes we would like to connect a camera to our custom node and update it with its projection matrix. Unfortunately, projection matrix is only available with API. Thus, we can't connect it directly to our node. To make the projection matrix an input for our node, we can use the camera node as input. I am going to create a node with accepts a message attribute from a cameraShape node and output the projection matrix of the camera.<br /> <br /> First, I'll need to create a message attribute, a matrix attribute and a dummy attribute for dirtying our node:</p>
<pre id="JfQACAXpnPU">// Create message attribute and matrix attribute here.<br />MStatus affects::initialize()<br />{<br />    MFnMatrixAttribute matAttr;<br />    MFnMessageAttribute msgAttr;<br />    MFnNumericAttribute nAttr;<br /><br />    // Use for projection matrix<br />    projectionMatrix = matAttr.create(PROJECTION_MATRIX_LN, PROJECTION_MATRIX_SN, MFnMatrixAttribute::kFloat);<br /><br />    // Message attribute <br />    inputCamera = msgAttr.create(INPUT_CAMERA_LN, INPUT_CAMERA_SN);<br /><br />    // For attributeAffects<br />    dirtyDummy = nAttr.create(DIRTY_DUMMY_LN, DIRTY_DUMMY_SN, MFnNumericData::kBoolean);<br /><br />    addAttribute(projectionMatrix);<br />    addAttribute(inputCamera);<br />    addAttribute(dirtyDummy);<br /><br />    attributeAffects(dirtyDummy, projectionMatrix);<br /><br />    return( MS::kSuccess );<br />}</pre>
<p>The projection matrix is a MFloatMatrix, and it is created with MFnMatrixAttribute. Because we are going to update our node during the callbacks, we'll need to create an attribute and make it affect the output matrix. I created a method called setProjectionMatrixDirty for it:</p>
<pre id="JfQACAqKQkG">void affects::setProjectionMatrixDirty()<br />{<br />    auto dirtyPlug = MPlug(thisMObject(), dirtyDummy);<br />    bool lastValue;<br />    dirtyPlug.getValue(lastValue);<br />    dirtyPlug.setValue(!lastValue);<br />}</pre>
<p><br /> When a plug is connected or disconnected, MFnNode::connectionMade or MFnNode::connectionBroken will be called. We could take advantage of this behavior, and register our callbacks in it. For the cameraShape node itself, we can use MNodeMessage::addNodeDirtyPlugCallback to track it, but it won't work for its transform. Luckily, Maya provides another callback MDagMessage::addWorldMatrixModifiedCallback to track its world matrix. The node itself is provided as custom data for the callbacks, so we have access to both the camera node and our node during the callback. We also need to define those callbacks as friend of our node, unless you make them directly members (cameraNode, projection matrix value, etc...) public. <br /> <br /> MPxNode::connectionMade is coded like below</p>
<pre id="JfQACAdme2S">// Create an attribute change callback on the camera when connection is made<br />MStatus affects::connectionMade( const MPlug&amp; plug, const MPlug&amp; otherPlug, bool asSrc )<br />{<br />    if(plug == inputCamera)<br />    {<br />        MObject otherNode = otherPlug.node();<br />    <br />        // If is from camera.message<br />        // It must be connected from cameraShape, otherwise won't work.<br />        if(otherNode.hasFn(MFn::kCamera))<br />        {<br />            MGlobal::displayInfo("Connection made.");<br />        <br />            isCameraSet = true;<br />            cameraNode = otherNode;<br /><br />            MFnCamera fnCam(cameraNode);            <br />            projectionMatrixValue = fnCam.projectionMatrix();                    <br />            setProjectionMatrixDirty();<br />            cameraCallbackId = MNodeMessage::addNodeDirtyPlugCallback(cameraNode, cameraNodePlugDirty, this);<br /><br />            // Add world transform matrix<br />            MSelectionList sel;<br />            sel.add(fnCam.fullPathName());<br />            MDagPath dagPath;<br />            sel.getDagPath(0,dagPath);<br />            worldMatrixCallbackId = MDagMessage::addWorldMatrixModifiedCallback(dagPath,cameraWorldMatrixChangeCallback,this);<br />            <br />            return MStatus::kSuccess;<br />        }<br />    }<br />    return MPxNode::connectionMade(plug, otherPlug, asSrc);<br />}</pre>
<p>Then, here is MPxNode::connectionBroken. We need to remove callbacks when the plug is disconnected</p>
<pre id="JfQACAWCiOT">// Remove callbacks when connection is broken.<br />MStatus affects::connectionBroken( const MPlug&amp; plug, const MPlug&amp; otherPlug, bool asSrc )<br />{<br />    if(plug == inputCamera)<br />    {<br />        MObject otherNode = otherPlug.node();<br />        // If is from cameraShape.message<br />        <br />        if(otherNode.hasFn(MFn::kCamera))<br />        {<br />            MGlobal::displayInfo("Connection breaks.");<br />            if(isCameraSet)<br />            {<br />                isCameraSet = false;<br />                cameraNode = otherNode;<br /><br />                MFnCamera fnCam(cameraNode);<br />                projectionMatrixValue = fnCam.projectionMatrix();        <br />                <br />                setProjectionMatrixDirty();<br /><br />                MNodeMessage::removeCallback(cameraCallbackId);<br />                MDagMessage::removeCallback(worldMatrixCallbackId);<br />            }<br />            return MStatus::kSuccess;<br />        }<br />    }<br />    return MPxNode::connectionBroken(plug, otherPlug, asSrc);<br />}</pre>
<p>Now, we have to write our callbacks. We are going to update the projection matrix attribute in the compute method to have a better performance, and there is one issue we should try to avoid here: calling MFnCamera::projectionMatrix in the compute method. During DG evaluation, it is better not to access the plugs outside the data block. So, getting the projection matrix from the camera shape during the compute method will cause a problem. But there is no such limitation in the callback, so we can get the value and cache it during the callback, then update the projection matrix attribute with the cached value in the callback. The callback is written like below:</p>
<pre id="JfQACA5hn5m">// Node plug dirty change callback<br />void cameraNodePlugDirty(MObject &amp;node, MPlug &amp;plug, void *clientData)<br />{<br />    affects* affectNode = (affects*)clientData;<br /><br />    if(affectNode-&gt;isCameraSet)<br />    {<br />        MGlobal::displayInfo("Updating projection matrix after camera shape changes.");<br />        MFnCamera fnCam(affectNode-&gt;cameraNode);<br /><br />        //Cache the projection matrix value here. It will prevent potential DG evaluation issues.<br />        affectNode-&gt;projectionMatrixValue = fnCam.projectionMatrix();<br />        affectNode-&gt;setProjectionMatrixDirty();<br />    }    <br />}<br /><br />//World matrix change callback<br />void cameraWorldMatrixChangeCallback(MObject &amp;transformNode, MDagMessage::MatrixModifiedFlags &amp;modified, void *userData)<br />{<br />    affects* affectNode = (affects*)userData;<br />    <br />    if(affectNode-&gt;isCameraSet)<br />    {<br />        MGlobal::displayInfo("Updating projection matrix after transform changes.");<br />        MFnCamera fnCam(affectNode-&gt;cameraNode);<br /><br />        //Cache the projection matrix value here. It will prevent potential DG evaluation issues.<br />        affectNode-&gt;projectionMatrixValue = fnCam.projectionMatrix();<br />        affectNode-&gt;setProjectionMatrixDirty();<br />    }    <br />}</pre>
<p>And the last part is to provide the compute method:</p>
<pre id="JfQACANSbx0">MStatus affects::compute( const MPlug&amp; plug, MDataBlock&amp; data )<br />{<br />    if(plug == projectionMatrix)<br />    {<br />        MGlobal::displayInfo("Updating projection matrix in compute");<br />        auto handle = data.outputValue(projectionMatrix);<br />        handle.setMFloatMatrix(projectionMatrixValue);<br />        handle.setClean();<br />    }<br />    return MStatus::kSuccess;<br />}</pre>
<p>The full sample is available on the GitHub, you can get it <a href="https://github.com/ADN-DevTech/affectNodesMessage">here</a>.</p>

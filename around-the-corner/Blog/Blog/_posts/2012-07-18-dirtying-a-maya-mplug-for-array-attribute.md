---
layout: "post"
title: "Dirtying a Maya MPlug for Array Attribute"
date: "2012-07-18 06:03:50"
author: "Cyrille Fauvel"
categories:
  - "C++"
  - "Custom Nodes"
  - "Cyrille Fauvel"
  - "Maya"
  - "MEL"
  - "Python"
original_url: "https://around-the-corner.typepad.com/adn/2012/07/dirtying-a-maya-mplug-for-array-attribute.html "
typepad_basename: "dirtying-a-maya-mplug-for-array-attribute"
typepad_status: "Publish"
---

<p>In Maya API, there is no way to explicitly set a plug dirty. However there is a MEL command &quot;dgdirty()&quot; to do exactly that. The MEL command takes the plug name and optionally the index if the plug is an array. I.e. &#39;dgdirty myNode.myattribute[1]&#39;. In this example you set dirty the second element of your array plug.</p>
<p><a class="asset-img-link" href="http://around-the-corner.typepad.com/.a/6a0163057a21c8970d0176168b7944970c-pi" style="display: inline;"><img alt="Node_connections" border="0" class="asset  asset-image at-xid-6a0163057a21c8970d0176168b7944970c" src="/assets/image_0e2f84.jpg" style="display: block; margin-left: auto; margin-right: auto;" title="Node_connections" /></a>There is also a MEL command to determine is a plug is dirty or not - that command is simply named &quot;isDirty()&quot;. From a Python or C++ you can use the MGlobal::executeCommand() to execute the above two MEL commands, while in Python you can also use the command directly since you can now mix command and API call within the same Python script.</p>
<p>However there is an issue we need to consider - In case plugs are array plugs, you may create what we call internally “fat connection”. A “fat connection” happens when&#0160;connecting array plugs at the root level vs elements. And if the plugs are dynamic as well, there is no way of knowing how many children need to be connected until the evaluation is completed. This is a perfect scenario where &quot;fat connection&quot; are made. It is therefore impossible to dirty a single element with this type of connection because the connection doesn’t even know if that element exists, or even if that element will keep the same logical index on the next evaluation. Since the information required to connect the multi-element is only generated by an evaluation there is no way to do it automatically, ...</p>
<p><a class="asset-img-link" href="http://around-the-corner.typepad.com/.a/6a0163057a21c8970d0177437195fe970d-pi" style="display: inline;"><img alt="Connection_broken" border="0" class="asset  asset-image at-xid-6a0163057a21c8970d0177437195fe970d" src="/assets/image_3ff75b.jpg" style="display: block; margin-left: auto; margin-right: auto;" title="Connection_broken" /></a></p>
<p>... you have to do it manually (and manage any changes in the size or indexes of the element in the output array).</p>
<p><a class="asset-img-link" href="http://around-the-corner.typepad.com/.a/6a0163057a21c8970d01676896a18c970b-pi" style="display: inline;"><img alt="Connections" border="0" class="asset  asset-image at-xid-6a0163057a21c8970d01676896a18c970b" src="/assets/image_b507f2.jpg" style="display: block; margin-left: auto; margin-right: auto;" title="Connections" /></a><br />Therefore, even if you explicitly call the &quot;dgdirty()&quot; command on individual element plug,&#0160;it may only dirty the root plug. Since this command sends a dirty message to a “connected” plug only, and the i&#39;th element plug has no connection itself, it will not dirty this element plug. Therefore the compute() function will not get triggered when the value of the element plug is requested.  The compute() function will only be triggered when the root plug is requested.</p>
<ol> </ol>
